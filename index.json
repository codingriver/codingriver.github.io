[{"categories":["hugo"],"content":"探索 Hugo - LoveIt 主题的全部内容和背后的核心概念.","date":"2020-03-06 21:40:32","objectID":"/theme-documentation-basics/","tags":["hugo"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["hugo"],"content":"探索 Hugo - LoveIt 主题的全部内容和背后的核心概念. ","date":"2020-03-06 21:40:32","objectID":"/theme-documentation-basics/:0:0","tags":["hugo"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["hugo"],"content":"1 准备 由于 Hugo 提供的便利性, Hugo 本身是这个主题唯一的依赖. 直接安装满足你操作系统 (Windows, Linux, macOS) 的最新版本  Hugo (\u003e 0.62.0). 为什么不支持早期版本的 Hugo? 由于 Markdown 渲染钩子函数 在 Hugo 圣诞节版本 中被引入, 本主题只支持高于 0.62.0 的 Hugo 版本. 推荐使用 Hugo extended 版本 由于这个主题的一些特性需要将  SCSS 转换为  CSS, 推荐使用 Hugo extended 版本来获得更好的使用体验. ","date":"2020-03-06 21:40:32","objectID":"/theme-documentation-basics/:1:0","tags":["hugo"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["hugo"],"content":"2 安装 以下步骤可帮助你初始化新网站. 如果你根本不了解 Hugo, 我们强烈建议你按照此 快速入门文档 进一步了解它. ","date":"2020-03-06 21:40:32","objectID":"/theme-documentation-basics/:2:0","tags":["hugo"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["hugo"],"content":"2.1 创建你的项目 Hugo 提供了一个 new 命令来创建一个新的网站: hugo new site my_website cd my_website ","date":"2020-03-06 21:40:32","objectID":"/theme-documentation-basics/:2:1","tags":["hugo"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["hugo"],"content":"2.2 安装主题 LoveIt 主题的仓库是: https://github.com/dillonzq/LoveIt. 你可以下载主题的 最新版本  .zip 文件 并且解压放到 themes 目录. 另外, 也可以直接把这个主题克隆到 themes 目录: git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 或者, 初始化你的项目目录为 git 仓库, 并且把主题仓库作为你的网站目录的子模块: git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt ","date":"2020-03-06 21:40:32","objectID":"/theme-documentation-basics/:2:2","tags":["hugo"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["hugo"],"content":"2.3 基础配置 以下是 LoveIt 主题的基本配置: baseURL = \"http://example.org/\" ## [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" ## 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" ## 是否包括中日韩文字 hasCJKLanguage = true ## 网站标题 title = \"我的全新 Hugo 网站\" ## 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" [params] # LoveIt 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 ## Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false 注意 在构建网站时, 你可以使用 --theme 选项设置主题. 但是, 我建议你修改配置文件 (config.toml) 将本主题设置为默认主题. ","date":"2020-03-06 21:40:32","objectID":"/theme-documentation-basics/:2:3","tags":["hugo"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["hugo"],"content":"2.4 创建你的第一篇文章 以下是创建第一篇文章的方法: hugo new posts/first_post.md 通过添加一些示例内容并替换文件开头的标题, 你可以随意编辑文章. 注意 默认情况下, 所有文章和页面均作为草稿创建. 如果想要渲染这些页面, 请从元数据中删除属性 draft: true, 设置属性 draft: false 或者为 hugo 命令添加 -D/--buildDrafts 参数. ","date":"2020-03-06 21:40:32","objectID":"/theme-documentation-basics/:2:4","tags":["hugo"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["hugo"],"content":"2.5 在本地启动网站 使用以下命令启动网站: hugo serve 去查看 http://localhost:1313. 基本配置下的预览\" 基本配置下的预览 技巧 当你运行 hugo serve 时, 当文件内容更改时, 页面会随着更改自动刷新. 注意 由于本主题使用了 Hugo 中的 .Scratch 来实现一些特性, 非常建议你为 hugo server 命令添加 --disableFastRender 参数来实时预览你正在编辑的文章页面. hugo serve --disableFastRender ","date":"2020-03-06 21:40:32","objectID":"/theme-documentation-basics/:2:5","tags":["hugo"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["hugo"],"content":"2.6 构建网站 当你准备好部署你的网站时, 运行以下命令: hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上. 技巧 网站内容可以通过 Netlify 自动发布和托管 (了解有关通过 Netlify 进行 HUGO 自动化部署 的更多信息). 或者, 您可以使用 AWS Amplify, Github pages, Render 以及更多… ","date":"2020-03-06 21:40:32","objectID":"/theme-documentation-basics/:2:6","tags":["hugo"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["hugo"],"content":"3 配置 ","date":"2020-03-06 21:40:32","objectID":"/theme-documentation-basics/:3:0","tags":["hugo"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["hugo"],"content":"3.1 网站配置 除了 Hugo 全局配置 和 菜单配置 之外, LoveIt 主题还允许您在网站配置中定义以下参数 (这是一个示例 config.toml, 其内容为默认值). 请打开下面的代码块查看完整的示例配置 : [params] # LoveIt 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL avatarURL = \"/images/avatar.png\" # 主页显示的网站标题 (支持 HTML 格式) title = \"\" # 主页显示的网站副标题 subtitle = \"这是我的全新 Hugo 网站\" # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"\" # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \"hiddenFromHomePage\" 时的默认行为 defaultHiddenFromHomePage = false # 作者的社交信息设置 [params.social] GitHub = \"xxxx\" Linkedin = \"\" Twitter = \"xxxx\" Instagram = \"xxxx\" Facebook = \"xxxx\" Telegram = \"xxxx\" Medium = \"\" Gitlab = \"\" Youtubelegacy = \"\" Youtubecustom = \"\" Youtubechannel = \"\" Tumblr = \"\" Quora = \"\" Keybase = \"\" Pinterest = \"\" Reddit = \"\" Codepen = \"\" FreeCodeCamp = \"\" Bitbucket = \"\" Stackoverflow = \"\" Weibo = \"\" Odnoklassniki = \"\" VK = \"\" Flickr = \"\" Xing = \"\" Snapchat = \"\" Soundcloud = \"\" Spotify = \"\" Bandcamp = \"\" Paypal = \"\" Fivehundredpx = \"\" Mix = \"\" Goodreads = \"\" Lastfm = \"\" Foursquare = \"\" Hackernews = \"\" Kickstarter = \"\" Patreon = \"\" Steam = \"\" Twitch = \"\" Strava = \"\" Skype = \"\" Whatsapp = \"\" Zhihu = \"\" Douban = \"\" Angellist = \"\" Slidershare = \"\" Jsfiddle = \"\" Deviantart = \"\" Behance = \"\" Dribbble = \"\" Wordpress = \"\" Vine = \"\" Googlescholar = \"\" Researchgate = \"\" Mastodon = \"\" Thingiverse = \"\" Devto = \"\" Gitea = \"\" XMPP = \"\" Matrix = \"\" Bilibili = \"\" Email = \"xxxx@xxxx.com\" RSS = true # # 文章页面配置 [params.page] # 是否在主页隐藏一篇文章 hiddenFromHomePage = false # 是否在搜索结果中隐藏一篇文章 hiddenFromSearch = false # 是否使用 twemoji twemoji = false # 是否使用 lightgallery lightgallery = false # 是否使用 ruby 扩展语法 ruby = true # 是否使用 fraction 扩展语法 fraction = true # 是否使用 fontawesome 扩展语法 fontawesome = true # 是否在文章页面显示原始 Markdown 文档链接 linkToMarkdown = true # 是否在 RSS 中显示全文内容 rssFullText = ","date":"2020-03-06 21:40:32","objectID":"/theme-documentation-basics/:3:1","tags":["hugo"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["hugo"],"content":"3.2 网站图标, 浏览器配置, 网站清单 强烈建议你把: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在 /static 目录. 利用 https://realfavicongenerator.net/ 可以很容易地生成这些文件. 可以自定义 browserconfig.xml 和 site.webmanifest 文件来设置 theme-color 和 background-color. ","date":"2020-03-06 21:40:32","objectID":"/theme-documentation-basics/:3:2","tags":["hugo"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["hugo"],"content":"3.3 增加网站 logo 和封面用于 SEO 优化 在 static 目录增加一个 logo 图片 (127x40) 和一个封面图片 (800x600). ","date":"2020-03-06 21:40:32","objectID":"/theme-documentation-basics/:3:3","tags":["hugo"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["hugo"],"content":"3.4 自定义样式 注意 Hugo extended 版本对于自定义样式是必需的. 通过定义自定义 .scss 样式文件, LoveIt 主题支持可配置的样式. 包含自定义 .scss 样式文件的目录相对于 你的项目根目录 的路径为 assets/css. 在 assets/css/_override.scss 中, 你可以覆盖 themes/LoveIt/assets/css/_variables.scss 中的变量以自定义样式. 这是一个例子: @import url('https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext'); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; 在 assets/css/_custom.scss 中, 你可以添加一些 CSS 样式代码以自定义样式. ","date":"2020-03-06 21:40:32","objectID":"/theme-documentation-basics/:3:4","tags":["hugo"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["hugo"],"content":"4 多语言和 i18n LoveIt 主题完全兼容 Hugo 的多语言模式, 并且支持在网页上切换语言. 语言切换\" 语言切换 ","date":"2020-03-06 21:40:32","objectID":"/theme-documentation-basics/:4:0","tags":["hugo"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["hugo"],"content":"4.1 兼容性 语言 Hugo 代码 HTML lang 属性 主题文档 Lunr.js 支持 英语 en en 简体中文 zh-cn zh-CN 法语 fr fr 波兰语 pl pl 巴西葡萄牙语 pt-br pt-BR 意大利语 it it 西班牙语 es es 德语 de de 塞尔维亚语 pl pl 俄语 ru ru 罗马尼亚语 ro ro ","date":"2020-03-06 21:40:32","objectID":"/theme-documentation-basics/:4:1","tags":["hugo"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["hugo"],"content":"4.2 基本配置 学习了 Hugo如何处理多语言网站 之后, 请在 站点配置 中定义你的网站语言. 例如, 一个支持英语, 中文和法语的网站配置: ## [en, zh-cn, fr, pl, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" [languages] [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" title = \"\" weight = 1 [[languages.en.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" weight = 2 [[languages.en.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" weight = 3 [languages.zh-cn] weight = 2 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true [[languages.zh-cn.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"文章\" url = \"/posts/\" title = \"\" weight = 1 [[languages.zh-cn.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[languages.zh-cn.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 [languages.fr] weight = 3 title = \"Mon nouveau site Hugo\" languageCode = \"fr\" languageName = \"Français\" [[languages.fr.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Postes\" url = \"/posts/\" title = \"\" weight = 1 [[languages.fr.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Balises\" url = \"/tags/\" title = \"\" weight = 2 [[languages.fr.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Catégories\" url = \"/categories/\" title = \"\" weight = 3 然后, 对于每个新页面, 将语言代码附加到文件名中. 单个文件 my-page.md 需要分为三个文件: 英语: my-page.en.md 中文: my-page.zh-cn.md 法语: my-page.fr.md 注意 请注意, 菜单中仅显示翻译的页面. 它不会替换为默认语言内容. 技巧 也可以使用 文章前置参数 来翻译网址. ","date":"2020-03-06 21:40:32","objectID":"/theme-documentation-basics/:4:2","tags":["hugo"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["hugo"],"content":"4.3 修改默认的翻译字符串 翻译字符串用于在主题中使用的常见默认值. 目前提供一些语言的翻译, 但你可能自定义其他语言或覆盖默认值. 要覆盖默认值, 请在你项目的 i18n 目录 i18n/\u003clanguageCode\u003e.toml 中创建一个新文件，并从 themes/LoveIt/i18n/en.toml 中获得提示. 另外, 由于你的翻译可能会帮助到其他人, 请花点时间通过  创建一个 PR 来贡献主题翻译, 谢谢! ","date":"2020-03-06 21:40:32","objectID":"/theme-documentation-basics/:4:3","tags":["hugo"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["hugo"],"content":"5 搜索 基于 Lunr.js 或 algolia, LoveIt 主题支持搜索功能. ","date":"2020-03-06 21:40:32","objectID":"/theme-documentation-basics/:5:0","tags":["hugo"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["hugo"],"content":"5.1 输出配置 为了生成搜索功能所需要的 index.json, 请在你的 网站配置 中添加 JSON 输出文件类型到 outputs 部分的 home 字段中. [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2020-03-06 21:40:32","objectID":"/theme-documentation-basics/:5:1","tags":["hugo"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["hugo"],"content":"5.2 搜索配置 基于 Hugo 生成的 index.json 文件, 你可以激活搜索功能. 这是你的 网站配置 中的搜索部分: [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" 怎样选择搜索引擎? 以下是两种搜索引擎的对比: lunr: 简单, 无需同步 index.json, 没有 contentLength 的限制, 但占用带宽大且性能低 (特别是中文需要一个较大的分词依赖库) algolia: 高性能并且占用带宽低, 但需要同步 index.json 且有 contentLength 的限制 文章内容被 h2 和 h3 HTML 标签切分来提高查询效果并且基本实现全文搜索. contentLength 用来限制 h2 和 h3 HTML 标签开头的内容部分的最大长度. 关于 algolia 的使用技巧 你需要上传 index.json 到 algolia 来激活搜索功能. 你可以使用浏览器来上传 index.json 文件但是一个自动化的脚本可能效果更好. Algolia Atomic 是一个不错的选择. 为了兼容 Hugo 的多语言模式, 你需要上传不同语言的 index.json 文件到对应的 algolia index, 例如 zh-cn/index.json 或 fr/index.json… ","date":"2020-03-06 21:40:32","objectID":"/theme-documentation-basics/:5:2","tags":["hugo"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["hugo"],"content":"了解如何在 LoveIt 主题中快速, 直观地创建和组织内容.","date":"2020-03-05 16:30:05","objectID":"/theme-documentation-content/","tags":["hugo"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["hugo"],"content":"了解如何在 LoveIt 主题中快速, 直观地创建和组织内容. ","date":"2020-03-05 16:30:05","objectID":"/theme-documentation-content/:0:0","tags":["hugo"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["hugo"],"content":"1 内容组织 以下是一些方便你清晰管理和生成文章的目录结构建议: 保持博客文章存放在 content/posts 目录, 例如: content/posts/我的第一篇文章.md 保持简单的静态页面存放在 content 目录, 例如: content/about.md 保持图片之类的媒体资源存放在 static 目录, 例如: static/images/screenshot.png ","date":"2020-03-05 16:30:05","objectID":"/theme-documentation-content/:1:0","tags":["hugo"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["hugo"],"content":"2 前置参数 Hugo 允许你在文章内容前面添加 yaml, toml 或者 json 格式的前置参数. 注意 不是所有的以下前置参数都必须在你的每篇文章中设置. 只有在文章的参数和你的 网站设置 中的 page 部分不一致时才有必要这么做. 这是一个前置参数例子: ---title:\"我的第一篇文章\"subtitle:\"\"date:2020-03-04T15:58:26+08:00lastmod:2020-03-04T15:58:26+08:00draft:trueauthor:\"\"authorLink:\"\"description:\"\"license:\"\"images:[]tags:[]categories:[]featuredImage:\"\"featuredImagePreview:\"\"hiddenFromHomePage:falsehiddenFromSearch:falsetwemoji:falselightgallery:trueruby:truefraction:truefontawesome:truelinkToMarkdown:truerssFullText:falsetoc:enable:trueauto:truecode:copy:true# ...math:enable:true# ...mapbox:accessToken:\"\"# ...share:enable:true# ...comment:enable:true# ...library:css:# someCSS = \"some.css\"# 位于 \"assets/\"# 或者# someCSS = \"https://cdn.example.com/some.css\"js:# someJS = \"some.js\"# 位于 \"assets/\"# 或者# someJS = \"https://cdn.example.com/some.js\"--- title: 文章标题. subtitle: 文章副标题. date: 这篇文章创建的日期时间. 它通常是从文章的前置参数中的 date 字段获取的, 但是也可以在 网站配置 中设置. lastmod: 上次修改内容的日期时间. draft: 如果设为 true, 除非 hugo 命令使用了 --buildDrafts/-D 参数, 这篇文章不会被渲染. author: 文章作者. authorLink: 文章作者的链接. description: 文章内容的描述. license: 这篇文章特殊的许可. images: 页面图片, 用于 Open Graph 和 Twitter Cards. tags: 文章的标签. categories: 文章所属的类别. featuredImage: 文章的特色图片. featuredImagePreview: 用在主页预览的文章特色图片. hiddenFromHomePage: 如果设为 true, 这篇文章将不会显示在主页上. hiddenFromSearch: 如果设为 true, 这篇文章将不会显示在搜索结果中. twemoji: 如果设为 true, 这篇文章会使用 twemoji. lightgallery: 如果设为 true, 文章中的图片将可以按照画廊形式呈现. ruby: 如果设为 true, 这篇文章会使用 上标注释扩展语法. fraction: 如果设为 true, 这篇文章会使用 分数扩展语法. fontawesome: 如果设为 true, 这篇文章会使用 Font Awesome 扩展语法. linkToMarkdown: 如果设为 true, 内容的页脚将显示指向原始 Markdown 文件的链接. rssFullText: 如果设为 true, 在 RSS 中将会显示全文内容. toc: 和 网站配置 中的 params.page.toc 部分相同. code: 和 网站配置 中的 params.page.code 部分相同. math: 和 网站配置 中的 params.page.math 部分相同. mapbox: 和 网站配置 中的 params.page.mapbox 部分相同. share: 和 网站配置 中的 params.page.share 部分相同. comment: 和 网站配置 中的 params.page.comment 部分相同. library: 和 网站配置 中的 params.page.library 部分相同. ","date":"2020-03-05 16:30:05","objectID":"/theme-documentation-content/:2:0","tags":["hugo"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["hugo"],"content":"3 内容摘要 LoveIt 主题使用内容摘要在主页中显示大致文章信息。Hugo 支持生成文章的摘要. 文章摘要预览\" 文章摘要预览 ","date":"2020-03-05 16:30:05","objectID":"/theme-documentation-content/:3:0","tags":["hugo"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["hugo"],"content":"自动摘要拆分 默认情况下, Hugo 自动将内容的前 70 个单词作为摘要. 你可以通过在 网站配置 中设置 summaryLength 来自定义摘要长度. 如果您要使用 CJK中文/日语/韩语 语言创建内容, 并且想使用 Hugo 的自动摘要拆分功能，请在 网站配置 中将 hasCJKLanguage 设置为 true. ","date":"2020-03-05 16:30:05","objectID":"/theme-documentation-content/:3:1","tags":["hugo"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["hugo"],"content":"手动摘要拆分 另外, 你也可以添加 \u003c!--more--\u003e 摘要分割符来拆分文章生成摘要. 摘要分隔符之前的内容将用作该文章的摘要. 注意 请小心输入\u003c!--more--\u003e ; 即全部为小写且没有空格. ","date":"2020-03-05 16:30:05","objectID":"/theme-documentation-content/:3:2","tags":["hugo"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["hugo"],"content":"前置参数摘要 你可能希望摘要不是文章开头的文字. 在这种情况下, 你可以在文章前置参数的 summary 变量中设置单独的摘要. ","date":"2020-03-05 16:30:05","objectID":"/theme-documentation-content/:3:3","tags":["hugo"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["hugo"],"content":"使用文章描述作为摘要 你可能希望将文章前置参数中的 description 变量的内容作为摘要. 你仍然需要在文章开头添加 \u003c!--more--\u003e 摘要分割符. 将摘要分隔符之前的内容保留为空. 然后 LoveIt 主题会将你的文章描述作为摘要. ","date":"2020-03-05 16:30:05","objectID":"/theme-documentation-content/:3:4","tags":["hugo"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["hugo"],"content":"摘要选择的优先级顺序 由于可以通过多种方式指定摘要, 因此了解顺序很有用. 如下: 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 但分隔符之前没有内容, 则使用描述作为摘要. 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 则将按照手动摘要拆分的方法获得摘要. 如果文章前置参数中有摘要变量, 那么将以该值作为摘要. 按照自动摘要拆分方法. 注意 不建议在摘要内容中包含富文本块元素, 这会导致渲染错误. 例如代码块, 图片, 表格等. ","date":"2020-03-05 16:30:05","objectID":"/theme-documentation-content/:3:5","tags":["hugo"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["hugo"],"content":"4 Markdown 基本语法 这部分内容在 Markdown 基本语法页面 中介绍. ","date":"2020-03-05 16:30:05","objectID":"/theme-documentation-content/:4:0","tags":["hugo"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["hugo"],"content":"5 Markdown 扩展语法 LoveIt 主题提供了一些扩展的语法便于你撰写文章. ","date":"2020-03-05 16:30:05","objectID":"/theme-documentation-content/:5:0","tags":["hugo"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["hugo"],"content":"Emoji 支持 这部分内容在 Emoji 支持页面 中介绍. ","date":"2020-03-05 16:30:05","objectID":"/theme-documentation-content/:5:1","tags":["hugo"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["hugo"],"content":"数学公式 LoveIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. 技巧 有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单. 公式块 默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 行内公式 默认的行内公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈现的输出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 技巧 你可以在 网站配置 中自定义公式块和行内公式的分割符. Copy-tex Copy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. mhchem mhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-05 16:30:05","objectID":"/theme-documentation-content/:5:2","tags":["hugo"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["hugo"],"content":"字符注音或者注释 LoveIt 主题支持一种 字符注音或者注释 Markdown 扩展语法: [Hugo]^(一个开源的静态网站生成工具) 呈现的输出效果如下: Hugo一个开源的静态网站生成工具 ","date":"2020-03-05 16:30:05","objectID":"/theme-documentation-content/:5:3","tags":["hugo"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["hugo"],"content":"分数 LoveIt 主题支持一种 分数 Markdown 扩展语法: [浅色]/[深色] [99]/[100] 呈现的输出效果如下: 浅色/深色 90/100 ","date":"2020-03-05 16:30:05","objectID":"/theme-documentation-content/:5:4","tags":["hugo"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["hugo"],"content":"Font Awesome LoveIt 主题使用 Font Awesome 作为图标库. 你同样可以在文章中轻松使用这些图标. 从 Font Awesome 网站 上获取所需的图标 class. 去露营啦! :(fas fa-campground fa-fw): 很快就回来. 真开心! :(far fa-grin-tears): 呈现的输出效果如下: 去露营啦!  很快就回来. 真开心! ","date":"2020-03-05 16:30:05","objectID":"/theme-documentation-content/:5:5","tags":["hugo"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["hugo"],"content":"转义字符 在某些特殊情况下 (编写这个主题文档时 ), 你的文章内容会与 Markdown 的基本或者扩展语法冲突, 并且无法避免. 转义字符语法可以帮助你渲染出想要的内容: {?X} -\u003e X 例如, 两个 : 会启用 emoji 语法. 但有时候这不是你想要的结果. 可以像这样使用转义字符语法: {?:}joy: 呈现的输出效果如下: :joy: 而不是 😂 技巧 这个方法可以间接解决一个还未解决的 Hugo 的 issue. 另一个例子是: [link{?]}(#escape-character) 呈现的输出效果如下: [link](#escape-character) 而不是 link. ","date":"2020-03-05 16:30:05","objectID":"/theme-documentation-content/:5:6","tags":["hugo"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["hugo"],"content":"Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁.","date":"2020-03-04 16:29:59","objectID":"/theme-documentation-built-in-shortcodes/","tags":["hugo"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["hugo"],"content":"Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁. Hugo 使用 Markdown 为其简单的内容格式. 但是, Markdown 在很多方面都无法很好地支持. 你可以使用纯 HTML 来扩展可能性. 但这恰好是一个坏主意. 大家使用 Markdown, 正是因为它即使不经过渲染也可以轻松阅读. 应该尽可能避免使用 HTML 以保持内容简洁. 为了避免这种限制, Hugo 创建了 shortcodes. shortcode 是一个简单代码段, 可以生成合理的 HTML 代码, 并且符合 Markdown 的设计哲学. Hugo 附带了一组预定义的 shortcodes, 它们实现了一些非常常见的用法. 提供这些 shortcodes 是为了方便保持你的 Markdown 内容简洁. ","date":"2020-03-04 16:29:59","objectID":"/theme-documentation-built-in-shortcodes/:0:0","tags":["hugo"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["hugo"],"content":"1 figure figure 的文档 一个 figure 示例: {{\u003c figure src=\"/images/theme-documentation-built-in-shortcodes/lighthouse.jpg\" title=\"Lighthouse (figure)\" \u003e}} 呈现的输出效果如下: Lighthouse (figure) 输出的 HTML 看起来像这样: \u003cfigure\u003e \u003cimg src=\"/images/theme-documentation-built-in-shortcodes/lighthouse.jpg\"/\u003e \u003cfigcaption\u003e \u003ch4\u003eLighthouse (figure)\u003c/h4\u003e \u003c/figcaption\u003e \u003c/figure\u003e ","date":"2020-03-04 16:29:59","objectID":"/theme-documentation-built-in-shortcodes/:1:0","tags":["hugo"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["hugo"],"content":"2 gist gist 的文档 一个 gist 示例: {{\u003c gist spf13 7896402 \u003e}} 呈现的输出效果如下: 输出的 HTML 看起来像这样: \u003cscript type=\"application/javascript\" src=\"https://gist.github.com/spf13/7896402.js\"\u003e\u003c/script\u003e ","date":"2020-03-04 16:29:59","objectID":"/theme-documentation-built-in-shortcodes/:2:0","tags":["hugo"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["hugo"],"content":"3 highlight highlight 的文档 一个 highlight 示例: {{\u003c highlight html \u003e}} \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e {{\u003c /highlight \u003e}} 呈现的输出效果如下: \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e ","date":"2020-03-04 16:29:59","objectID":"/theme-documentation-built-in-shortcodes/:3:0","tags":["hugo"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["hugo"],"content":"4 instagram instagram 的文档 一个 instagram 示例: {{\u003c instagram BWNjjyYFxVx hidecaption \u003e}} 呈现的输出效果如下: \\}\\}-- ","date":"2020-03-04 16:29:59","objectID":"/theme-documentation-built-in-shortcodes/:4:0","tags":["hugo"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["hugo"],"content":"5 param param 的文档 一个 param 示例: {{\u003c param description \u003e}} 呈现的输出效果如下: Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁. ","date":"2020-03-04 16:29:59","objectID":"/theme-documentation-built-in-shortcodes/:5:0","tags":["hugo"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["hugo"],"content":"6 ref 和 relref ref 和 relref 的文档 ","date":"2020-03-04 16:29:59","objectID":"/theme-documentation-built-in-shortcodes/:6:0","tags":["hugo"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["hugo"],"content":"7 tweet tweet 的文档 一个 tweet 示例: {{\u003c tweet 877500564405444608 \u003e}} 呈现的输出效果如下: \\}\\}-- ","date":"2020-03-04 16:29:59","objectID":"/theme-documentation-built-in-shortcodes/:7:0","tags":["hugo"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["hugo"],"content":"8 vimeo vimeo 的文档 一个 vimeo 示例: {{\u003c vimeo 146022717 \u003e}} 呈现的输出效果如下: ","date":"2020-03-04 16:29:59","objectID":"/theme-documentation-built-in-shortcodes/:8:0","tags":["hugo"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["hugo"],"content":"9 youtube youtube 的文档 一个 youtube 示例: {{\u003c youtube w7Ft2ymGmfc \u003e}} 呈现的输出效果如下: ","date":"2020-03-04 16:29:59","objectID":"/theme-documentation-built-in-shortcodes/:9:0","tags":["hugo"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["hugo"],"content":"LoveIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode.","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"LoveIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode. ","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/:0:0","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"1 style 注意 Hugo extended 版本对于 style shortcode 是必需的. style shortcode 用来在你的文章中插入自定义样式. style shortcode 有两个位置参数. 第一个参数是自定义样式的内容. 它支持  SASS 中的嵌套语法, 并且 \u0026 指代这个父元素. 第二个参数是包裹你要更改样式的内容的 HTML 标签, 默认值是 div. 一个 style 示例: {{\u003c style \"text-align:right; strong{color:#00b1ff;}\" \u003e}} This is a **right-aligned** paragraph. {{\u003c /style \u003e}} 呈现的输出效果如下: This is a right-aligned paragraph. ","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/:1:0","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"2 link link shortcode 是 Markdown 链接语法 的替代. link shortcode 可以提供一些其它的功能并且可以在代码块中使用. link shortcode 有以下命名参数: href [必需] (第一个位置参数) 链接的目标. content [可选] (第二个位置参数) 链接的内容, 默认值是 href 参数的值. 支持 Markdown 或者 HTML 格式. title [可选] (第三个位置参数) HTML a 标签 的 title 属性, 当悬停在链接上会显示的提示. rel [可选] HTML a 标签 的 rel 补充属性. class [可选] HTML a 标签 的 class 属性. 一个 link 示例: {{\u003c link \"https://assemble.io\" \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" \u003e}} {{\u003c link \"mailto:contact@revolunet.com\" \u003e}} 或者 {{\u003c link href=\"mailto:contact@revolunet.com\" \u003e}} {{\u003c link \"https://assemble.io\" Assemble \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" content=Assemble \u003e}} 呈现的输出效果如下: https://assemble.io mailto:contact@revolunet.com Assemble 一个带有标题的 link 示例: {{\u003c link \"https://github.com/upstage/\" Upstage \"Visit Upstage!\" \u003e}} 或者 {{\u003c link href=\"https://github.com/upstage/\" content=Upstage title=\"Visit Upstage!\" \u003e}} 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage ","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/:2:0","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"3 image image shortcode 是 figure shortcode 的替代. image shortcode 可以充分利用 lazysizes 和 lightgallery.js 两个依赖库. image shortcode 有以下命名参数: src [必需] (第一个位置参数) 图片的 URL. alt [可选] (第二个位置参数) 图片无法显示时的替代文本, 默认值是 src 参数的值. 支持 Markdown 或者 HTML 格式. caption [可选] (第三个位置参数) 图片标题. 支持 Markdown 或者 HTML 格式. title [可选] 当悬停在图片上会显示的提示. class [可选] HTML figure 标签的 class 属性. src_s [可选] 图片缩略图的 URL, 用在画廊模式中, 默认值是 src 参数的值. src_l [可选] 高清图片的 URL, 用在画廊模式中, 默认值是 src 参数的值. height [可选] 图片的 height 属性. width [可选] 图片的 width 属性. linked [可选] 图片是否需要被链接, 默认值是 true. rel [可选] HTML a 标签 的 rel 补充属性, 仅在 linked 属性设置成 true 时有效. large [可选] 图片是否是大尺寸的, 用来加载动画, 仅在 linked 属性设置成 false 时有效. 一个 image 示例: {{\u003c image src=\"/images/theme-documentation-extended-shortcodes/lighthouse.jpg\" caption=\"Lighthouse (`image`)\" src-s=\"/images/theme-documentation-extended-shortcodes/lighthouse-small.jpg\" src-l=\"/images/theme-documentation-extended-shortcodes/lighthouse-large.jpg\" \u003e}} 呈现的输出效果如下: Lighthouse (image)\" Lighthouse (image) ","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/:3:0","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"4 admonition admonition shortcode 支持 12 种 帮助你在页面中插入提示的横幅. 支持 Markdown 或者 HTML 格式. 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 admonition shortcode 有以下命名参数: type [必需] (第一个位置参数) admonition 横幅的类型, 默认值是 note. title [可选] (第二个位置参数) admonition 横幅的标题, 默认值是 type 参数的值. open [可选] (第三个位置参数) 横幅内容是否默认展开, 默认值是 true. 一个 admonition 示例: {{\u003c admonition type=tip title=\"This is a tip\" open=false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 或者 {{\u003c admonition tip \"This is a tip\" false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 呈现的输出效果如下: This is a tip 一个 技巧 横幅 ","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/:4:0","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"5 mermaid mermaid 是一个可以帮助你在文章中生成图表和流程图的库, 类似 Markdown 的语法. 只需将你的 mermaid 代码插入 mermaid shortcode 中即可. ","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/:5:0","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"5.1 流程图 一个 流程图 mermaid 示例: {{\u003c mermaid \u003e}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/:5:1","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"5.2 时序图 一个 时序图 mermaid 示例: {{\u003c mermaid \u003e}} sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/:5:2","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"5.3 甘特图 一个 甘特图 mermaid 示例: {{\u003c mermaid \u003e}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/:5:3","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"5.4 类图 一个 类图 mermaid 示例: {{\u003c mermaid \u003e}} classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/:5:4","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"5.5 状态图 一个 状态图 mermaid 示例: {{\u003c mermaid \u003e}} stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/:5:5","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"5.6 Git 图 一个 Git 图 mermaid 示例: {{\u003c mermaid \u003e}} gitGraph: options { \"nodeSpacing\": 100, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/:5:6","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"5.7 饼图 一个 饼图 mermaid 示例: {{\u003c mermaid \u003e}} pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/:5:7","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"6 echarts ECharts 是一个帮助你生成交互式数据可视化的库. ECharts 提供了常规的 折线图, 柱状图, 散点图, 饼图, K线图, 用于统计的 盒形图, 用于地理数据可视化的 地图, 热力图, 线图, 用于关系数据可视化的 关系图, treemap, 旭日图, 多维数据可视化的 平行坐标, 还有用于 BI 的 漏斗图, 仪表盘, 并且支持图与图之间的混搭. 只需在 echarts shortcode 中以 JSON/YAML/TOML格式插入 ECharts 选项即可. 一个 JSON 格式的 echarts 示例: {{\u003c echarts \u003e}} { \"title\": { \"text\": \"折线统计图\", \"top\": \"2%\", \"left\": \"center\" }, \"tooltip\": { \"trigger\": \"axis\" }, \"legend\": { \"data\": [\"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\"], \"top\": \"10%\" }, \"grid\": { \"left\": \"5%\", \"right\": \"5%\", \"bottom\": \"5%\", \"top\": \"20%\", \"containLabel\": true }, \"toolbox\": { \"feature\": { \"saveAsImage\": { \"title\": \"保存为图片\" } } }, \"xAxis\": { \"type\": \"category\", \"boundaryGap\": false, \"data\": [\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"] }, \"yAxis\": { \"type\": \"value\" }, \"series\": [ { \"name\": \"邮件营销\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [120, 132, 101, 134, 90, 230, 210] }, { \"name\": \"联盟广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [220, 182, 191, 234, 290, 330, 310] }, { \"name\": \"视频广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [150, 232, 201, 154, 190, 330, 410] }, { \"name\": \"直接访问\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [320, 332, 301, 334, 390, 330, 320] }, { \"name\": \"搜索引擎\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [820, 932, 901, 934, 1290, 1330, 1320] } ] } {{\u003c /echarts \u003e}} 一个 YAML 格式的 echarts 示例: {{\u003c echarts \u003e}}title:text:折线统计图top:2%left:centertooltip:trigger:axislegend:data:- 邮件营销- 联盟广告- 视频广告- 直接访问- 搜索引擎top:10%grid:left:5%right:5%bottom:5%top:20%containLabel:truetoolbox:feature:saveAsImage:title:保存为图片xAxis:type:categoryboundaryGap:falsedata:- 周一- 周二- 周三- 周四- 周五- 周六- 周日yAxis:type:valueseries:- name:邮件营销type:linestack:总量data:- 120- 132- 101- 134- 90- 230- 210- name:联盟广告type:linestack:总量data:- 220- 182- 191- 234- 290- 330- 310- name:视频广告type:linestack:总量data:- 150- 232- 201- 154- 190- 330- 410- name:直接访问type:linestack:总量data:- 320- 332- 301- 334- 390- 330- 320- name:搜索引擎type:linestack:总量data:- 820- 932- 901- 934- 1290- 1330- 1320{{\u003c /echarts \u003e}} 一个 TOML 格式的 echarts 示例: {{\u003c echarts \u003e}} [title] text = \"折线统计图\" top = \"2%\" left = \"center\" [tooltip] trigger = \"axis\" [legend] data = [ \"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\" ] top = \"10%\" [grid] left = \"5%\" right = \"5%\" bottom = \"5%\" top = \"20%\" containLabel = true [toolbox] [toolbox.feature] [toolbox.feature.saveAsImage] title = \"保存为图片\" [xAxis] type = \"category\" boundaryGap = false data = [ \"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\" ] [yAxis] type = \"value\" [[series]] name = \"邮件营销\" type = \"line\" stack = \"总量\" data = [ 120.0, 132.0, 101.0, 134.0, 90.0, 230.0, 210.0 ] [[series]] name = \"联盟广告\" type = \"line\" stack = \"总量\" data = [ 220.0, 182.0, 191.0, 234.0, 290.0, 330.0, 310.0 ] [[series]] name = \"视频广告\" type = \"line\" stack = \"总量\" data = [ 150.0, 232.0, 201.0, 154.0, 190.0, 330.0, 410.0 ] [[series]] name = \"直接访问\" type = \"line\" stack = \"总量\" data = [ 320.0, 332.0, 301.0, 334.0, 390.0, 330.0, 320.0 ] [[series]] name = \"搜索引擎\" type = \"line\" stack = \"总量\" data = [ 820.0, 932.0, 901.0, 934.0, 1290.0, 1330.0, 1320.0 ] {{\u003c /echarts \u003e}} 呈现的输出效果如下: echarts shortcode 还有以下命名参数: width [可选] (第一个位置参数) 数据可视化的宽度, 默认值是 100%. height [可选] (第二个位置参数) 数据可视化的高度, 默认值是 30rem. ","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/:6:0","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"7 mapbox Mapbox GL JS 是一个 JavaScript 库，它使用 WebGL, 以 vector tiles 和 Mapbox styles 为来源, 将它们渲染成互动式地图. mapbox shortcode 有以下命名参数来使用 Mapbox GL JS: lng [必需] (第一个位置参数) 地图初始中心点的经度, 以度为单位. lat [必需] (第二个位置参数) 地图初始中心点的纬度, 以度为单位. zoom [可选] (第三个位置参数) 地图的初始缩放级别, 默认值是 10. marked [可选] (第四个位置参数) 是否在地图的初始中心点添加图钉, 默认值是 true. light-style [可选] (第五个位置参数) 浅色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. dark-style [可选] (第六个位置参数) 深色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. navigation [可选] 是否添加 NavigationControl, 默认值是前置参数或者网站配置中设置的值. geolocate [可选] 是否添加 GeolocateControl, 默认值是前置参数或者网站配置中设置的值. scale [可选] 是否添加 ScaleControl, 默认值是前置参数或者网站配置中设置的值. fullscreen [可选] 是否添加 FullscreenControl, 默认值是前置参数或者网站配置中设置的值. width [可选] 地图的宽度, 默认值是 100%. height [可选] 地图的高度, 默认值是 20rem. 一个简单的 mapbox 示例: {{\u003c mapbox 121.485 31.233 12 \u003e}} 或者 {{\u003c mapbox lng=121.485 lat=31.233 zoom=12 \u003e}} 呈现的输出效果如下: 一个带有自定义样式的 mapbox 示例: {{\u003c mapbox -122.252 37.453 10 false \"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 或者 {{\u003c mapbox lng=-122.252 lat=37.453 zoom=10 marked=false light-style=\"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/:7:0","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"8 music music shortcode 基于 APlayer 和 MetingJS 提供了一个内嵌的响应式音乐播放器. 有三种方式使用 music shortcode. ","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/:8:0","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"8.1 自定义音乐 URL music shortcode 有以下命名参数来使用自定义音乐 URL: server [必需] 音乐的链接. type [可选] 音乐的名称. artist [可选] 音乐的创作者. cover [可选] 音乐的封面链接. 一个使用自定义音乐 URL 的 music 示例: {{\u003c music url=\"/music/Wavelength.mp3\" name=Wavelength artist=oldmanyoung cover=\"/images/theme-documentation-extended-shortcodes/Wavelength.jpg\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/:8:1","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"8.2 音乐平台 URL 的自动识别 music shortcode 有一个命名参数来使用音乐平台 URL 的自动识别: auto [必需]] (第一个位置参数) 用来自动识别的音乐平台 URL, 支持 netease, tencent 和 xiami 平台. 一个使用音乐平台 URL 的自动识别的 music 示例: {{\u003c music auto=\"https://music.163.com/#/playlist?id=60198\" \u003e}} 或者 {{\u003c music \"https://music.163.com/#/playlist?id=60198\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/:8:2","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"8.3 自定义音乐平台, 类型和 ID music shortcode 有以下命名参数来使用自定义音乐平台: server [必需] (第一个位置参数) [netease, tencent, kugou, xiami, baidu] 音乐平台. type [必需] (第二个位置参数) [song, playlist, album, search, artist] 音乐类型. id [必需] (第三个位置参数) 歌曲 ID, 或者播放列表 ID, 或者专辑 ID, 或者搜索关键词, 或者创作者 ID. 一个使用自定义音乐平台的 music 示例: {{\u003c music server=\"netease\" type=\"song\" id=\"1868553\" \u003e}} 或者 {{\u003c music netease song 1868553 \u003e}} 呈现的输出效果如下: ","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/:8:3","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"8.4 其它参数 music shortcode 有一些可以应用于以上三种方式的其它命名参数: theme [可选] 音乐播放器的主题色, 默认值是 #448aff. fixed [可选] 是否开启固定模式, 默认值是 false. mini [可选] 是否开启迷你模式, 默认值是 false. autoplay [可选] 是否自动播放音乐, 默认值是 false. volume [可选] 第一次打开播放器时的默认音量, 会被保存在浏览器缓存中, 默认值是 0.7. mutex [可选] 是否自动暂停其它播放器, 默认值是 true. music shortcode 还有一些只适用于音乐列表方式的其它命名参数: loop [可选] [all, one, none] 音乐列表的循环模式, 默认值是 none. order [可选] [list, random] 音乐列表的播放顺序, 默认值是 list. list-folded [可选] 初次打开的时候音乐列表是否折叠, 默认值是 false. list-max-height [可选] 音乐列表的最大高度, 默认值是 340px. ","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/:8:4","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"9 bilibili bilibili shortcode 提供了一个内嵌的用来播放 bilibili 视频的响应式播放器. 如果视频只有一个部分, 则仅需要视频的 BV id, 例如: https://www.bilibili.com/video/BV1Sx411T7QQ 一个 bilibili 示例: {{\u003c bilibili BV1Sx411T7QQ \u003e}} 或者 {{\u003c bilibili id=BV1Sx411T7QQ \u003e}} 呈现的输出效果如下: 如果视频包含多个部分, 则除了视频的 BV id 之外, 还需要 p, 默认值为 1, 例如: https://www.bilibili.com/video/BV1TJ411C7An?p=3 一个带有 p 参数的 bilibili 示例: {{\u003c bilibili BV1TJ411C7An 3 \u003e}} 或者 {{\u003c bilibili id=BV1TJ411C7An p=3 \u003e}} 呈现的输出效果如下: ","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/:9:0","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"10 typeit typeit shortcode 基于 TypeIt 提供了打字动画. 只需将你需要打字动画的内容插入 typeit shortcode 中即可. ","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/:10:0","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"10.1 简单内容 允许使用 Markdown 格式的简单内容, 并且 不包含 富文本的块内容, 例如图像等等… 一个 typeit 示例: {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: 另外, 你也可以自定义 HTML 标签. 一个带有 h4 标签的 typeit 示例: {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/:10:1","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"10.2 代码内容 代码内容也是允许的, 并且通过使用参数 code 指定语言类型可以实习语法高亮. 一个带有 code 参数的 typeit 示例: {{\u003c typeit code=java \u003e}} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/:10:2","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"10.3 分组内容 默认情况下, 所有打字动画都是同时开始的. 但是有时你可能需要按顺序开始一组 typeit 内容的打字动画. 一组具有相同 group 参数值的 typeit 内容将按顺序开始打字动画. 一个带有 group 参数的 typeit 示例: {{\u003c typeit group=paragraph \u003e}} **首先**, 这个段落开始 {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **然后**, 这个段落开始 {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/:10:3","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"11 script script shortcode 用来在你的文章中插入  Javascript 脚本. 注意 脚本内容可以保证在所有的第三方库加载之后按顺序执行. 所以你可以自由地使用第三方库. 一个 script 示例: {{\u003c script \u003e}} console.log('Hello LoveIt!'); {{\u003c /script \u003e}} 你可以在开发者工具的控制台中看到输出. ","date":"2020-03-03 16:29:59","objectID":"/theme-documentation-extended-shortcodes/:11:0","tags":["hugo"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["hugo"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例. 注意 这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 Loveit 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. 事实上, 编写 Web 内容很麻烦. WYSIWYG所见即所得 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑. 没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式! 技巧  将此页保存为书签，以备将来参考! ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:0:0","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID 要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:1:0","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:2:0","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:3:0","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"4 段落 按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:4:0","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"5 内联 HTML 元素 如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e 这是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落. ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:5:0","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"6 强调 ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:6:0","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"加粗 用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** __渲染为粗体__ 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:6:1","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"斜体 用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. *渲染为斜体* _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:6:2","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:6:3","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"组合 加粗, 斜体, 和删除线可以 组合使用. ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除线和斜体*~~ ~~***加粗, 斜体和删除线***~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:6:4","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"7 引用 用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:7:0","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"8 列表 ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:8:0","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"无序列表 一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: * 一项内容 - 一项内容 + 一项内容 例如: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:8:1","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"有序列表 一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧 如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:8:2","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"任务列表 任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框，请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:8:3","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"9 代码 ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:9:0","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"行内代码 用 ` 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:9:1","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"缩进代码 将几行代码缩进至少四个空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments line 1 of code line 2 of code line 3 of code 输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:9:2","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:9:3","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意 Hugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode. ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:9:4","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐 在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:10:0","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"11 链接 ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:11:0","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上，没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:11:1","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:11:2","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意 定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了. ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:11:3","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"12 脚注 脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:12:0","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"13 图片 图片的语法与链接相似, 但包含一个在前面的感叹号. ![](https://octodex.github.com/images/minion.png) 或者: ![](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The Stormtroopocat\" The Stormtroopocat 像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The DojocatAlt text \" The Dojocat 稍后在文档中提供参考内容, 用来定义 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 技巧 LoveIt 主题提供了一个包含更多功能的 图片的 shortcode. 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2019-12-01 21:57:40","objectID":"/basic-markdown-syntax/:13:0","tags":["hugo"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["hugo"],"content":"Hugo 和 LoveIt 中的 Emoji 的用法指南.","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"Emoji 可以通过多种方式在 Hugo 项目中启用. emojify 方法可以直接在模板中调用, 或者使用行内 Shortcodes. 要全局使用 emoji, 需要在你的网站配置中设置 enableEmoji 为 true, 然后你就可以直接在文章中输入 emoji 的代码. 它们以冒号开头和结尾，并且包含 emoji 的 代码: 去露营啦! :tent: 很快就回来. 真开心! :joy: 呈现的输出效果如下: 去露营啦! ⛺ 很快就回来. 真开心! 😂 以下符号清单是 emoji 代码的非常有用的参考. ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:0:0","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"表情与情感 ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:1:0","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"笑脸表情 图标 代码 图标 代码 😀 grinning 😃 smiley 😄 smile 😁 grin 😆 laughing satisfied 😅 sweat_smile 🤣 rofl 😂 joy 🙂 slightly_smiling_face 🙃 upside_down_face 😉 wink 😊 blush 😇 innocent ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:1:1","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"爱意表情 图标 代码 图标 代码 😍 heart_eyes 😘 kissing_heart 😗 kissing ☺️ relaxed 😚 kissing_closed_eyes 😙 kissing_smiling_eyes ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:1:2","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"吐舌头表情 图标 代码 图标 代码 😋 yum 😛 stuck_out_tongue 😜 stuck_out_tongue_winking_eye 😝 stuck_out_tongue_closed_eyes 🤑 money_mouth_face ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:1:3","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"带手的表情 图标 代码 图标 代码 🤗 hugs 🤔 thinking ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:1:4","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"中性表情 图标 代码 图标 代码 🤐 zipper_mouth_face 😐 neutral_face 😑 expressionless 😶 no_mouth 😏 smirk 😒 unamused 🙄 roll_eyes 😬 grimacing 🤥 lying_face ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:1:5","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"困倦的表情 图标 代码 图标 代码 😌 relieved 😔 pensive 😪 sleepy 🤤 drooling_face 😴 sleeping ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:1:6","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"不适的表情 图标 代码 图标 代码 😷 mask 🤒 face_with_thermometer 🤕 face_with_head_bandage 🤢 nauseated_face 🤧 sneezing_face 😵 dizzy_face ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:1:7","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"戴帽子的表情 图标 代码 图标 代码 🤠 cowboy_hat_face ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:1:8","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"戴眼镜的表情 图标 代码 图标 代码 😎 sunglasses 🤓 nerd_face ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:1:9","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"担心的表情 图标 代码 图标 代码 😕 confused 😟 worried 🙁 slightly_frowning_face ☹ frowning_face 😮 open_mouth 😯 hushed 😲 astonished 😳 flushed 😦 frowning 😧 anguished 😨 fearful 😰 cold_sweat 😥 disappointed_relieved 😢 cry 😭 sob 😱 scream 😖 confounded 😣 persevere 😞 disappointed 😓 sweat 😩 weary 😫 tired_face ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:1:10","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"否定的表情 图标 代码 图标 代码 😤 triumph 😡 pout rage 😠 angry 😈 smiling_imp 👿 imp 💀 skull ☠️ skull_and_crossbones ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:1:11","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"特殊打扮的表情 图标 代码 图标 代码 💩 hankey poop shit 🤡 clown_face 👹 japanese_ogre 👺 japanese_goblin 👻 ghost 👽 alien 👾 space_invader 🤖 robot ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:1:12","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"猫脸表情 图标 代码 图标 代码 😺 smiley_cat 😸 smile_cat 😹 joy_cat 😻 heart_eyes_cat 😼 smirk_cat 😽 kissing_cat 🙀 scream_cat 😿 crying_cat_face 😾 pouting_cat ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:1:13","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"猴脸表情 图标 代码 图标 代码 🙈 see_no_evil 🙉 hear_no_evil 🙊 speak_no_evil ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:1:14","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"情感 图标 代码 图标 代码 💋 kiss 💌 love_letter 💘 cupid 💝 gift_heart 💖 sparkling_heart 💗 heartpulse 💓 heartbeat 💞 revolving_hearts 💕 two_hearts 💟 heart_decoration ❣️ heavy_heart_exclamation 💔 broken_heart ❤️ heart 💛 yellow_heart 💚 green_heart 💙 blue_heart 💜 purple_heart 🖤 black_heart 💯 100 💢 anger 💥 boom collision 💫 dizzy 💦 sweat_drops 💨 dash 🕳️ hole 💣 bomb 💬 speech_balloon 👁️‍🗨️ eye_speech_bubble 🗯️ right_anger_bubble 💭 thought_balloon 💤 zzz ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:1:15","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"人与身体 ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:2:0","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"张开手掌的手势 图标 代码 图标 代码 👋 wave 🤚 raised_back_of_hand 🖐️ raised_hand_with_fingers_splayed ✋ hand raised_hand 🖖 vulcan_salute ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:2:1","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"部分手指的手势 图标 代码 图标 代码 👌 ok_hand ✌️ v 🤞 crossed_fingers 🤘 metal 🤙 call_me_hand ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:2:2","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"一根手指的手势 图标 代码 图标 代码 👈 point_left 👉 point_right 👆 point_up_2 🖕 fu middle_finger 👇 point_down ☝️ point_up ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:2:3","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"握紧的手势 图标 代码 图标 代码 👍 +1 thumbsup 👎 -1 thumbsdown ✊ fist fist_raised 👊 facepunch fist_oncoming punch 🤛 fist_left 🤜 fist_right ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:2:4","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"两只手 图标 代码 图标 代码 👏 clap 🙌 raised_hands 👐 open_hands 🤝 handshake 🙏 pray ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:2:5","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"握住东西的手势 图标 代码 图标 代码 ✍️ writing_hand 💅 nail_care 🤳 selfie ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:2:6","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"身体部位 图标 代码 图标 代码 💪 muscle 👂 ear 👃 nose 👀 eyes 👁️ eye 👅 tongue 👄 lips ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:2:7","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"人 图标 代码 图标 代码 👶 baby 👦 boy 👧 girl :blonde_man: blonde_man person_with_blond_hair 👨 man 👩 woman 👱‍♀️ blonde_woman 👴 older_man 👵 older_woman ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:2:8","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"身体动作 图标 代码 图标 代码 🙍‍♀️ frowning_woman person_frowning 🙍‍♂️ frowning_man 🙎‍♀️ person_with_pouting_face pouting_woman 🙎‍♂️ pouting_man 🙅‍♀️ ng_woman no_good no_good_woman 🙅‍♂️ ng_man no_good_man 🙆‍♀️ ok_woman 🙆‍♂️ ok_man 💁‍♀️ information_desk_person sassy_woman tipping_hand_woman 💁‍♂️ sassy_man tipping_hand_man 🙋‍♀️ raising_hand raising_hand_woman 🙋‍♂️ raising_hand_man 🙇‍♂️ bow bowing_man 🙇‍♀️ bowing_woman 🤦‍♂️ man_facepalming 🤦‍♀️ woman_facepalming 🤷‍♂️ man_shrugging 🤷‍♀️ woman_shrugging ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:2:9","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"人物角色 图标 代码 图标 代码 👨‍⚕️ man_health_worker 👩‍⚕️ woman_health_worker 👨‍🎓 man_student 👩‍🎓 woman_student 👨‍🏫 man_teacher 👩‍🏫 woman_teacher 👨‍⚖️ man_judge 👩‍⚖️ woman_judge 👨‍🌾 man_farmer 👩‍🌾 woman_farmer 👨‍🍳 man_cook 👩‍🍳 woman_cook 👨‍🔧 man_mechanic 👩‍🔧 woman_mechanic 👨‍🏭 man_factory_worker 👩‍🏭 woman_factory_worker 👨‍💼 man_office_worker 👩‍💼 woman_office_worker 👨‍🔬 man_scientist 👩‍🔬 woman_scientist 👨‍💻 man_technologist 👩‍💻 woman_technologist 👨‍🎤 man_singer 👩‍🎤 woman_singer 👨‍🎨 man_artist 👩‍🎨 woman_artist 👨‍✈️ man_pilot 👩‍✈️ woman_pilot 👨‍🚀 man_astronaut 👩‍🚀 woman_astronaut 👨‍🚒 man_firefighter 👩‍🚒 woman_firefighter 👮‍♂️ cop policeman 👮‍♀️ policewoman 🕵 detective male_detective 🕵️‍♀️ female_detective 💂‍♂️ guardsman 💂‍♀️ guardswoman 👷‍♂️ construction_worker construction_worker_man 👷‍♀️ construction_worker_woman 🤴 prince 👸 princess 👳‍♂️ man_with_turban 👳‍♀️ woman_with_turban 👲 man_with_gua_pi_mao 🤵‍♂️ man_in_tuxedo 👰 bride_with_veil 🤰 pregnant_woman ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:2:10","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"幻想的人物 图标 代码 图标 代码 👼 angel 🎅 santa 🤶 mrs_claus ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:2:11","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"人物活动 图标 代码 图标 代码 💆‍♀️ massage massage_woman 💆‍♂️ massage_man 💇‍♀️ haircut haircut_woman 💇‍♂️ haircut_man 🚶‍♂️ walking walking_man 🚶‍♀️ walking_woman 🏃‍♂️ runner running running_man 🏃‍♀️ running_woman 💃 dancer 🕺 man_dancing 🕴️ business_suit_levitating 👯‍♀️ dancers dancing_women 👯‍♂️ dancing_men ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:2:12","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"体育 图标 代码 图标 代码 🤺 person_fencing 🏇 horse_racing ⛷️ skier 🏂 snowboarder 🏌️‍♂️ golfing_man 🏌️‍♀️ golfing_woman 🏄‍♂️ surfer surfing_man 🏄‍♀️ surfing_woman 🚣‍♂️ rowboat rowing_man 🚣‍♀️ rowing_woman 🏊‍♂️ swimmer swimming_man 🏊‍♀️ swimming_woman ⛹️‍♂️ basketball_man ⛹️‍♀️ basketball_woman 🏋️‍♂️ weight_lifting_man 🏋️‍♀️ weight_lifting_woman 🚴‍♂️ bicyclist biking_man 🚴‍♀️ biking_woman 🚵‍♂️ mountain_bicyclist mountain_biking_man 🚵‍♀️ mountain_biking_woman 🤸‍♂️ man_cartwheeling 🤸‍♀️ woman_cartwheeling 🤼‍♂️ men_wrestling 🤼‍♀️ women_wrestling 🤽‍♂️ man_playing_water_polo 🤽‍♀️ woman_playing_water_polo 🤾‍♂️ man_playing_handball 🤾‍♀️ woman_playing_handball 🤹‍♂️ man_juggling 🤹‍♀️ woman_juggling ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:2:13","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"休息 图标 代码 图标 代码 🛀 bath 🛌 sleeping_bed ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:2:14","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"家庭 图标 代码 图标 代码 👭 two_women_holding_hands 👫 couple 👬 two_men_holding_hands 👩‍❤️‍💋‍👨 couplekiss_man_woman 👨‍❤️‍💋‍👨 couplekiss_man_man 👩‍❤️‍💋‍👩 couplekiss_woman_woman 💑 couple_with_heart couple_with_heart_woman_man 👨‍❤️‍👨 couple_with_heart_man_man 👩‍❤️‍👩 couple_with_heart_woman_woman 👨‍👩‍👦 family family_man_woman_boy 👨‍👩‍👧 family_man_woman_girl 👨‍👩‍👧‍👦 family_man_woman_girl_boy 👨‍👩‍👦‍👦 family_man_woman_boy_boy 👨‍👩‍👧‍👧 family_man_woman_girl_girl 👨‍👨‍👦 family_man_man_boy 👨‍👨‍👧 family_man_man_girl 👨‍👨‍👧‍👦 family_man_man_girl_boy 👨‍👨‍👦‍👦 family_man_man_boy_boy 👨‍👨‍👧‍👧 family_man_man_girl_girl 👩‍👩‍👦 family_woman_woman_boy 👩‍👩‍👧 family_woman_woman_girl 👩‍👩‍👧‍👦 family_woman_woman_girl_boy 👩‍👩‍👦‍👦 family_woman_woman_boy_boy 👩‍👩‍👧‍👧 family_woman_woman_girl_girl 👨‍👦 family_man_boy 👨‍👦‍👦 family_man_boy_boy 👨‍👧 family_man_girl 👨‍👧‍👦 family_man_girl_boy 👨‍👧‍👧 family_man_girl_girl 👩‍👦 family_woman_boy 👩‍👦‍👦 family_woman_boy_boy 👩‍👧 family_woman_girl 👩‍👧‍👦 family_woman_girl_boy 👩‍👧‍👧 family_woman_girl_girl ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:2:15","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"人物符号 图标 代码 图标 代码 🗣 speaking_head 👤 bust_in_silhouette 👥 busts_in_silhouette 👣 footprints ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:2:16","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"动物与自然 ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:3:0","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"哺乳动物 图标 代码 图标 代码 🐵 monkey_face 🐒 monkey 🦍 gorilla 🐶 dog 🐕 dog2 🐩 poodle 🐺 wolf 🦊 fox_face 🐱 cat 🐈 cat2 🦁 lion 🐯 tiger 🐅 tiger2 🐆 leopard 🐴 horse 🐎 racehorse 🦄 unicorn 🦌 deer 🐮 cow 🐂 ox 🐃 water_buffalo 🐄 cow2 🐷 pig 🐖 pig2 🐗 boar 🐽 pig_nose 🐏 ram 🐑 sheep 🐐 goat 🐪 dromedary_camel 🐫 camel 🐘 elephant 🦏 rhinoceros 🐭 mouse 🐁 mouse2 🐀 rat 🐹 hamster 🐰 rabbit 🐇 rabbit2 🐿️ chipmunk 🦇 bat 🐻 bear 🐨 koala 🐼 panda_face 🐾 feet paw_prints ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:3:1","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"鸟类 图标 代码 图标 代码 🦃 turkey 🐔 chicken 🐓 rooster 🐣 hatching_chick 🐤 baby_chick 🐥 hatched_chick 🐦 bird 🐧 penguin 🕊 dove 🦅 eagle 🦆 duck 🦉 owl ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:3:2","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"两栖动物 icon code icon code 🐸 frog ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:3:3","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"爬虫类 图标 代码 图标 代码 🐊 crocodile 🐢 turtle 🦎 lizard 🐍 snake 🐲 dragon_face 🐉 dragon ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:3:4","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"海洋动物 图标 代码 图标 代码 🐳 whale 🐋 whale2 🐬 dolphin flipper 🐟 fish 🐠 tropical_fish 🐡 blowfish 🦈 shark 🐙 octopus 🐚 shell ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:3:5","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"虫类 图标 代码 图标 代码 🐌 snail 🦋 butterfly 🐛 bug 🐜 ant 🐝 bee honeybee 🪲 beetle 🕷️ spider 🕸️ spider_web 🦂 scorpion ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:3:6","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"花类植物 图标 代码 图标 代码 💐 bouquet 🌸 cherry_blossom 💮 white_flower 🏵️ rosette 🌹 rose 🥀 wilted_flower 🌺 hibiscus 🌻 sunflower 🌼 blossom 🌷 tulip ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:3:7","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"其它植物 图标 代码 图标 代码 🌱 seedling 🌲 evergreen_tree 🌳 deciduous_tree 🌴 palm_tree 🌵 cactus 🌾 ear_of_rice 🌿 herb ☘️ shamrock 🍀 four_leaf_clover 🍁 maple_leaf 🍂 fallen_leaf 🍃 leaves ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:3:8","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"食物与饮料 ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:4:0","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"水果 图标 代码 图标 代码 🍇 grapes 🍈 melon 🍉 watermelon 🍊 mandarin orange tangerine 🍋 lemon 🍌 banana 🍍 pineapple 🍎 apple 🍏 green_apple 🍐 pear 🍑 peach 🍒 cherries 🍓 strawberry 🥝 kiwi_fruit 🍅 tomato ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:4:1","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"蔬菜 图标 代码 图标 代码 🥑 avocado 🍆 eggplant 🥔 potato 🥕 carrot 🌽 corn 🌶️ hot_pepper 🥒 cucumber 🍄 mushroom 🥜 peanuts 🌰 chestnut ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:4:2","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"快餐 图标 代码 图标 代码 🍞 bread 🥐 croissant 🥖 baguette_bread 🥞 pancakes 🧀 cheese 🍖 meat_on_bone 🍗 poultry_leg 🥓 bacon 🍔 hamburger 🍟 fries 🍕 pizza 🌭 hotdog 🌮 taco 🌯 burrito 🥙 stuffed_flatbread 🥚 egg 🍳 fried_egg 🥘 shallow_pan_of_food 🍲 stew 🥗 green_salad 🍿 popcorn ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:4:3","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"亚洲食物 图标 代码 图标 代码 🍱 bento 🍘 rice_cracker 🍙 rice_ball 🍚 rice 🍛 curry 🍜 ramen 🍝 spaghetti 🍠 sweet_potato 🍢 oden 🍣 sushi 🍤 fried_shrimp 🍥 fish_cake 🍡 dango ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:4:4","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"海鲜 图标 代码 图标 代码 🦀 crab 🦐 shrimp 🦑 squid ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:4:5","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"甜点 图标 代码 图标 代码 🍦 icecream 🍧 shaved_ice 🍨 ice_cream 🍩 doughnut 🍪 cookie 🎂 birthday 🍰 cake 🍫 chocolate_bar 🍬 candy 🍭 lollipop 🍮 custard 🍯 honey_pot ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:4:6","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"饮料 图标 代码 图标 代码 🍼 baby_bottle 🥛 milk_glass ☕ coffee 🍵 tea 🍶 sake 🍾 champagne 🍷 wine_glass 🍸 cocktail 🍹 tropical_drink 🍺 beer 🍻 beers 🥂 clinking_glasses 🥃 tumbler_glass ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:4:7","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"餐具 图标 代码 图标 代码 🍽️ plate_with_cutlery 🍴 fork_and_knife 🥄 spoon 🔪 hocho knife 🏺 amphora ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:4:8","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"旅游与地理 ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:5:0","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"地图 图标 代码 图标 代码 🌍 earth_africa 🌎 earth_americas 🌏 earth_asia 🌐 globe_with_meridians 🗺️ world_map 🗾 japan ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:5:1","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"地理现象 图标 代码 图标 代码 🏔 mountain_snow ⛰️ mountain 🌋 volcano 🗻 mount_fuji 🏕️ camping ⛱ beach_umbrella 🏜️ desert 🏝️ desert_island 🏞️ national_park ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:5:2","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"建筑物 图标 代码 图标 代码 🏟️ stadium 🏛️ classical_building 🏗️ building_construction 🏘 houses 🏚 derelict_house 🏠 house 🏡 house_with_garden 🏢 office 🏣 post_office 🏤 european_post_office 🏥 hospital 🏦 bank 🏨 hotel 🏩 love_hotel 🏪 convenience_store 🏫 school 🏬 department_store 🏭 factory 🏯 japanese_castle 🏰 european_castle 💒 wedding 🗼 tokyo_tower 🗽 statue_of_liberty ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:5:3","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"宗教建筑 图标 代码 图标 代码 ⛪ church 🕌 mosque 🕍 synagogue ⛩️ shinto_shrine 🕋 kaaba ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:5:4","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"其它地点 图标 代码 图标 代码 ⛲ fountain ⛺ tent 🌁 foggy 🌃 night_with_stars 🏙️ cityscape 🌄 sunrise_over_mountains 🌅 sunrise 🌆 city_sunset 🌇 city_sunrise 🌉 bridge_at_night ♨️ hotsprings 🎠 carousel_horse 🎡 ferris_wheel 🎢 roller_coaster 💈 barber 🎪 circus_tent ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:5:5","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"陆路运输 图标 代码 图标 代码 🚂 steam_locomotive 🚃 railway_car 🚄 bullettrain_side 🚅 bullettrain_front 🚆 train2 🚇 metro 🚈 light_rail 🚉 station 🚊 tram 🚝 monorail 🚞 mountain_railway 🚋 train 🚌 bus 🚍 oncoming_bus 🚎 trolleybus 🚐 minibus 🚑 ambulance 🚒 fire_engine 🚓 police_car 🚔 oncoming_police_car 🚕 taxi 🚖 oncoming_taxi 🚗 car red_car 🚘 oncoming_automobile 🚙 blue_car 🚚 truck 🚛 articulated_lorry 🚜 tractor 🏎️ racing_car 🏍 motorcycle 🛵 motor_scooter 🚲 bike 🛴 kick_scooter 🚏 busstop 🛣️ motorway 🛤️ railway_track 🛢️ oil_drum ⛽ fuelpump 🚨 rotating_light 🚥 traffic_light 🚦 vertical_traffic_light 🛑 stop_sign 🚧 construction ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:5:6","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"水路运输 图标 代码 图标 代码 ⚓ anchor ⛵ boat sailboat 🛶 canoe 🚤 speedboat 🛳️ passenger_ship ⛴️ ferry 🛥️ motor_boat 🚢 ship ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:5:7","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"空中运输 图标 代码 图标 代码 ✈️ airplane 🛩️ small_airplane 🛫 flight_departure 🛬 flight_arrival 💺 seat 🚁 helicopter 🚟 suspension_railway 🚠 mountain_cableway 🚡 aerial_tramway 🛰️ artificial_satellite 🚀 rocket ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:5:8","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"旅馆 icon code icon code 🛎️ bellhop_bell ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:5:9","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"时间 图标 代码 图标 代码 ⌛ hourglass ⏳ hourglass_flowing_sand ⌚ watch ⏰ alarm_clock ⏱️ stopwatch ⏲️ timer_clock 🕰️ mantelpiece_clock 🕛 clock12 🕧 clock1230 🕐 clock1 🕜 clock130 🕑 clock2 🕝 clock230 🕒 clock3 🕞 clock330 🕓 clock4 🕟 clock430 🕔 clock5 🕠 clock530 🕕 clock6 🕡 clock630 🕖 clock7 🕢 clock730 🕗 clock8 🕣 clock830 🕘 clock9 🕤 clock930 🕙 clock10 🕥 clock1030 🕚 clock11 🕦 clock1130 ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:5:10","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"天空与天气 图标 代码 图标 代码 🌑 new_moon 🌒 waxing_crescent_moon 🌓 first_quarter_moon 🌔 moon waxing_gibbous_moon 🌕 full_moon 🌖 waning_gibbous_moon 🌗 last_quarter_moon 🌘 waning_crescent_moon 🌙 crescent_moon 🌚 new_moon_with_face 🌛 first_quarter_moon_with_face 🌜 last_quarter_moon_with_face 🌡️ thermometer ☀️ sunny 🌝 full_moon_with_face 🌞 sun_with_face ⭐ star 🌟 star2 🌠 stars 🌌 milky_way ☁️ cloud ⛅ partly_sunny ⛈ cloud_with_lightning_and_rain 🌤 sun_behind_small_cloud 🌥 sun_behind_large_cloud 🌦 sun_behind_rain_cloud 🌧 cloud_with_rain 🌨 cloud_with_snow 🌩 cloud_with_lightning 🌪️ tornado 🌫️ fog 🌬 wind_face 🌀 cyclone 🌈 rainbow 🌂 closed_umbrella ☂️ open_umbrella ☂️ umbrella ⛱️ parasol_on_ground ⚡ zap ❄️ snowflake ☃️ snowman_with_snow ☃️ snowman ☄️ comet 🔥 fire 💧 droplet 🌊 ocean ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:5:11","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"活动 ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:6:0","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"事件 图标 代码 图标 代码 🎃 jack_o_lantern 🎄 christmas_tree 🎆 fireworks 🎇 sparkler ✨ sparkles 🎈 balloon 🎉 tada 🎊 confetti_ball 🎋 tanabata_tree 🎍 bamboo 🎎 dolls 🎏 flags 🎐 wind_chime 🎑 rice_scene 🎀 ribbon 🎁 gift 🎗️ reminder_ribbon 🎟 tickets 🎫 ticket ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:6:1","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"奖杯与奖牌 图标 代码 图标 代码 🎖️ medal_military 🏆 trophy 🏅 medal_sports 🥇 1st_place_medal 🥈 2nd_place_medal 🥉 3rd_place_medal ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:6:2","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"体育运动 图标 代码 图标 代码 ⚽ soccer ⚾ baseball 🏀 basketball 🏐 volleyball 🏈 football 🏉 rugby_football 🎾 tennis 🎳 bowling 🦗 cricket 🏑 field_hockey 🏒 ice_hockey 🏓 ping_pong 🏸 badminton 🥊 boxing_glove 🥋 martial_arts_uniform 🥅 goal_net ⛳ golf ⛸️ ice_skate 🎣 fishing_pole_and_fish 🎽 running_shirt_with_sash 🎿 ski ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:6:3","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"游戏 图标 代码 图标 代码 🎯 dart 🎱 8ball 🔮 crystal_ball 🎮 video_game 🕹️ joystick 🎰 slot_machine 🎲 game_die ♠️ spades ♥️ hearts ♦️ diamonds ♣️ clubs 🃏 black_joker 🀄 mahjong 🎴 flower_playing_cards ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:6:4","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"艺术与工艺 图标 代码 图标 代码 🎭 performing_arts 🖼 framed_picture 🎨 art ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:6:5","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"物品 ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:7:0","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"服装 图标 代码 图标 代码 👓 eyeglasses 🕶️ dark_sunglasses 👔 necktie 👕 shirt tshirt 👖 jeans 👗 dress 👘 kimono 👙 bikini 👚 womans_clothes 👛 purse 👜 handbag 👝 pouch 🛍️ shopping 🎒 school_satchel 👞 mans_shoe shoe 👟 athletic_shoe 👠 high_heel 👡 sandal 👢 boot 👑 crown 👒 womans_hat 🎩 tophat 🎓 mortar_board ⛑️ rescue_worker_helmet 📿 prayer_beads 💄 lipstick 💍 ring 💎 gem ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:7:1","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"声音 图标 代码 图标 代码 🔇 mute 🔈 speaker 🔉 sound 🔊 loud_sound 📢 loudspeaker 📣 mega 📯 postal_horn 🔔 bell 🔕 no_bell ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:7:2","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"音乐 图标 代码 图标 代码 🎼 musical_score 🎵 musical_note 🎶 notes 🎙️ studio_microphone 🎚️ level_slider 🎛️ control_knobs 🎤 microphone 🎧 headphones 📻 radio ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:7:3","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"乐器 图标 代码 图标 代码 🎷 saxophone 🎸 guitar 🎹 musical_keyboard 🎺 trumpet 🎻 violin 🥁 drum ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:7:4","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"电话 图标 代码 图标 代码 📱 iphone 📲 calling ☎️ phone telephone 📞 telephone_receiver 📟 pager 📠 fax ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:7:5","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"电脑 图标 代码 图标 代码 🔋 battery 🔌 electric_plug 💻 computer 🖥️ desktop_computer 🖨️ printer ⌨️ keyboard 🖱 computer_mouse 🖲️ trackball 💽 minidisc 💾 floppy_disk 💿 cd 📀 dvd ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:7:6","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"灯光与影像 图标 代码 图标 代码 🎥 movie_camera 🎞️ film_strip 📽️ film_projector 🎬 clapper 📺 tv 📷 camera 📸 camera_flash 📹 video_camera 📼 vhs 🔍 mag 🔎 mag_right 🕯️ candle 💡 bulb 🔦 flashlight 🏮 izakaya_lantern lantern ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:7:7","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"书与纸张 图标 代码 图标 代码 📔 notebook_with_decorative_cover 📕 closed_book 📖 book open_book 📗 green_book 📘 blue_book 📙 orange_book 📚 books 📓 notebook 📒 ledger 📃 page_with_curl 📜 scroll 📄 page_facing_up 📰 newspaper 🗞️ newspaper_roll 📑 bookmark_tabs 🔖 bookmark 🏷️ label ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:7:8","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"钱 图标 代码 图标 代码 💰 moneybag 💴 yen 💵 dollar 💶 euro 💷 pound 💸 money_with_wings 💳 credit_card 💹 chart ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:7:9","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"邮件 图标 代码 图标 代码 ✉️ email envelope 📧 📧 📨 incoming_envelope 📩 envelope_with_arrow 📤 outbox_tray 📥 inbox_tray 📦 package 📫 mailbox 📪 mailbox_closed 📬 mailbox_with_mail 📭 mailbox_with_no_mail 📮 postbox 🗳 ballot_box ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:7:10","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"书写 图标 代码 图标 代码 ✏️ pencil2 ✒️ black_nib 🖋 fountain_pen 🖊 pen 🖌 paintbrush 🖍 crayon 📝 memo pencil ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:7:11","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"办公 图标 代码 图标 代码 💼 briefcase 📁 file_folder 📂 open_file_folder 🗂️ card_index_dividers 📅 date 📆 calendar 🗒 spiral_notepad 🗓 spiral_calendar 📇 card_index 📈 chart_with_upwards_trend 📉 chart_with_downwards_trend 📊 bar_chart 📋 clipboard 📌 pushpin 📍 round_pushpin 📎 paperclip 🖇 paperclips 📏 straight_ruler 📐 triangular_ruler ✂️ scissors 🗃️ card_file_box 🗄️ file_cabinet 🗑️ wastebasket ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:7:12","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"锁 图标 代码 图标 代码 🔒 lock 🔓 unlock 🔏 lock_with_ink_pen 🔐 closed_lock_with_key 🔑 key 🗝️ old_key ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:7:13","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"工具 图标 代码 图标 代码 🔨 hammer ⛏️ pick ⚒️ hammer_and_pick 🛠️ hammer_and_wrench 🗡 dagger ⚔️ crossed_swords 🔫 gun 🏹 bow_and_arrow 🛡️ shield 🔧 wrench 🔩 nut_and_bolt ⚙️ gear 🗜 clamp ⚖ balance_scale 🔗 link ⛓️ chains ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:7:14","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"科学 图标 代码 图标 代码 ⚗️ alembic 🔬 microscope 🔭 telescope 🛰️ satellite ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:7:15","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"医疗 图标 代码 图标 代码 💉 syringe 💊 pill ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:7:16","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"生活用品 图标 代码 图标 代码 🚪 door 🛏️ bed 🛋️ couch_and_lamp 🚽 toilet 🚿 shower 🛁 bathtub 🛒 shopping_cart ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:7:17","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"其它物品 图标 代码 图标 代码 🚬 smoking ⚰️ coffin ⚱️ funeral_urn 🗿 moyai ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:7:18","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"符号 ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:8:0","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"交通标识 图标 代码 图标 代码 🏧 atm 🚮 put_litter_in_its_place 🚰 potable_water ♿ wheelchair 🚹 mens 🚺 womens 🚻 restroom 🚼 baby_symbol 🚾 wc 🛂 passport_control 🛃 customs 🛄 baggage_claim 🛅 left_luggage ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:8:1","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"警告 图标 代码 图标 代码 ⚠️ warning 🚸 children_crossing ⛔ no_entry 🚫 no_entry_sign 🚳 no_bicycles 🚭 no_smoking 🚯 do_not_litter 🚱 🚱 🚷 no_pedestrians 📵 no_mobile_phones 🔞 underage ☢ radioactive ☣ biohazard ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:8:2","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"箭头 图标 代码 图标 代码 ⬆️ arrow_up ↗️ arrow_upper_right ➡️ arrow_right ↘️ arrow_lower_right ⬇️ arrow_down ↙️ arrow_lower_left ⬅️ arrow_left ↖️ arrow_upper_left ↕️ arrow_up_down ↔️ left_right_arrow ↩️ leftwards_arrow_with_hook ↪️ arrow_right_hook ⤴️ arrow_heading_up ⤵️ arrow_heading_down 🔃 arrows_clockwise 🔄 arrows_counterclockwise 🔙 back 🔚 end 🔛 on 🔜 soon 🔝 top ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:8:3","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"宗教 图标 代码 图标 代码 🛐 place_of_worship ⚛️ atom_symbol 🕉 om ✡️ star_of_david ☸️ wheel_of_dharma ☯️ yin_yang ✝️ latin_cross ☦️ orthodox_cross ☪️ star_and_crescent ☮️ peace_symbol 🕎 menorah 🔯 six_pointed_star ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:8:4","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"生肖 图标 代码 图标 代码 ♈ aries ♉ taurus ♊ gemini ♋ cancer ♌ leo ♍ virgo ♎ libra ♏ scorpius ♐ sagittarius ♑ capricorn ♒ aquarius ♓ pisces ⛎ ophiuchus ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:8:5","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"影像符号 图标 代码 图标 代码 🔀 twisted_rightwards_arrows 🔁 repeat 🔂 repeat_one ▶️ arrow_forward ⏩ fast_forward ⏭ next_track_button ⏯ play_or_pause_button ◀️ arrow_backward ⏪ rewind ⏮️ previous_track_button 🔼 arrow_up_small ⏫ arrow_double_up 🔽 arrow_down_small ⏬ arrow_double_down ⏸ pause_button ⏹ stop_button ⏺ record_button 🎦 cinema 🔅 low_brightness 🔆 high_brightness 📶 signal_strength 📳 vibration_mode 📴 mobile_phone_off ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:8:6","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"数学 图标 代码 图标 代码 ✖️ heavy_multiplication_x ➕ heavy_plus_sign ➖ heavy_minus_sign ➗ heavy_division_sign ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:8:7","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"标点符号 图标 代码 图标 代码 ‼️ bangbang ⁉️ interrobang ❓ question ❔ grey_question ❕ grey_exclamation ❗ exclamation heavy_exclamation_mark 〰️ wavy_dash ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:8:8","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"货币 图标 代码 图标 代码 💱 currency_exchange 💲 heavy_dollar_sign ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:8:9","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"按键符号 图标 代码 图标 代码 #️⃣ hash *️⃣ asterisk 0️⃣ zero 1️⃣ one 2️⃣ two 3️⃣ three 4️⃣ four 5️⃣ five 6️⃣ six 7️⃣ seven 8️⃣ eight 9️⃣ nine 🔟 keycap_ten ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:8:10","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"字母符号 图标 代码 图标 代码 🔠 capital_abcd 🔡 abcd 🔢 1234 🔣 symbols 🔤 abc 🅰️ a 🆎 ab 🅱️ b 🆑 cl 🆒 cool 🆓 free ℹ️ information_source 🆔 id ⓜ️ m 🆕 new 🆖 ng 🅾️ o2 🆗 ok 🅿️ parking 🆘 sos 🆙 up 🆚 vs 🈁 koko 🈂️ sa 🈷️ u6708 🈶 u6709 🈯 u6307 🉐 ideograph_advantage 🈹 u5272 🈚 u7121 🈲 u7981 🉑 accept 🈸 u7533 🈴 u5408 🈳 u7a7a ㊗️ congratulations ㊙️ secret 🈺 u55b6 🈵 u6e80 ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:8:11","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"几何符号 图标 代码 图标 代码 🔴 red_circle 🔵 large_blue_circle ⚫ black_circle ⚪ white_circle ⬛ black_large_square ⬜ white_large_square ◼️ black_medium_square ◻️ white_medium_square ◾ black_medium_small_square ◽ white_medium_small_square ▪️ black_small_square ▫️ white_small_square 🔶 large_orange_diamond 🔷 large_blue_diamond 🔸 small_orange_diamond 🔹 small_blue_diamond 🔺 small_red_triangle 🔻 small_red_triangle_down 💠 diamond_shape_with_a_dot_inside 🔘 radio_button 🔳 white_square_button 🔲 black_square_button ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:8:12","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"其它符合 图标 代码 图标 代码 ♻️ recycle ⚜️ fleur_de_lis 🔱 trident 📛 name_badge 🔰 beginner ⭕ o ✅ white_check_mark ☑️ ballot_box_with_check ✔️ heavy_check_mark ❌ x ❎ negative_squared_cross_mark ➰ curly_loop ➿ loop 〽️ part_alternation_mark ✳️ eight_spoked_asterisk ✴️ eight_pointed_black_star ❇️ sparkle ©️ copyright ®️ registered ™️ tm ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:8:13","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"旗帜 ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:9:0","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"常用旗帜 图标 代码 图标 代码 🏁 checkered_flag 🚩 triangular_flag_on_post 🎌 crossed_flags 🏴 black_flag 🏳 white_flag 🏳️‍🌈 rainbow_flag ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:9:1","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["hugo"],"content":"国家和地区旗帜 图标 代码 图标 代码 🇦🇩 andorra 🇦🇪 united_arab_emirates 🇦🇫 afghanistan 🇦🇬 antigua_barbuda 🇦🇮 anguilla 🇦🇱 albania 🇦🇲 armenia 🇦🇴 angola 🇦🇶 antarctica 🇦🇷 argentina 🇦🇸 american_samoa 🇦🇹 austria 🇦🇺 australia 🇦🇼 aruba 🇦🇽 aland_islands 🇦🇿 azerbaijan 🇧🇦 bosnia_herzegovina 🇧🇧 barbados 🇧🇩 bangladesh 🇧🇪 belgium 🇧🇫 burkina_faso 🇧🇬 bulgaria 🇧🇭 bahrain 🇧🇮 burundi 🇧🇯 benin 🇧🇱 st_barthelemy 🇧🇲 bermuda 🇧🇳 brunei 🇧🇴 bolivia 🇧🇶 caribbean_netherlands 🇧🇷 brazil 🇧🇸 bahamas 🇧🇹 bhutan 🇧🇼 botswana 🇧🇾 belarus 🇧🇿 belize 🇨🇦 canada 🇨🇨 cocos_islands 🇨🇩 congo_kinshasa 🇨🇫 central_african_republic 🇨🇬 congo_brazzaville 🇨🇭 switzerland 🇨🇮 cote_divoire 🇨🇰 cook_islands 🇨🇱 chile 🇨🇲 cameroon 🇨🇳 cn 🇨🇴 colombia 🇨🇷 costa_rica 🇨🇺 cuba 🇨🇻 cape_verde 🇨🇼 curacao 🇨🇽 christmas_island 🇨🇾 cyprus 🇨🇿 czech_republic 🇩🇪 de 🇩🇯 djibouti 🇩🇰 denmark 🇩🇲 dominica 🇩🇴 dominican_republic 🇩🇿 algeria 🇪🇨 ecuador 🇪🇪 estonia 🇪🇬 egypt 🇪🇭 western_sahara 🇪🇷 eritrea 🇪🇸 es 🇪🇹 ethiopia 🇪🇺 eu european_union 🇫🇮 finland 🇫🇯 fiji 🇫🇰 falkland_islands 🇫🇲 micronesia 🇫🇴 faroe_islands 🇫🇷 fr 🇬🇦 gabon 🇬🇧 gb uk 🇬🇩 grenada 🇬🇪 georgia 🇬🇫 french_guiana 🇬🇬 guernsey 🇬🇭 ghana 🇬🇮 gibraltar 🇬🇱 greenland 🇬🇲 gambia 🇬🇳 guinea 🇬🇵 guadeloupe 🇬🇶 equatorial_guinea 🇬🇷 greece 🇬🇸 south_georgia_south_sandwich_islands 🇬🇹 guatemala 🇬🇺 guam 🇬🇼 guinea_bissau 🇬🇾 guyana 🇭🇰 hong_kong 🇭🇳 honduras 🇭🇷 croatia 🇭🇹 haiti 🇭🇺 hungary 🇮🇨 canary_islands 🇮🇩 indonesia 🇮🇪 ireland 🇮🇱 israel 🇮🇲 isle_of_man 🇮🇳 india 🇮🇴 british_indian_ocean_territory 🇮🇶 iraq 🇮🇷 iran 🇮🇸 iceland 🇮🇹 it 🇯🇪 jersey 🇯🇲 jamaica 🇯🇴 jordan 🇯🇵 jp 🇰🇪 kenya 🇰🇬 kyrgyzstan 🇰🇭 cambodia 🇰🇮 kiribati 🇰🇲 comoros 🇰🇳 st_kitts_nevis 🇰🇵 north_korea 🇰🇷 kr 🇰🇼 kuwait 🇰🇾 cayman_islands 🇰🇿 kazakhstan 🇱🇦 laos 🇱🇧 lebanon 🇱🇨 st_lucia 🇱🇮 liechtenstein 🇱🇰 sri_lanka 🇱🇷 liberia 🇱🇸 lesotho 🇱🇹 lithuania 🇱🇺 luxembourg 🇱🇻 latvia 🇱🇾 libya 🇲🇦 morocco 🇲🇨 monaco 🇲🇩 moldova 🇲🇪 montenegro 🇲🇬 madagascar 🇲🇭 marshall_islands 🇲🇰 macedonia 🇲🇱 mali 🇲🇲 myanmar 🇲🇳 mongolia 🇲🇴 macau 🇲🇵 northern_mariana_islands 🇲🇶 martinique 🇲🇷 mauritania 🇲🇸 montserrat 🇲🇹 malta 🇲🇺 mauritius 🇲🇻 maldives 🇲🇼 malawi 🇲🇽 mexico 🇲🇾 malaysia 🇲🇿 mozambique 🇳🇦 namibia 🇳🇨 new_caledonia 🇳🇪 niger 🇳🇫 norfolk_island 🇳🇬 nigeria 🇳🇮 nicaragua 🇳🇱 netherlands 🇳🇴 norway 🇳🇵 nepal 🇳🇷 nauru 🇳🇺 niue 🇳🇿 new_zealand 🇴🇲 oman 🇵🇦 panama 🇵🇪 peru 🇵🇫 french_polynesia 🇵🇬 papua_new_guinea 🇵🇭 philippines 🇵🇰 pakistan 🇵🇱 poland 🇵🇲 st_pierre_miquelon 🇵🇳 pitcairn_islands 🇵🇷 puerto_rico 🇵🇸 palestinian_territories 🇵🇹 portugal 🇵🇼 palau 🇵🇾 paraguay 🇶🇦 qatar 🇷🇪 reunion 🇷🇴 romania 🇷🇸 serbia 🇷🇺 ru 🇷🇼 rwanda 🇸🇦 saudi_arabia 🇸🇧 solomon_islands 🇸🇨 seychelles 🇸🇩 sudan 🇸🇪 sweden 🇸🇬 singapore 🇸🇭 st_helena 🇸🇮 slovenia 🇸🇰 slovakia 🇸🇱 sierra_leone 🇸🇲 san_marino 🇸🇳 senegal 🇸🇴 somalia 🇸🇷 suriname 🇸🇸 south_sudan 🇸🇹 sao_tome_principe 🇸🇻 el_salvador 🇸🇽 sint_maarten 🇸🇾 syria 🇸🇿 swaziland 🇹🇨 turks_caicos_islands 🇹🇩 chad 🇹🇫 french_southern_territories 🇹🇬 togo 🇹🇭 thailand 🇹🇯 tajikistan 🇹🇰 tokelau 🇹🇱 timor_leste 🇹🇲 turkmenistan 🇹🇳 tunisia 🇹🇴 tonga 🇹🇷 tr 🇹🇹 trinidad_tobago 🇹🇻 tuvalu 🇹🇼 taiwan 🇹🇿 tanzania 🇺🇦 ukraine 🇺🇬 uganda 🇺🇸 us 🇺🇾 uruguay 🇺🇿 uzbekistan 🇻🇦 vatican_city 🇻🇨 st_vincent_grenadines 🇻🇪 venezuela 🇻🇬 british_virgin_islands 🇻🇮 us_virgin_islands 🇻🇳 vietnam 🇻🇺 vanuatu 🇼🇫 wallis_futuna 🇼🇸 samoa 🇽🇰 kosovo 🇾🇪 yemen 🇾🇹 mayotte 🇿🇦 south_africa 🇿🇲 zambia 🇿🇼 zimbabwe ","date":"2019-10-01 17:55:28","objectID":"/theme-emoji-support/:9:2","tags":["hugo"],"title":"主题文档 - Emoji 支持","uri":"/theme-emoji-support/"},{"categories":["shader"],"content":" Gamma校正: 所谓Gamma校正就是对颜色进行指数运算。对图像进行Gamma校正（gamma = 1/2.2 = 0.4545454…）是为了在存储空间有限的情况下，提高符合人眼特性的可辨识精度。由于硬盘存储的图像是经过Gamma校正的，因此显示器显示图片时，需要做一次逆Gamma校正（gamma = 2.2）——也就是说，所有显示器都期待软件输出的图片是经过Gamma校正的。至于为什么这个值是2.2，由于历史惯用，Gamma值=2.2已成为业界标准。 ","date":"2022-03-09 10:44:08","objectID":"/gamma%E5%92%8Clinear%E5%8F%8Asrgb%E8%AF%B4%E6%98%8E/:0:0","tags":["shader"],"title":"Gamma和Linear及sRGB说明","uri":"/gamma%E5%92%8Clinear%E5%8F%8Asrgb%E8%AF%B4%E6%98%8E/"},{"categories":["shader"],"content":"unity中测试结果： Gamma space，开不开sRGB都没有影响 Linear space，gamma texture 勾选sRGB Linear space，linear texture 不勾sRGB （这个是没有测试的，推断的） ","date":"2022-03-09 10:44:08","objectID":"/gamma%E5%92%8Clinear%E5%8F%8Asrgb%E8%AF%B4%E6%98%8E/:0:1","tags":["shader"],"title":"Gamma和Linear及sRGB说明","uri":"/gamma%E5%92%8Clinear%E5%8F%8Asrgb%E8%AF%B4%E6%98%8E/"},{"categories":["shader"],"content":"unity中测试过程： 外部导入一张gamma texture贴图： ps导出的gamma空间的图片 外部导入一张linear texture贴图： ps导出的linear空间的图片 unity 使用 Gamma Space 勾不勾sRGB都没有影响 unity 使用 Linear Space 使用 gamma texture 勾选sRGB 在Linear Space下，如果勾了sRGB 之后，Unity是做了Remove Gamma Correction 使用 gamma texture 不勾选sRGB 使用 linear texture 勾选sRGB 这个是错误的，不能勾选sRGB,这个效果和ps中显示是一样的 使用 linear texture 不勾选sRGB 对于测试纹理勾选sRGB后再内存中的格式是RGB8_sRGB,对于这种_SRGB后缀的格式，GPU在进行纹理采样的时候，会自动将其移除GamaCorrection，即将数值做2.2次幂操作，但是不会对原始数据做修改。在Gamma空间中，不论勾选还是不勾选sRGB，格式都是RGB8_UNORM。 注意 public Color GetPixel(int x, int y 方法获取纹理中间的颜色时，linear space下，不管勾不勾sRGB都是返回固定值，中间的红色位置始终返回0.996，没有定论 ","date":"2022-03-09 10:44:08","objectID":"/gamma%E5%92%8Clinear%E5%8F%8Asrgb%E8%AF%B4%E6%98%8E/:0:2","tags":["shader"],"title":"Gamma和Linear及sRGB说明","uri":"/gamma%E5%92%8Clinear%E5%8F%8Asrgb%E8%AF%B4%E6%98%8E/"},{"categories":["shader"],"content":"Gamma工作流说明： gamma texture 在存储时 预先做gamma校正（0.454）,然后储存到文件（这时候纹理是被整体提亮的），文件加载读取后直接输出到屏幕时，显示器内置自动做逆gamma校正（2.2），所以看到是正常的图片。 unity中gamma空间也是这样工作的，这时sRGB没有任何作用，如果做pbr等光照计算，需要在计算前进行逆gamma校正（2.2）回归到线性空间，然后进行光照计算，计算后的颜色需要做gamma校正（0.454）（从线性空间返回到gamma空间），输出后的颜色从显示器显示（内置逆gamma校正（2.2）） ，看到正常图片。参与光照计算的光滑度/金属度贴图，这类存储数值信息的贴图，是线性贴图，在渲染时，它不提供色彩信息给显示器，而是提供光滑度/金属度这样的数据用以光照计算，因此0.5就是0.5，不需要sRGB解码 参考： https://segmentfault.com/a/1190000040181885 https://blog.51cto.com/u_15054050/4550752 https://ciel1012.github.io/2019/06/12/ColorSpace/ https://answer.uwa4d.com/question/5f8129c29424416784ef25a1 ","date":"2022-03-09 10:44:08","objectID":"/gamma%E5%92%8Clinear%E5%8F%8Asrgb%E8%AF%B4%E6%98%8E/:0:3","tags":["shader"],"title":"Gamma和Linear及sRGB说明","uri":"/gamma%E5%92%8Clinear%E5%8F%8Asrgb%E8%AF%B4%E6%98%8E/"},{"categories":["Unity"],"content":"UIParticle使用教程 Unity中 UGUI 使用 Particle System每次需要设置rendererorder和layer等信息来控制排序，非常繁琐，这里使用ParticleEffectForUGUI插件来解决该问题。 ParticleEffectForUGUI ","date":"2022-02-17 15:49:27","objectID":"/particleeffectforugui%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:0:0","tags":["Unity","UGUI"],"title":"ParticleEffectForUGUI使用教程","uri":"/particleeffectforugui%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["Unity"],"content":"使用 设置Game窗口的分辨率 1920*1080 将带Particle System组件的物体放到UGUI根节点里面 将带Particle System组件的物体添加 UIParticle 组件,该组件会自动添加到子节点的所有带Particle System组件的物体上 Scale:调整该Particle System的缩放,不影响子物体 Animatable Properties:如果使用Animation或者其他动画更新（Update）材质球上的属性，则勾选上对应的Shader属性即可 删除则需要每个物体去删除 UIParticle 组件 ","date":"2022-02-17 15:49:27","objectID":"/particleeffectforugui%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:1:0","tags":["Unity","UGUI"],"title":"ParticleEffectForUGUI使用教程","uri":"/particleeffectforugui%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["Unity"],"content":"说明 每个带Particle System组件的物体都要增加 UIParticle 组件 （可以挂到prefab根节点物体上，可以是空物体） ParticleEffectForUGUI会自动合批处理，不被打算的情况下 ParticleEffectForUGUI插件支持 Mask Rect Mask2D等遮罩，需要在使用的Shader上添加模板测试(Stencil)和ClipRect代码进行支持 ","date":"2022-02-17 15:49:27","objectID":"/particleeffectforugui%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:0","tags":["Unity","UGUI"],"title":"ParticleEffectForUGUI使用教程","uri":"/particleeffectforugui%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["Unity"],"content":" lua中os.clock(): 解释：返回一个程序使用CPU时间的一个近似值。 引用：https://www.jianshu.com/p/46e0d70746cc ","date":"2022-02-17 15:37:27","objectID":"/xlua%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:0:0","tags":["Unity","lua"],"title":"Xlua性能测试","uri":"/xlua%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["Unity"],"content":"xlua 常用说明 详细说明：https://github.com/Tencent/xLua/blob/master/Assets/XLua/Doc/configure.md XLua.LuaCallCSharp 一个C#类型加了这个配置，xLua会生成这个类型的适配代码（包括构造该类型实例，访问其成员属性、方法，静态属性、方法），否则将会尝试用性能较低的反射方式来访问。 一个类型的扩展方法（Extension Methods）加了这配置，也会生成适配代码并追加到被扩展类型的成员方法上。 xLua只会生成加了该配置的类型，不会自动生成其父类的适配代码，当访问子类对象的父类方法，如果该父类加了LuaCallCSharp配置，则执行父类的适配代码，否则会尝试用反射来访问。 反射访问除了性能不佳之外，在il2cpp下还有可能因为代码剪裁而导致无法访问，后者可以通过下面介绍的ReflectionUse标签来避免。 XLua.CSharpCallLua 如果希望把一个lua函数适配到一个C# delegate（一类是C#侧各种回调：UI事件，delegate参数，比如List:ForEach；另外一类场景是通过LuaTable的Get函数指明一个lua函数绑定到一个delegate）。或者把一个lua table适配到一个C# interface，该delegate或者interface需要加上该配置。 XLua.DoNotGen 指明一个类里头的部分函数、字段、属性不生成代码，通过反射访问。 只能标准Dictionary\u003cType, List\u003e的field或者property。key指明的是生效的类，value是一个列表，配置的是不生成代码的函数、字段、属性的名字。 和ReflectionUse的区别是：1、ReflectionUse指明的是整个类；2、当第一次访问一个函数（字段、属性）时，ReflectionUse会把整个类都wrap，而DoNotGen只wrap该函数（字段、属性），换句话DoNotGen更lazy一些； 和BlackList的区别是：1、BlackList配了就不能用；2、BlackList能指明某重载函数，DoNotGen不能； ","date":"2022-02-17 15:37:27","objectID":"/xlua%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:0:1","tags":["Unity","lua"],"title":"Xlua性能测试","uri":"/xlua%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["Unity"],"content":"xlua 性能测试 环境 win 平台的 unity2020.3.21f1c1,xlua版本2.2.16 性能测试结果（1+2加法运算执行1亿次的耗时，毫秒单位） 案例 结果 CSharp 内调用 20.5071 lua 内调用 3000.00 Hotfix 模式Hotfix Inject In Editor后 170.0945 xlua.hotfix()修复后调用 9175.6273 LuaCallCSharp 标记前调用 184000.00 LuaCallCSharp 标记后调用 6000.00 Hotfix 模式下执行Hotfix Inject In Editor后 执行lua的xlua.hotfix()修复后调用 性能测试代码 using UnityEngine; using XLua; namespace LuaAnalysis { #region Calc Class /// \u003csummary\u003e /// 纯CSharp调用 /// LuaCallCSharp 标记前调用 /// \u003c/summary\u003e public class Calc1 { public static int Add(int a,int b) { return a+b; } } /// \u003csummary\u003e /// LuaCallCSharp 标记后调用 /// \u003c/summary\u003e [LuaCallCSharp] public class Calc { public static int Add(int a,int b) { return a+b; } } [Hotfix] public class HotfixCalc { public int Add(int a, int b) { return a - b; } /// \u003csummary\u003e /// Hotfix 标记后 /// \u003c/summary\u003e /// \u003cparam name=\"a\"\u003e\u003c/param\u003e /// \u003cparam name=\"b\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static int Add1(int a, int b) { return a - b; } /// \u003csummary\u003e /// Hotfix 标记后,注入后且xlua.hotfix修复后执行lua代码 /// \u003c/summary\u003e /// \u003cparam name=\"a\"\u003e\u003c/param\u003e /// \u003cparam name=\"b\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static int Add2(int a, int b) { return a - b; } } public class NoHotfixCalc { public int Add(int a, int b) { return a + b; } } #endregion public class Analysis : MonoBehaviour { static string lua=@\" local Add= function(a, b) return a + b end local count=100 * 1000 * 1000 starttime = os.time() for i=1,count,1 do Add(2,1) end endtime=os.time() print(string.format('Lua内调用 : %.2f', (endtime - starttime)*1000)) starttime = os.time() for i=1,count,1 do CS.LuaAnalysis.Calc1.Add(2,1) end endtime=os.time() print(string.format('LuaCallCSharp 标记前调用（反射访问） : %.2f', (endtime - starttime)*1000)) starttime = os.time() for i=1,count,1 do CS.LuaAnalysis.Calc.Add(2,1) end endtime=os.time() print(string.format('LuaCallCSharp 标记后调用（绑定访问） : %.2f', (endtime - starttime)*1000)) xlua.hotfix(CS.LuaAnalysis.HotfixCalc, 'Add2', function(a,b) return a+b end) \"; // Start is called before the first frame update void Start() { LuaEnv luaenv = new LuaEnv(); HotfixCalc calc = new HotfixCalc(); int CALL_TIME = 100 * 1000 * 1000; System.DateTime start; double d=0; luaenv.DoString(lua); start = System.DateTime.Now; for (int i = 0; i \u003c CALL_TIME; i++) { Calc1.Add(2, 1); } d = (System.DateTime.Now - start).TotalMilliseconds; Debug.Log(\"CSharp 内调用(静态方法):\" + d); start= System.DateTime.Now; for (int i = 0; i \u003c CALL_TIME; i++) { calc.Add(2, 1); } d = (System.DateTime.Now - start).TotalMilliseconds; Debug.Log(\"Hotfix 标记后(成员方法):\" + d); start= System.DateTime.Now; for (int i = 0; i \u003c CALL_TIME; i++) { HotfixCalc.Add1(2, 1); } d = (System.DateTime.Now - start).TotalMilliseconds; Debug.Log(\"Hotfix 标记后(静态方法):\" + d); start= System.DateTime.Now; for (int i = 0; i \u003c CALL_TIME; i++) { HotfixCalc.Add2(2, 1); } d = (System.DateTime.Now - start).TotalMilliseconds; Debug.Log(\"Hotfix 标记后(静态方法) lua.hotfix修复后:\" + d); // start= System.DateTime.Now; // for (int i = 0; i \u003c CALL_TIME; i++) // { // HotfixCalc.Add3(2, 1); // } // d = (System.DateTime.Now - start).TotalMilliseconds; // Debug.Log(\"Hotfix 标记后(静态方法,CSharpCallLua) lua.hotfix修复后:\" + d); luaenv.Dispose(); } } } 打印结果 LUA: Lua内调用 : 3000.00 LUA: LuaCallCSharp 标记前调用（反射访问） : 184000.00 LUA: LuaCallCSharp 标记后调用（绑定访问） : 6000.00 CSharp 内调用(静态方法):20.5071 Hotfix 标记后(成员方法):170.0945 Hotfix 标记后(静态方法):171.2534 Hotfix 标记后(静态方法) lua.hotfix修复后:9175.6273 ","date":"2022-02-17 15:37:27","objectID":"/xlua%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:0:2","tags":["Unity","lua"],"title":"Xlua性能测试","uri":"/xlua%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["笔记"],"content":"常用快捷键 ","date":"2022-02-02 22:17:18","objectID":"/shell%E7%AC%94%E8%AE%B0/:1:0","tags":["笔记","shell"],"title":"Shell笔记","uri":"/shell%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"查看环境变量 env | less -N printenv | less -N 打印变量 echo $? # mac or linux echo $PATH # windows echo %PATH% ","date":"2022-02-02 22:17:18","objectID":"/shell%E7%AC%94%E8%AE%B0/:2:0","tags":["笔记","shell"],"title":"Shell笔记","uri":"/shell%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"显示shell变量 set | less -N 打印变量 echo $? echo $TERM unset 复位变量 ","date":"2022-02-02 22:17:18","objectID":"/shell%E7%AC%94%E8%AE%B0/:3:0","tags":["笔记","shell"],"title":"Shell笔记","uri":"/shell%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"whereis 和 whatis [root@VM-24-15-centos ~]# whatis cp cp (1) - copy files and directories [root@VM-24-15-centos ~]# whereis cp cp: /usr/bin/cp /usr/share/man/man1/cp.1.gz [root@VM-24-15-centos ~]# ","date":"2022-02-02 22:17:18","objectID":"/shell%E7%AC%94%E8%AE%B0/:4:0","tags":["笔记","shell"],"title":"Shell笔记","uri":"/shell%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"who am i mrwang@CodingdeMBP hugo-project % who am i mrwang ttys000 Feb 3 12:43 mrwang@CodingdeMBP hugo-project % who are you mrwang ttys000 Feb 3 12:44 mrwang@CodingdeMBP hugo-project % who goes there mrwang ttys000 Feb 3 12:44 mrwang@CodingdeMBP hugo-project % who is god mrwang ttys000 Feb 3 12:44 ","date":"2022-02-02 22:17:18","objectID":"/shell%E7%AC%94%E8%AE%B0/:5:0","tags":["笔记","shell"],"title":"Shell笔记","uri":"/shell%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"键入信号：erase, werase, kill 信号 键 作用 erase \u003c Backspace \u003e / \u003c Delete \u003e 删除最后一个键入的字符 werase ^W 删除最后一个键入的单词 kill ^X / ^U 删除整行 ^X 将光标移动到行的开头位置 ","date":"2022-02-02 22:17:18","objectID":"/shell%E7%AC%94%E8%AE%B0/:6:0","tags":["笔记","shell"],"title":"Shell笔记","uri":"/shell%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"stty命令 ## 显示所有键盘映射当前设置 stty -a ## 屏蔽显示 stty -echo #禁止回显 stty echo #打开回显 ## 忽略回车符 stty igncr # 开启 stty -igncr # 恢复 ## 改变ctrl+D的方法: stty eof \"string\" # 系统默认是ctrl+D来表示文件的结束,而通过这种方法,可以改变! 信号 键 作用 erase \u003c Backspace \u003e / \u003c Delete \u003e 删除最后一个键入的字符 werase ^W 删除最后一个键入的单词 kill ^X / ^U 删除整行 stop ^S 暂停屏幕显示 start ^Q 重新启动屏幕显示 eof ^D 指示已经没有数据 ","date":"2022-02-02 22:17:18","objectID":"/shell%E7%AC%94%E8%AE%B0/:7:0","tags":["笔记","shell"],"title":"Shell笔记","uri":"/shell%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"less 命令 less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。 b 向上翻一页 空格键 向下翻一页 y 向上滚动一行 回车键 向下滚动一行 u 向上翻半页 d 向下翻半页 -i 忽略搜索时的大小写 -N 显示每行的行号 -o \u003c文件名\u003e 将less 输出的内容在指定文件中保存起来 -s 显示连续空行为一行 /字符串：向下搜索“字符串”的功能 ?字符串：向上搜索“字符串”的功能 n：重复前一个搜索（与 / 或 ? 有关） N：反向重复前一个搜索（与 / 或 ? 有关） -x \u003c数字\u003e 将“tab”键显示为规定的数字空格 h 显示帮助界面 Q 退出less 命令 [pagedown]： 向下翻动一页 [pageup]： 向上翻动一页 案例一 分页查看ps进程信息 ## -N 显示行号 ps -aux | less -N 案例二 查看多个文件 ## 可以使用 n 查看下一个，使用 p 查看前一个。 less 1.log 2.log ","date":"2022-02-02 22:17:18","objectID":"/shell%E7%AC%94%E8%AE%B0/:8:0","tags":["笔记","shell"],"title":"Shell笔记","uri":"/shell%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"scp 命令 scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。 使用scp需要远程用户密码；如果配置远程ssh的私钥则不用密码，自动使用私钥登陆 命令格式 scp [参数] [原路径] [目标路径] [目标路径]: user@server-ip:server-path 常用命令参数 -C - 这会在复制过程中压缩文件或目录。 -P - 如果默认 SSH 端口不是 22，则使用此选项指定 SSH 端口。 -r - 此选项递归复制目录及其内容。 -p - 保留文件的访问和修改时间。 复制文件到远程服务器 scp logs.tar.gz root@192.168.43.137:/root 复制远程服务器文件到本地 scp root@192.168.43.137:/root/logs.tar.gz ./ 复制文件夹到远程服务器 scp -rC syslog root@192.168.43.137:/root 复制远程服务器文件夹到本地 scp -rC root@192.168.43.137:/root syslog 参考: https://www.cnblogs.com/peida/archive/2013/03/15/2960802.html https://www.linuxprobe.com/scp-cmd-usage.html ","date":"2022-02-02 22:17:18","objectID":"/shell%E7%AC%94%E8%AE%B0/:9:0","tags":["笔记","shell"],"title":"Shell笔记","uri":"/shell%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"rsync 命令 Rsync（remote sync ; remote synchronous）是UNIX 及类UNIX 平台下一款神奇的数据镜像备份软件，它不像FTP 或其他文件传输服务那样需要进行全备份，Rsync 可以根据数据的变化进行差异备份，从而减少数据流量，提高工作效率。你可以使用它进行本地数据或远程数据的复制，Rsync 可以使用SSH 安全隧道进行加密数据传输。Rsync 服务器端定义源数据，Rsync 客户端仅在源数据发生改变后才会从服务器上实际复制数据至本地，如果源数据在服务器端被删除，则客户端数据也会被删除，以确保主机之间的数据是同步的。Rsync 使用TCP 873 端口。 使用rsync需要远程用户密码；如果配置远程ssh的私钥则不用密码，自动使用私钥登陆 配置文件：/etc/rsyncd.conf。 windows安装 rsync https://www.itefix.net/cwrsync https://www.cnblogs.com/zhangweiyi/p/10571273.html https://blog.csdn.net/zetion_3/article/details/103575905 常用参数： -a 包含-rtplgoD -r 同步目录时要加上，类似cp时的-r选项 -v 同步时显示一些信息，让我们知道同步的过程 -l 保留软连接 -L 加上该选项后，同步软链接时会把源文件给同步 -p 保持文件的权限属性 -o 保持文件的属主 -g 保持文件的属组 -D 保持设备文件信息 -t 保持文件的时间属性 --delete 删除DEST中SRC没有的文件 --exclude 过滤指定文件，如--exclude “logs”会把文件名包含logs的文件或者目录过滤掉，不同步 -P 显示同步过程，比如速率，比-v更加详细 -u 加上该选项后，如果DEST中的文件比SRC新，则不同步 -z 传输时压缩 同步文件夹 上传文件夹及同步 ## -r 递归处理文件夹 ## 文件夹最后必须带斜杠(/)，不带则远程会创建文件夹 ## 第一次同步后，第二次及后面的同步都是增量同步，存在的文件且相同的不会传输 rsync -r ~/pub/ 101.43.160.247:~/public/ ## --delete 本地如果删除文件或文件夹，同步后会删除远程的文件或文件夹（exclude 忽略的文件或文件夹除外） ## --exclude 本地忽略同步的文件或文件夹，例如项目中.git文件夹不需要同步到远程 rsync -rtvpz --delete --exclude .git ~/pub/ root@101.43.160.247:~/public/ rsync -rt --delete --exclude .git ~/pub/ 101.43.160.247:~/public/ 下载文件夹及同步 ## -r 递归处理文件夹 ## 文件夹最后必须带斜杠(/)，不带则远程会创建文件夹 ## 第一次同步后，第二次及后面的同步都是增量同步，存在的文件且相同的不会传输 rsync -r 101.43.160.247:~/public/ ~/pub/ ## --delete 本地如果删除文件或文件夹，同步后会删除远程的文件或文件夹（exclude 忽略的文件或文件夹除外） ## --exclude 本地忽略同步的文件或文件夹，例如项目中.git文件夹不需要同步到远程 rsync -rtvpz --delete --exclude .git 101.43.160.247:~/public/ ~/pub/ 同步文件 上传文件及同步 rsync ~/pub/a.txt 101.43.160.247:~/public/f.txt 下载文件及同步 rsync 101.43.160.247:~/public/f.txt ~/pub/a.txt 参考： https://www.jianshu.com/p/5a799b36c7e1 https://blog.csdn.net/allway2/article/details/103073243 Rsync同步时删除多余文件 rsync –exclude 参数 windows 上rsync客户端使用方法 ","date":"2022-02-02 22:17:18","objectID":"/shell%E7%AC%94%E8%AE%B0/:10:0","tags":["笔记","shell"],"title":"Shell笔记","uri":"/shell%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"md5sum 使用 centos 默认安装了md5sum命令 计算二进制文件的md5: # -b, --binary Read files in binary mode # -t, --text Read files in ASCII mode md5sum filename 计算字符串md5值： [root@xyz.com ~]$ echo -n 'hello world!' | md5sum fc3ff98e8c6a0d3087d515c0473f8677 - 注：一定要加上’-n’参数，代表去掉控制字符。 错误命令示例1： [root@xyz.com ~]$ echo 'hello world!' | md5sum c897d1410af8f2c74fba11b1db511e9e - 错误操作2：将文本hello world！写在文本文件中进行保存test文件，然后对文件进行md5sum。 mrwang@CodingdeMBP Sites % echo 'hello world!' | md5sum c897d1410af8f2c74fba11b1db511e9e - mrwang@CodingdeMBP Sites % cat test | md5sum c897d1410af8f2c74fba11b1db511e9e - mrwang@CodingdeMBP Sites % md5sum test c897d1410af8f2c74fba11b1db511e9e test mrwang@CodingdeMBP Sites % 此错误操作与错误1得到的结果一样，都是因为文本中会自动带上一些控制字符，从而导致最终计算出来的md5值不是纯粹字符串的md5值。 用vi打开test文件 使用vi 命令\"：set list\"，显示如下： hello world!$ 多了控制字符。 批量文件计算md5: #!/bin/sh #获取文件夹下所有文件 folder=\"./\" softfiles=$(ls $folder) cd ${folder} for sfile in ${softfiles} do md5sum $sfile \u003e\u003e ../md5sum.txt # md5sum $sfile done Mac 使用 md5sum: Mac没有自带md5sum， 需要安装md5sum。 使用brew安装 brew install md5sha1sum 参考： https://www.cnblogs.com/xd502djj/p/7055228.html http://www.blogjava.net/anchor110/articles/433319.html ","date":"2022-02-02 22:17:18","objectID":"/shell%E7%AC%94%E8%AE%B0/:11:0","tags":["笔记","shell"],"title":"Shell笔记","uri":"/shell%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"find 命令 查找文件或者文件夹test # 在当前目录查找文件或文件夹 test find test # 在根目录查找文件或文件夹 test find / -name test # 在根目录查找文件或文件夹 以test开头的 find / -name test* find / -name ‘test*’ # 在 home 目录查找文件或文件夹 包含 test 的 find /home -name *test* find /home -name ‘*test*’ 查找文件test # 在当前目录查找文件 test find test -type f # 在根目录查找文件 test find / -name test -type -f 查找文件夹test # 在当前目录查找文件夹 test find test -type f # 在根目录查找文件夹 test find / -name test -type -f 参考： https://www.runoob.com/linux/linux-comm-find.html https://blog.csdn.net/l_liangkk/article/details/81294260 ","date":"2022-02-02 22:17:18","objectID":"/shell%E7%AC%94%E8%AE%B0/:12:0","tags":["笔记","shell"],"title":"Shell笔记","uri":"/shell%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"tail 命令 Linux中用于查看文件尾部的内容，与head相对应。 常用来查看日志文件，通过 tail -f 实时查看文件最新内容。 尤其是对于日志文件较大的时候，通过tail指定输出的行数来查看日志。 // 输出最后10行的内容 tail test.log // 输出最后10行的内容，同时监视文件的变化，一旦变化就显示出来 tail -f test.log // 输出最后n行的内容，同时监视文件的变化，一旦变化就显示出来 tail -nf test.log // 输出文件最后10行的内容 tail -n 10 filename // 除第9行不显示外，显示第10行到末尾行 tail -n -10 filename // 从第20行至末尾 tail +20 test.log // 显示最后10个字符 tail -c 10 test.log // 实时日志查看与grep过滤关键字 // -A 除显示符合t匹配内容的那一行之外，并显示该行之后的内容 // -B 除显示符合匹配内容的那一行之外，并显示该行之前的内容 // -C 除显示符合匹配内容的那一列之外，并显示该列前后的内容 tail -f test.log | grep 'test' -C 5 tail -f test.log | grep 'test' -5 参考：https://blog.csdn.net/mo_247/article/details/103567545 ","date":"2022-02-02 22:17:18","objectID":"/shell%E7%AC%94%E8%AE%B0/:13:0","tags":["笔记","shell"],"title":"Shell笔记","uri":"/shell%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"curl 命令 https://www.cnblogs.com/duhuo/p/5695256.html https://www.ruanyifeng.com/blog/2019/09/curl-reference.html 常用命令 ","date":"2022-02-02 22:17:18","objectID":"/shell%E7%AC%94%E8%AE%B0/:14:0","tags":["笔记","shell"],"title":"Shell笔记","uri":"/shell%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"读取文件每一行 使用for循环 # 换行符必须是unix的\\n,不能是windows的\\r\\n,mac是\\r结尾 # `cat img.txt | tr \"\\r\\n\" \"\\n\" | tr \"\\r\" \"\\n\"` for line in `cat img.txt | tr '\\r\\n' '\\n'` do echo $line cp -f \"/d/Sites/hugo-project/content/imgs/${line}\" \"./imgs/${line}\" done 使用for循环 # 换行符必须是unix的\\n,不能是windows的\\r\\n,mac是\\r结尾 # $(cat img.txt | tr \"\\r\\n\" \"\\n\" | tr \"\\r\" \"\\n\") for line in $(cat img.txt| tr '\\r\\n' '\\n') do echo $line cp -f \"/d/Sites/hugo-project/content/imgs/${line}\" \"./imgs/${line}\" done 使用while循环 # 换行符必须是unix的\\n,不能是windows的\\r\\n,mac是\\r结尾 while read -r line do echo $line cp -f \"/d/Sites/hugo-project/content/imgs/${line}\" \"./imgs/${line}\" done \u003c filename 参考：https://www.cnblogs.com/oskb/p/9669186.html ","date":"2022-02-02 22:17:18","objectID":"/shell%E7%AC%94%E8%AE%B0/:15:0","tags":["笔记","shell"],"title":"Shell笔记","uri":"/shell%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":" 一些记录 bsdiff差分算法 出正式包怎么剥离无用的dll，比如log插件dll，Debug库，绘制插件dll（仅dev使用）参考 - 这里可以在打包正式包时将dll删除后打包 解决方案 1. 将所有Shader抽出打成一个独立bundle 2. 配置到工程设置中(需要测试) ![](../../imgs/2022-01-20-11-30-10.png) 3. 不建议使用URP自带shader 变体数量庞大，TA部门提供简化版本的Lit shader等等 -- ","date":"2022-01-17 21:51:13","objectID":"/%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/:0:0","tags":["笔记"],"title":"包体大小优化笔记","uri":"/%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"AssetBundle大小管理策略 主要问题：纹理，Shader，FBX动画 主要问题：纹理，Shader，Mesh，Terrain，FBX动画， #### 打包避免冗余 - 每个角色的AB文件中都有 `Universal Render Pipeline/Lit`和`\"Hidden/Universal Render Pipeline/FallbackError\"`两个Shader，出现严重冗余，需要调整打包策略，建议所有Shader打包一个AB文件 - 基类公共状态机冗余 ![](../../imgs/2022-01-24-21-54-50.png) *每个角色的包内都有该资源*，**需要验证** -- 图集、图片文件过大 使用第三方无损压缩，减小文件大小，这里文件大小是原来的1/3。 使用图片无损压缩打包测试，图片属性：RGBA 2048*2048,使用RGBA Crunched ETC2内存压缩 压缩尺寸 压缩前 压缩后 图片文件 1564kb 481kb AB文件 2048 268kb 260kb AB文件 1024 96kb 89kb 可以发现压缩后的图片打包AB文件比压缩前小大概7kb左右 图片在内存中没有压缩 纹理的压缩格式影响AB包的大小 (Android平台测试) 使用ETC2压缩生成AB包比使用 Crunched ETC生成AB包大3倍(这里只是说明压缩格式影响AB包文件大小，不说明压缩格式和包体的具体关系)。 Android平台 使用ETC 4Bit压缩后 使用 Crunched ETC 压缩（需要真机测试性能及是否支持该压缩格式），这个格式消耗cpu，进入GPU处理阶段会解压成etc压缩，GPU本身不支持 Crunched ETC压缩 推荐 Android 和IOS都用ASTC; 参考：ASTC纹理压缩格式详解 FBX文件过大 主要是animation和纹理占用比较大,每个带动画的角色都是这样的情况 FBX模型通过draco算法压缩为gltf格式 压缩大小比10倍，待测，不知道animation压缩怎么样 设置FBX Animation Compress格式 使用R220002@ui_comeout.fbx动画文件测试 现在的FBX配置 文件大小是4322kb，打包AB文件大小是1553kb 修改FBX配置（没有勾选 Resample Curves） 文件大小是4322kb,打包AB文件大小是499kb （这里fbx文件本身大小没变，untiy不修改源文件） 修改后的内存大小是原来的1/4，Ab文件是原来的1/3 （动画表现一致） 使用脚本剔除无用scale数据及修改数据精度（没有勾选 Resample Curves） 这种方式每次animation导入修改后都不会保持，因为untiy默认重新导入animation并计算数据，需要在animation后处理中处理，每次变化都要执行一遍 文件大小是4322kb,打包AB文件大小是310kb 修改后内存更低了和原始比是原来的不到1/4，AB文件是原来的1/5 （这里fbx文件本身大小没变，untiy不修改源文件） （动画表现一致） 如果所有的角色动画都进行调整，包体可以明显减小 fbx导入到Unity之后是不会变化的，就是说Unity里面的所有编辑都不会保存在FBX文件里,可能在meta文件中，这里没有测试。 注意压缩后需要真机测试看看动画是否一致，这里是win editor测试的，没有真机测试 参考： https://blog.uwa4d.com/archives/Optimization_Animation.html https://zhuanlan.zhihu.com/p/353402448 https://www.bzetu.com/344/.html https://blog.uwa4d.com/archives/UWA_Pipeline22.html 处理Animation时遇到的问题: 一个fbx上出现两个animation 动画，__preview_Take 001应该是美术没有删除干净 打包AB文件没有发现__preview_Take 001资源打包进去 可进行二次处理 ![](../../imgs/2022-01-20-17-10-26.png) *音频长度2分钟15秒* 音频单个文件1M多，会影响加载速度，比较慢 需要降低下音频质量，或者无损压缩，这个应该是背景，一般几百kb就可以，200kb-500kb左右即可 优化参考： #### Terrain使用问题 有多个Terrain Data占用太大 ![](../../imgs/2022-01-21-10-55-02.png) ![](../../imgs/2022-01-21-10-56-27.png) 如果确定不使用分块的方式处理场景，则需要Terrain导出Mesh，美术对Mesh直接减面去处理 **Terrain地形制作后最直接的问题是Mesh太大，没用的三角面太多** #### Mesh问题 有多个mesh占用太大，根据具体情况减面，是否没用的三角面过多 ![](../../imgs/2022-01-21-10-55-02.png) ![](../../imgs/2022-01-21-10-56-27.png) ![](../../imgs/2022-01-21-11-12-10.png) 静态批处理的Mesh占用比较大(new_scene) #### 图集优化 使用图集可以影响包体大小，需要测试 ![](../../imgs/2022-01-20-17-33-07.png) ![](../../imgs/2022-01-20-18-35-15.png) *蓝框中的new_common图集打包出错了，texture2D纹理没有打包进去，只是打包进去sprite数据，可能因为Library异常* 上面atlas前缀得AB文件是按照图集打包总共AB文件大小是`1.87M`，下面是散图打包的，总共AB文件大小是`6.93M`。对包体影响很大，需要细测，和图集利用率有关系 #### Shader过大 ![](../../imgs/2022-01-21-10-42-53.png) keywords组合不低于236种，造成Shader的AB文件太大，而且Sahder.Parse开销也会很大 所有Shader需要单独打包测试 #### 视频文件 ![](../../imgs/2022-01-21-11-07-54.png) 单个音频AB文件30M，内存占用也是30M左右 最后需要检查是否有优化的可能 #### TextAsset检查 ![](../../imgs/2022-01-21-11-24-01.png) 有几个场景Terrain分块后的数据AB包大概是9M左右（只是分块后的数据，没有素材和材质球等） 这里是Terrain分块后的数据，量比较大，检查是否有优化可能性 #### Mesh Animator使用 ![](../../imgs/2022-01-21-11-30-37.png) 这个fly.asset文件大小是15M左右，内存占用4M左右，打包AB文件比较大，这个AB文件3M左右 **是否有其他方式去替代优化** **内存分析需要着重关注** -- ","date":"2022-01-17 21:51:13","objectID":"/%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/:0:1","tags":["笔记"],"title":"包体大小优化笔记","uri":"/%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"AB加载和卸载策略 现有加载策略： 根据manifest配置文件进行加载资源并且找到依赖进行加载 只有同步加载没有异步加载 加载的Bundle和LoadAsset资源都做了缓存，但是没有引用计数 现有资源卸载策略: lua Bundle加载资源后直接卸载bundle； 场景加载后将bundle卸载,在切换场景时： - 执行LuaGC处理 - 清理所有Asset的引用（将缓存的Dict清空）（资源泄露:bundle没有卸载，清空了asset引用，再次加载资源时会再次LoadAsset，会存在多份相同asset;加载效率利用率低，没有区分常驻内存资源和非常驻内存资源，bundle管理粗放） 非场景资源加载后没有卸载流程,全部依靠场景卸载时清理 除了上述bundle卸载之外，游戏运行中没有卸载bundle，内存占用过高容易崩溃 业务层只管加载，不处理卸载 Resources.UnloadUnusedAssets()没有调用(场景加载时会自动调用，记不清了) 调整方案： 同步和异步加载 使用引用计数方案对Bundle和Asset管理 增加图集管理(图集制作细分方案待定) 使用加载和卸载成对管理，或者做内置管理和实例对象绑定 ","date":"2022-01-17 21:51:13","objectID":"/%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/:0:2","tags":["笔记"],"title":"包体大小优化笔记","uri":"/%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"URP Package 内置shader打包问题 Universal Render Pipeline/Lit has too many Shader variants(150994944) URP 自带Lit Shader变体太多问题 Assertion failed on expression:`m_UserPathRemap.count(pathStr) == 0` 可能因为在Project Setting–\u003eGraphing设置All include 然后打包又打进去所以报错了 ","date":"2022-01-17 21:51:13","objectID":"/%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/:0:3","tags":["笔记"],"title":"包体大小优化笔记","uri":"/%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"包体优化结果 左侧蓝色是优化后的，右侧红色是优化前的 DisableWriteTypeTree问题 关闭Bundle文件的type information数据写入，这是为了使用Unity版本不同做的兼容（标记数据，unity版本相同无用） //BuildAssetBundleOptions.DisableWriteTypeTree BuildPipeline.BuildAssetBundles(dir,ls.ToArray(),BuildAssetBundleOptions.DeterministicAssetBundle | BuildAssetBundleOptions.ChunkBasedCompression|BuildAssetBundleOptions.DisableWriteTypeTree, BuildTarget.Android); 红色是开启默认type information写入，asset classes就是写入的数据，左侧蓝色是关闭type information写入的大小 bundle文件大小差5k多（每个bundle文件内容不一样，大小也不一样），还是很可观的 参考：https://blog.csdn.net/kangluo1/article/details/119089200 ","date":"2022-01-17 21:51:13","objectID":"/%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/:0:4","tags":["笔记"],"title":"包体大小优化笔记","uri":"/%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"Shader变体处理 Graphics APIs 只保留OpenGLEL3就可以了,否则打包Shader时每个平台生成一套代码导致AB包过大 Graphics -\u003e Tier Settings默认三种配置，每个shader会生成对应三套代码，这里将Tier三种配置设置成相同的，则Shader只会生成一套代码，减小包体 单独打包Shader文件（没有材质球） 关于#pragma multi_compile和#pragma shader_feature 测试 #pragma multi_compile COM_M COM_N #pragma multi_compile COM_X COM_Y COM_Z #pragma shader_feature _ A B #pragma shader_feature E F 打包的AB包中的Shader keywords数量 multi_compile两行的keywords组合相乘是最后的shader代码的数量，注意数量 这里#pragma shader_feature 如果第一项是_则认为没有keywords,如果不是_，则默认打包进第一个选项（这里是E） 单独打包材质球（将材质球和shader打包一起） #pragma multi_compile COM_M COM_N #pragma multi_compile COM_X COM_Y COM_Z #pragma shader_feature _ A B #pragma shader_feature E F 打包的AB包中的Shader keywords数量 材质球keywords默认： 材质球指定keywords后 指定keywords后等于选择shader_feature的变体，multi_compile进行全部组合 总结：材质球指定shader_feature keywords后和shader打包到AB文件中，shader的keywords是受材质球的keywords配置影响的;加入了GraphicsSetting-\u003e always included shader后，会将它所有的keywords变体打包到游戏中 可以用Shader Variant Collection单独控制keywords，把collection和shader打包到一个AB文件中 参考： https://zhuanlan.zhihu.com/p/68888831 https://blog.csdn.net/eevee_1/article/details/118632371 https://zhuanlan.zhihu.com/p/392004640 https://blog.csdn.net/danteshenqu/article/details/78170745 https://zhuanlan.zhihu.com/p/83780152 关于 GraphicsSetting-\u003e always included shader说明： 如果打AB时不想shader被打包进AB包，则用 always included shader 添加shader，单只能是unity buildin 内置shader（Packages内的shader不是内置的）。 cube11和cube1使用的shader是Unlit/Color,Cube22和Cube2使用的shader是custom/Cube2；每个ab文件内只有一个cube物体的prefab，引用一个材质球和对应的shader AB文件cube11和cube22是在always included shader添加前打包的，AB文件Cube1和Cube2是在always included shader添加后打包的 根据上面打包测试分析出结果： Cube22和Cube2使用自定义shader custom/Cube2 ，不管always included shader内是否添加该shader，打AB包都会把该shader打包进去 Cube11和Cube1使用内置shader Unlit/Color,always included shader内添加该shader，打包AB包不会把该内置shader打包进去；否则会打包进AB包内 URP内Shader算是自定义shader，不管always included shader内是否添加，都会将使用的URP Shader打包到对应AB包中 ","date":"2022-01-17 21:51:13","objectID":"/%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/:0:5","tags":["笔记"],"title":"包体大小优化笔记","uri":"/%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"关于URP Shader打包问题 由于URP内部的Shader在Packages中，不能使用Inspector面板设置AssetBundleName及脚本代码设置AssetBundleName。在Graphics面板中添加URP shader，但是打包还是会被打进去 解决方案： 1. 使用AssetBundleBuild方式打包可以控制Packages内的资源 2. 使用Addressables官方插件打包可以设置Packages内的资源 材质球和shader打包到一起，会根据材质球引用的keywords变体打包，而加入了GraphicsSetting-\u003e always included shader后，会将它所有的keywords变体打包到游戏中 关于shader变体说明：https://blog.csdn.net/kuangben2000/article/details/105400835 ","date":"2022-01-17 21:51:13","objectID":"/%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/:0:6","tags":["笔记"],"title":"包体大小优化笔记","uri":"/%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/"},{"categories":["shader"],"content":"角色展示 需要的贴图： 漫反射贴图；法线贴图；Metal，Roughness，SkinArea通道贴图CompMask（M,R,S）；次表面散射LUT查找图；IBL Specular CubeMap环境图；IBL Diffuse 球谐数据（提前读取IBL Diffuse CubeMap数据）;头发Aniso各向异性Noise贴图 漫反射，镜面反射，环境反射，环境高光 身体部分 组成： 直接光漫反射 Lambert 直接光的镜面反射 Blinn-Phong 皮肤区域给一个很弱的高光（油光） 间接光的漫反射 SH（球谐） 间接光的镜面反射 CubeMap （Specular） LUT SSS次表面散射（皮肤处理） LUT实现 色彩矫正 ToneMaping ACES Shader \"Custom/Role_Standard\" { Properties { _MainTex (\"Texture\", 2D) = \"white\" {} _CompMask(\"CompMask(R M)\",2D) = \"white\"{} _NormalMap(\"NormalMap\",2D) = \"bump\"{} _SpecShininess(\"Spec Shininess\",Float)=10 _RoughnessAdjust(\"Roughness Adjust\",Range(-1,1))=0 _MetalAdjust(\"Metal Adjust\",Range(-1,1))=0 _SkinLUT(\"Skin LUT\",2D)=\"white\"{} _CurveOffset(\"Curve Offset\",Range(0,1))=1 _LutOffset(\"LutOffset\",Range(0,1))=0 [Header(IBL Specular)] _Tint(\"Tint\",Color)=(1,1,1,1) _Expose(\"Expose\",Float)=1.0 _EnvMap(\"Env Cube\",Cube)=\"white\"{} _Rotate(\"Rotate\",Range(0,360))=0 [Toggle(_DIFFUSE_ON)]_DiffuseCheck(\"Diffuse Check\",Float)=0 [Toggle(_SPECULAR_ON)]_Specular_Check(\"Specular Check\",Float)=0 [Toggle(_SH_ON)]_SHCheck(\"SH Check\",Float)=0 [Toggle(_IBL_ON)]_IBLCheck(\"IBL Check\",Float)=0 [Toggle(_OILSKIN_ON)]_OilSkinCheck(\"Oil Skin Check\",Float)=0 [Space(20)] [Header(SH)] [HideInInspector]custom_SHAr(\"Custom SHAr\", Vector) = (0, 0, 0, 0) [HideInInspector]custom_SHAg(\"Custom SHAg\", Vector) = (0, 0, 0, 0) [HideInInspector]custom_SHAb(\"Custom SHAb\", Vector) = (0, 0, 0, 0) [HideInInspector]custom_SHBr(\"Custom SHBr\", Vector) = (0, 0, 0, 0) [HideInInspector]custom_SHBg(\"Custom SHBg\", Vector) = (0, 0, 0, 0) [HideInInspector]custom_SHBb(\"Custom SHBb\", Vector) = (0, 0, 0, 0) [HideInInspector]custom_SHC(\"Custom SHC\", Vector) = (0, 0, 0, 1) } SubShader { Tags { \"RenderType\"=\"Opaque\" } LOD 100 Pass { Tags{\"LightMode\" = \"ForwardBase\"} CGPROGRAM #pragma vertex vert #pragma fragment frag #pragma multi_compile_fwdbase #pragma shader_feature _DIFFUSE_ON #pragma shader_feature _SPECULAR_ON #pragma shader_feature _SH_ON #pragma shader_feature _IBL_ON #pragma shader_feature _OILSKIN_ON #include \"UnityCG.cginc\" #include\"AutoLight.cginc\" struct appdata // appdata_full { float4 vertex : POSITION; //模型空间顶点坐标 half2 texcoord : TEXCOORD0; //第一套UV（模型最多只能有4套UV） half3 normal : NORMAL; //顶点法线 half4 tangent : TANGENT; //顶点切线(模型导入Unity后自动计算得到) }; struct v2f { float4 pos : SV_POSITION; //输出裁剪空间下的顶点坐标数据，给光栅化使用，必须要写的数据 float2 uv : TEXCOORD0; //自定义数据体 half3 normal_dir : TEXCOORD1; half3 tangent_dir : TEXCOORD2; half3 binormal_dir : TEXCOORD3; half3 pos_world : TEXCOORD4; //最多可以写16个：TEXCOORD0 ~ TEXCOORD15。 LIGHTING_COORDS(5,6) ///SHADOW 第一步 }; sampler2D _MainTex; sampler2D _CompMask; float4 _MainTex_ST; float4 _LightColor0; float _Shininess; float4 _AmbientColor; float _SpecIntensity; sampler2D _AOMap; sampler2D _SpecMask; sampler2D _NormalMap; float _NormalIntensity; sampler2D _ParallaxMap; float _Parallax; float _SpecShininess; float _RoughnessAdjust; float _MetalAdjust; float4 _Tint; float _Expose; float _Rotate; samplerCUBE _EnvMap; float4 _EnvMap_HDR; sampler2D _SkinLUT; float _CurveOffset; float _LutOffset; half4 custom_SHAr; half4 custom_SHAg; half4 custom_SHAb; half4 custom_SHBr; half4 custom_SHBg; half4 custom_SHBb; half4 custom_SHC; float3 ShadeSH(float3 normal_dir) { float4 normalForSH = float4(normal_dir, 1.0); //SHEvalLinearL0L1 half3 x; x.r = dot(custom_SHAr, normalForSH); x.g = dot(custom_SHAg, normalForSH); x.b = dot(custom_SHAb, normalForSH); //SHEvalLinearL2 half3 x1, x2; // 4 of the quadratic (L2) polynomials half4 vB = normalForSH.xyzz * normalForSH.yzzx; x1.r = dot(custom_SHBr, vB); x1.g = dot(custom_SHBg, vB); x1.b = dot(custom_SHBb, vB); // Final (5th) quadratic (L2) polynomial half vC = normalForSH.x*normalForSH.x - normalForSH.y*normalForSH.y; x2 = custom_SHC.rgb * vC; float3 sh = max(float3(0.0, 0.0, 0.0), (x + x1 + x2)); sh = pow(sh, 1.0 / 2.2); return sh; } float3 ACESFilm(float3 x) { float a = 2.51f; float b = 0.03f; float c = 2.43f; float d = 0.59f; float e = 0.14f; return saturate((x*(a*x + b)) / (x*(c*x + d) + e)); }; v2f v","date":"2021-12-21 17:16:51","objectID":"/shader%E6%A1%88%E4%BE%8B/:0:1","tags":["shader"],"title":"Shader案例","uri":"/shader%E6%A1%88%E4%BE%8B/"},{"categories":["shader"],"content":"玉龙 漫反射，透射光（高光），环境光 透射光实现：根据光反方向（增加法线的扭曲，表示玉龙表面的粗糙情况影响光线的方向）和视线方向夹角来判定透射光的强度（假设从玉龙后面有个手电筒和人眼的夹角，越小表示人眼看到的光线越多，光越强），然后通过厚度图来模拟玉龙的通透性 Shader \"CS03/Dragon\" { Properties { _DiffuseColor (\"Diffuse Color\", Color) = (1,1,1,1) _Opacity(\"Opacity\",Float)=1 _AddColor (\"Add Color\", Color) = (1,1,1,1) _Distort(\"Distort\",Range(0,1))=0 _Power(\"Power\",Float)=2 _Scale(\"Scale\",Float)=1 _ThicknessMap (\"Thickness Map\", 2D) = \"black\" {} _CubeMap (\"Cube Map\", CUBE) = \"white\" {} _EnvRotate(\"Env Rotate\",Range(0,360))=0 } SubShader { Tags { \"RenderType\"=\"Opaque\" } LOD 100 Pass { Tags{\"LightMode\" = \"ForwardBase\"} CGPROGRAM #pragma vertex vert #pragma fragment frag #pragma multi_compile_fwdbase #include \"UnityCG.cginc\" #include\"AutoLight.cginc\" struct appdata // appdata_full { float4 vertex : POSITION; //模型空间顶点坐标 half2 texcoord : TEXCOORD0; //第一套UV（模型最多只能有4套UV） half2 texcoord1 : TEXCOORD1; //第二套UV half2 texcoord2 : TEXCOORD2; //第三套UV half2 texcoord3 : TEXCOORD3; //第四套UV，模型最多只能有4套UV half4 color : COLOR; //顶点颜色 half3 normal : NORMAL; //顶点法线 half4 tangent : TANGENT; //顶点切线(模型导入Unity后自动计算得到) }; struct v2f { float4 pos : SV_POSITION; //输出裁剪空间下的顶点坐标数据，给光栅化使用，必须要写的数据 float2 uv : TEXCOORD0; //自定义数据体 half3 normal_dir : TEXCOORD1; half3 tangent_dir : TEXCOORD2; half3 binormal_dir : TEXCOORD3; half3 pos_world : TEXCOORD4; //最多可以写16个：TEXCOORD0 ~ TEXCOORD15。 }; sampler2D _MainTex; float4 _MainTex_ST; float4 _LightColor0; sampler2D _NormalMap; float _Distort; float _Power; float _Scale; sampler2D _ThicknessMap; samplerCUBE _CubeMap; float4 _CubeMap_HDR; float _EnvRotate; float4 _DiffuseColor; float4 _AddColor; float _Opacity; v2f vert (appdata v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.uv=TRANSFORM_TEX(v.texcoord,_MainTex); o.pos_world=mul(unity_ObjectToWorld,v.vertex).xyz; o.normal_dir=normalize(mul(v.normal,(float3x3)unity_WorldToObject)); o.tangent_dir=normalize(mul((float3x3)unity_ObjectToWorld,v.tangent.xyz)); o.binormal_dir=normalize(cross(o.normal_dir, o.tangent_dir))*v.tangent.w; return o; } half4 frag (v2f i) : SV_Target { half3 pos_world=i.pos_world; half3 normal_dir=normalize(i.normal_dir); half3 tangent_dir=normalize(i.tangent_dir); half3 binormal_dir=normalize(i.binormal_dir); half3 view_dir=normalize(_WorldSpaceCameraPos.xyz-pos_world); float3x3 TBN=float3x3(tangent_dir,binormal_dir,normal_dir); // Light half3 light_dir=normalize(_WorldSpaceLightPos0.xyz); half4 light_color=_LightColor0.rgba; half atten=1.0; //漫反射 float NdotL=max(0.0,dot(normal_dir,light_dir)); float3 color_diffuse=NdotL*_DiffuseColor.rgb*light_color.rgb; float sky_light=(dot(normal_dir,float3(0,1,0))+1.0)*0.5; float3 color_sky=sky_light*_DiffuseColor.rgb; float3 final_diffuse=color_diffuse+_AddColor.rgb+color_sky*_Opacity; // 透射光 float3 back_dir=-normalize(light_dir+normal_dir*_Distort); float VdotB=max(0.0,dot(view_dir,back_dir)); float backlight_term=max(0.0,pow(VdotB,_Power))*_Scale; float thickness=1.0-tex2D(_ThicknessMap,i.uv).r; half3 back_color=backlight_term*light_color*thickness; // 光泽反射 float3 rView_dir=reflect(-view_dir,normal_dir); float drag=_EnvRotate*UNITY_PI/180.0; float2x2 Roration=float2x2(cos(drag),sin(drag),-sin(drag),cos(drag)); rView_dir.xz=mul(Roration,rView_dir.xz); half4 color_cube=texCUBE(_CubeMap,rView_dir); float3 color_env=DecodeHDR(color_cube,_CubeMap_HDR); half fresnel=1.0-max(0.0,dot(normal_dir,view_dir)); float3 final_env=color_env*fresnel; float3 color_final=final_diffuse+final_env+ back_color; // return half4(thickness.xxx,1.0); return half4(color_final,1.0); } ENDCG } Pass { Tags{\"LightMode\" = \"ForwardAdd\"} Blend One One CGPROGRAM #pragma vertex vert #pragma fragment frag #pragma multi_compile_fwdadd #include \"UnityCG.cginc\" #include\"AutoLight.cginc\" struct appdata // appdata_full { float4 vertex : POSITION; //模型空间顶点坐标 half2 texcoord : TEXCOORD0; //第一套UV（模型最多只能有4套UV） half2 texcoord1 : TEXCOORD1; //第二套UV half2 texcoord2 : TEXCOORD2; //第三套UV half2 texcoord3 : TEXCOORD3; //第四套UV，模型最多只能有4套UV half4 color : COLOR; //顶点颜色 half3 normal : NORMAL; //","date":"2021-12-21 17:16:51","objectID":"/shader%E6%A1%88%E4%BE%8B/:0:2","tags":["shader"],"title":"Shader案例","uri":"/shader%E6%A1%88%E4%BE%8B/"},{"categories":["shader"],"content":"钻石 双Pass渲染，一个背面渲染（cubemap的反射和折射），一个前面渲染（折射和菲涅尔） ASE // Made with Amplify Shader Editor // Available at the Unity Asset Store - http://u3d.as/y3X Shader \"CS07/Diamond\" { Properties { _ColorA(\"Color A\", Color) = (0.02491992,0.09269338,0.754717,0) _RefractTex(\"RefractTex\", CUBE) = \"white\" {} _ReflectTex(\"ReflectTex\", CUBE) = \"white\" {} _ReflectIntensity(\"ReflectIntensity\", Float) = 1 _RefractIntensity(\"RefractIntensity\", Float) = 1 _RimPower(\"RimPower\", Float) = 5 _RimBias(\"RimBias\", Float) = 0 _RimScale(\"RimScale\", Float) = 0 _RimColor(\"RimColor\", Color) = (0,0,0,0) } SubShader { Tags { \"RenderType\"=\"Opaque\" \"Queue\"=\"Geometry\" } LOD 100 Pass { Name \"Unlit\" Tags { \"LightMode\"=\"ForwardBase\" } CGINCLUDE #pragma target 3.0 ENDCG Blend Off AlphaToMask Off Cull Front ColorMask RGBA ZWrite On ZTest LEqual Offset 0 , 0 CGPROGRAM #ifndef UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX //only defining to not throw compilation error over Unity 5.5 #define UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input) #endif #pragma vertex vert #pragma fragment frag #pragma multi_compile_instancing #include \"UnityCG.cginc\" #define ASE_NEEDS_FRAG_WORLD_POSITION struct appdata { float4 vertex : POSITION; float4 color : COLOR; float3 ase_normal : NORMAL; UNITY_VERTEX_INPUT_INSTANCE_ID }; struct v2f { float4 vertex : SV_POSITION; #ifdef ASE_NEEDS_FRAG_WORLD_POSITION float3 worldPos : TEXCOORD0; #endif float4 ase_texcoord1 : TEXCOORD1; UNITY_VERTEX_INPUT_INSTANCE_ID UNITY_VERTEX_OUTPUT_STEREO }; uniform float4 _ColorA; uniform samplerCUBE _RefractTex; uniform samplerCUBE _ReflectTex; uniform float _RefractIntensity; v2f vert ( appdata v ) { v2f o; UNITY_SETUP_INSTANCE_ID(v); UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o); UNITY_TRANSFER_INSTANCE_ID(v, o); float3 ase_worldNormal = UnityObjectToWorldNormal(v.ase_normal); o.ase_texcoord1.xyz = ase_worldNormal; //setting value to unused interpolator channels and avoid initialization warnings o.ase_texcoord1.w = 0; float3 vertexValue = float3(0, 0, 0); #if ASE_ABSOLUTE_VERTEX_POS vertexValue = v.vertex.xyz; #endif vertexValue = vertexValue; #if ASE_ABSOLUTE_VERTEX_POS v.vertex.xyz = vertexValue; #else v.vertex.xyz += vertexValue; #endif o.vertex = UnityObjectToClipPos(v.vertex); #ifdef ASE_NEEDS_FRAG_WORLD_POSITION o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; #endif return o; } fixed4 frag (v2f i ) : SV_Target { UNITY_SETUP_INSTANCE_ID(i); UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i); fixed4 finalColor; #ifdef ASE_NEEDS_FRAG_WORLD_POSITION float3 WorldPosition = i.worldPos; #endif float3 ase_worldNormal = i.ase_texcoord1.xyz; float3 ase_worldViewDir = UnityWorldSpaceViewDir(WorldPosition); ase_worldViewDir = normalize(ase_worldViewDir); float3 ase_worldReflection = reflect(-ase_worldViewDir, ase_worldNormal); float4 texCUBENode7 = texCUBE( _ReflectTex, ase_worldReflection ); float4 temp_output_12_0 = ( _ColorA * texCUBE( _RefractTex, ase_worldReflection ) * texCUBENode7 * _RefractIntensity ); finalColor = temp_output_12_0; return finalColor; } ENDCG } Pass { Name \"Second\" Tags { \"LightMode\"=\"ForwardBase\" } CGINCLUDE #pragma target 3.0 ENDCG Blend One One AlphaToMask Off Cull Back ColorMask RGBA ZWrite On ZTest LEqual Offset 0 , 0 CGPROGRAM #ifndef UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX //only defining to not throw compilation error over Unity 5.5 #define UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input) #endif #pragma vertex vert #pragma fragment frag #pragma multi_compile_instancing #include \"UnityCG.cginc\" #define ASE_NEEDS_FRAG_WORLD_POSITION struct appdata { float4 vertex : POSITION; float4 color : COLOR; float3 ase_normal : NORMAL; UNITY_VERTEX_INPUT_INSTANCE_ID }; struct v2f { float4 vertex : SV_POSITION; #ifdef ASE_NEEDS_FRAG_WORLD_POSITION float3 worldPos : TEXCOORD0; #endif float4 ase_texcoord1 : TEXCOORD1; UNITY_VERTEX_INPUT_INSTANCE_ID UNITY_VERTEX_OUTPUT_STEREO }; uniform float4 _ColorA; uniform samplerCUBE _RefractTex; uniform samplerCUBE _ReflectTex; uniform float _RefractIntensity; uniform float _ReflectIn","date":"2021-12-21 17:16:51","objectID":"/shader%E6%A1%88%E4%BE%8B/:0:3","tags":["shader"],"title":"Shader案例","uri":"/shader%E6%A1%88%E4%BE%8B/"},{"categories":["shader","笔记"],"content":"什么是PBR PBR即基于物理的渲染过程。 PBR 并不是“一项”技术，它是由一系列技术的集合。 满足以下条件的光照模型才能称之为PBR光照模型： 基于微平面模型（Be based on the microfacet surface model） 能量守恒（Be energy conserving） 使用基于物理的BRDF（Use a physically based BRDF） 参考：https://learnopengl-cn.github.io/07%20PBR/01%20Theory/ PBR，或者用更通俗一些的称呼是指基于物理的渲染(Physically Based Rendering)，它指的是一些在不同程度上都基于与现实世界的物理原理更相符的基本理论所构成的渲染技术的集合。正因为基于物理的渲染目的便是为了使用一种更符合物理学规律的方式来模拟光线，因此这种渲染方式与我们原来的Phong或者Blinn-Phong光照算法相比总体上看起来要更真实一些。除了看起来更好些以外，由于它与物理性质非常接近，因此我们（尤其是美术师们）可以直接以物理参数为依据来编写表面材质，而不必依靠粗劣的修改与调整来让光照效果看上去正常。使用基于物理参数的方法来编写材质还有一个更大的好处，就是不论光照条件如何，这些材质看上去都会是正确的，而在非PBR的渲染管线当中有些东西就不会那么真实了。 虽然如此，基于物理的渲染仍然只是对基于物理原理的现实世界的一种近似，这也就是为什么它被称为基于物理的着色(Physically based Shading) 而非物理着色(Physical Shading)的原因。 ","date":"2021-12-07 13:39:26","objectID":"/pbr%E7%AC%94%E8%AE%B0/:0:1","tags":["shader","笔记"],"title":"PBR笔记","uri":"/pbr%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"基于物理渲染的优点 很容易就可以作出真实和照片级的效果 同一配置可以适用于在不同HDR光照环境下 接口简单而直观，都是基于世界真实的参数。（如粗糙度，金属度，等等） 不需要美术去提供经验性的”奇怪”参数和配置 更容易去解决问题和扩展需求 ","date":"2021-12-07 13:39:26","objectID":"/pbr%E7%AC%94%E8%AE%B0/:0:2","tags":["shader","笔记"],"title":"PBR笔记","uri":"/pbr%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"基于物理的渲染和传统区别 有着基于物理规则的光照模式 有着无处不在的fresnel效果 (指当光到达两种材质的接触面时，一些光在接触面的表面被反射出去，而另一部分光将发生折射穿过接触面) 能量守恒“energy conservation”，物体平面的反射光无法超过它所解接受的入射光 基于物体材质，会分辨金属和介电质，微平面的概念 线性空间的光照，支持gamma矫正的，HDR渲染和tonemap ","date":"2021-12-07 13:39:26","objectID":"/pbr%E7%AC%94%E8%AE%B0/:0:3","tags":["shader","笔记"],"title":"PBR笔记","uri":"/pbr%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"PBR特征 这节阐述的是PBR呈现的效果特征，而非底层物理原理的特征。 相比传统的Lambert着色和Phong着色，PBR着色在效果上有着质的提升，可以表示更多更复杂的材质特征： 表面细节 物体粗糙度 区别明显的金属和绝缘体 物体的浑浊程度 菲涅尔现象：不同角度有不同强度的反射光 半透明物体 多层混合材质 清漆效果 其它更复杂的表面特征 Phong模型着色效果，只能简单地表现理想模型的漫反射和高光，渲染出的效果跟真实世界相差甚远。 PBR材质效果球，它们真实地渲染出各类材质的粗糙、纹理、高光、清漆、边缘光等等表面细节特征。PBR对渲染效果真实感的提升可见一斑。 ","date":"2021-12-07 13:39:26","objectID":"/pbr%E7%AC%94%E8%AE%B0/:0:4","tags":["shader","笔记"],"title":"PBR笔记","uri":"/pbr%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"PBR和PBS的关系 PBR（Physically Based Rendering）是一种渲染方式(基于物理渲染)，它使用的材质是PBS（Physically Based Shader），中文名：基于物理的渲染技术(基于物理着色)。可以对光和材质之间的行为进行更加真实的建模。PBS只考虑材质在真实物理环境下应该有的效果。PBR包围的范围会更广一些，比如GI/AO/SUN等复杂情况，这些东西加上PBS，才是PBR。 Unity中的PBS即是把PBR算法封装起来，只用修改PBS的参数就能达到PBR的效果。 在Unity中，PBS分为两类，一个叫做Standard，一个叫做Standard（Specular Setup）,我们把它称为标准着色器的高光版，它们共同组成了一个完整的PBS光照明模型，而且非常易于使用。 ","date":"2021-12-07 13:39:26","objectID":"/pbr%E7%AC%94%E8%AE%B0/:0:5","tags":["shader","笔记"],"title":"PBR笔记","uri":"/pbr%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"光与物质的交互（light and matter） 光是一种横向传播的电磁波，电磁波的波长范围非常广，但只有390~760nm之间的一段波谱是人眼可见到的，也就是在图形学里对渲染着色起作用的部分。另外因为光有波粒二象性的缘故，有时候我们在图形学里也会把光做为光子（photon）来处理。 当光投射到传感器（眼睛，照相机等）上时，颜色和亮度就会被吸收并感知，而光与物质交互后被感知的，就是物体的颜色。 物质对光的影响，可以用折射率（refractive index）来描述，当由复数来表示折射率时，它的实部影响速度（相对于真空中的速度），虚部来影响光的衰减（被吸收），折射率会改变光的波长。 我们先根据物质按照内部折射率是否均匀来进行分类： 均匀介质（Homogeneous Media）—直线传播 内部密度相同的物质，意味着他有唯一的折射率，对应透明的均匀物质来讲（如水，玻璃），光通过时，并不会改变光的颜色或强度，而当物质对某一种可见光谱有吸收率的时候，那么，光就会随着在物质内的传播距离而逐渐被吸收，而光的方向并不发生改变，这就是光被吸收（absorption）。 光穿透玻璃和水时，方向、颜色和强度都不会发生： 如果物质对某一种可见光谱有吸收率时，光方向不会发生变化，而光的强度会随着距离丧失强度（改变颜色），也就是光被吸收了： 非均匀介质（heterogeneous medium）—散射 当非均匀物质内部的折射率变化斜率很大时（突变），就会发生散射（Scattering）现象，光会被分割为多个方向，但光的总量并不会发生变化： 除了以上两种交互外，物质还可能因为其他能量发出新的光，称为自发光“emission”。 光与物质交互的三种方式：吸收、散射、自发光 示意图如下： 散射(Scattering): 由观察尺度划分 漫反射(Diffuse): 观察像素大于散射距离 次表面散射(Subsurface Scattering): 观察像素小于散射距离 透射(Transmission): 入射光经过折射穿过物体后的出射现象, 为次表面散射的特例 另外，折射率缓慢的逐渐变化不会导致光线的分离，而是导致其传播路径的弯曲。 当空气密度因温度而变化时，通常可以看到这种效果，例如海市蜃楼（mirages）和热形变（heat distortion）。见下图。 ","date":"2021-12-07 13:39:26","objectID":"/pbr%E7%AC%94%E8%AE%B0/:0:6","tags":["shader","笔记"],"title":"PBR笔记","uri":"/pbr%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"光与平面的交互（light and object surface） 上面我们讲了光在密度不同的物质内传递的现象，而渲染中最为典型的，是发生在物体表面时，关于光与空气和物质之间的散射效果。 这个时候平面散射光会分为两部分：进入平面的部分（折射，在物体内部传播中被吸收或散射），从平面出去的部分（反射）;一个假设完美无限光学平坦的平面（简称光学平面）反射效果，平面两侧的空气和物体有各自的折射率： 但实际上，平面大多都不是光学平面（除了镜子或镜头等），而是一种微几何体（Microgeometry），表面都会有一些比可见光波长要大的不规则凹凸，但又小到无法覆盖一个像素或者采样点，所以，我们就把这种非光学平面，理解为一组微小光学平面的集合，而可见光的反射，实际上是在平面各个点上轻微不同方向的反射集合，也就是后面会提到的微平面理论（Microsurface Theory）。 ","date":"2021-12-07 13:39:26","objectID":"/pbr%E7%AC%94%E8%AE%B0/:0:7","tags":["shader","笔记"],"title":"PBR笔记","uri":"/pbr%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"Fresnel（菲涅尔）反射 Fresnel表现的是材质的反射率和入射角（也就是光源入射向量和平面法线向量的夹角）的对应关系 表示观察看到的反射光线的向量与视角相关的现象 光线以不同角度入射会有不同反射率, 掠射角度(90)下反射率最大 F0: 平行于表面法向量入射的菲涅尔反射值, 任意角度的菲涅尔反射可由 F0 和入射角度计算得出 光线对于不同物质有不同的反射率, 非金属 F0: 0.02~0.04, 金属 F0: 0.7~1.0 光线入射角越大，镜面反射的比例越大 如果要达到真实的fresnel，那么美术对fresnel的控制应该越少越好，需要提供一些参数值来使用，通常是**光泽度(Gloss，或粗糙度 Roughness)**和反射率（Reflectivity）。提供一个基础反射率，来设置平面最小的反射值，让fresnel曲线从这个最小反射值开始，以满足不同角度的需求。 次级表面散射（Subsurface Scattering） 菲涅尔方程定义的是在不同观察方向上，表面上被反射的光除以被折射的光的比例。我们通过该方程可以计算得到被反射的光的能量，根据能量守恒我们就可以得知被折射进物体的光的能量了。那些折射进物体的光也没闲着，他们在物体内进行着称之为**次表面散射（Subsurface Scattering）**的行为，最终会看似随机地射出表面。如下图所示： 其中黄色出射光为直接反射光，红色出射光为次表面反射光。可以看到，在一个平滑的平面上（即不考虑微平面理论），在宏观上来说，反射光即为材质的高光 specular 部分，而次表面反射因为是完全随机出射，所以构成了漫反射 diffuse 部分。 这里还是得提一句 Subsurface Scattering 的注意事项。先从引擎玩起再来补图形学知识的人可能会疑惑，Subsurface Scattering 不是做皮肤那种，模拟光从一个像素点入射，从另一个像素点出射的物理现象吗？但这里整篇文章模拟的都是一个像素所覆盖的平面所产生的物理属性（还是之前提到的 pixel footprint 的概念），而这种跨越多个像素的、宏观的次表面反射会在后面使用一个单独的物理模型去模拟，即 BSSRDF。 当像素小于出射到入射距离时，每个点的着色就会收到其他光入射到其他点的影响，也就是常说的“次级表面散射”技术，很重要的一点是，它和普通的漫反射着色是一种物理现象（都是折射光的次级表面散射），唯一不同的就是散射的距离与观察点大小的关系，一个通常被认为是“次级表面散射”的表现，当在较远的距离观察时，就可以被认为是漫反射着色（例如远距离角色的皮肤），而“正规的漫反射着色”在很近距离观察时，也会有次级表面散射的效果。 ","date":"2021-12-07 13:39:26","objectID":"/pbr%E7%AC%94%E8%AE%B0/:0:8","tags":["shader","笔记"],"title":"PBR笔记","uri":"/pbr%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"微平面理论(Microfacet Theory) 上面描述的反射和散射都依赖于表面的朝向。放大来看，这被用来渲染网格的形状，也可以使用法线贴图来描述更小的细节。这样任何渲染系统都可以处理更多的细节，把反射和散射表现得更好。 然而，任然有一点没有考虑到。大多数真实世界的表面都存在非常小的缺口：凹槽、裂缝、凸块，这些都因为太小了以至于眼睛无法看到，并且使用正常解析度的法线贴图都无法表现出来。尽管无法被肉眼看到，但这些微粒还是影响着反射和折射。 为表面细节最容易在反射中被观察到（散射并不会被太多的影响到，这里不会讨论到）。上图中，入射光的平行线当从粗糙的表面反射是发生了交叉，因为每一条射线遇到的表面方向都不一样。就像将球抛向墙面一样，如果墙面非常不平整，球任然会反弹，但是反弹方向是不可预测的。简而言之，表面越粗糙，越多的反射光线会产生交叉，看上去越“模糊”。 不幸的是，为了着色而评估每一个微表面特征对美术、内存、计算量来说都是非常昂贵的操作。我们该怎么做呢？事实证明，如果我们放弃直接描述微表面，取而代之使用整体的粗糙度，就可以写出相当精确的着色器来产生类似的效果。这个值通常指的是光泽度（Gloss），平滑度（Smoothness）或者粗糙度（Roughness）。可以从纹理或者一个常量值中获取。 这种微表面细节对于任何材质来说都是非常重要的，因为真实世界到处都是各种各样的微表面特征。光泽贴图并不是一个新的盖面，但是它在基于物理的渲染中起到了关键的作用，因为微表面细节对光反射有着很大的影响。就如我们一会儿会看到的，有几个关于微表面属性基于物理渲染改善的注意事项。 将物体表面建模成无数微观尺度上有随机朝向的理想镜面反射的微表面(microfacet) 实际 PBR 工作流中, 微平面通过粗糙度贴图或高光贴图来表示 微观尺度上, 表面越粗糙反射越模糊, 越光滑反射越集中 到达微观尺度后任何平面都可以用称为微平面的细小镜面来进行描绘 用统计学的方法估算微平面粗糙程度 半角向量(Halfway Vector): 位于光线向量 l 和视线向量 v 之间的中间向量 h=normalize(lightDir+viewDir); 用基于一个平面的粗糙度(Roughness)来计算出半程向量的方向与微平面平均取向方向一致的概率 微平面的取向方向与半程向量的方向越是一致，镜面反射的效果就越是强烈越是锐利。然后再加上一个介于0到1之间的粗糙度参数(Roughness)，这样我们就能概略的估算微平面的取向情况了： 我们可以看到，较高的粗糙度值显示出来的镜面反射的轮廓要更大一些。与之相反地，较小的粗糙值显示出的镜面反射轮廓则更小更锐利。 ","date":"2021-12-07 13:39:26","objectID":"/pbr%E7%AC%94%E8%AE%B0/:0:9","tags":["shader","笔记"],"title":"PBR笔记","uri":"/pbr%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"Surface Reflectance 前文已经提到了微几何体，之所以有微平面的概念，因为从宏观来看，在我们渲染模型网格时，使用法线贴图就可以描述表面小的细节，但这样仍然会有一定的缺失，很多真实世界的平面上，还是有一些微小的凹陷，裂缝或突起，而用肉眼是很难看清楚的，小到连正常大小的法线贴图也无法来表现，虽然肉眼无法看到，但这些微观特征，还是对Diffuse和Specular产生了影响。 微平面的细节，对反射的影响更多，也就是Specular，因为粗糙的微平面会把反射光分散或者内部遮挡，所以有了下面两个项目来描述这个现象: Normal Distribution Function(法线分布函数) 因为微几何体的所有平面的方向，并不是均匀分布的，如果是分布比较均匀的光滑平面，那么光就会在几乎相同的方向反射，产生清晰的高光，如果粗糙表面则是模糊的高光. 有多少微平面点的法线更倾向宏观平面的法线方向，我们把这种平面法线方向分布的统计，称之为microgeometry normal distribution function D()，和fresenl方程不同的是，D() 并没有一个类似0~1的范围，而是来帮助确定微平面法线在某一个给定方向上的集中度。 所以，D()决定了高光的镜面反射高光的大小，亮度和形状，一些D()会提供前面提到的类似”Roughness(粗糙度)”的参数（也可以是glossiness），当粗糙度降低时，微几何体平面的法线方向就会更集中在宏观的平面法线方向上，D()的值也会变高。除了指定粗糙度参数外，也可以通过传递一张Glossn map的方式提供更高的细节。 Geometry Function(几何函数) shadowing现象 因为微几何体的构造缘故，一些入射光的平面点被内部遮挡，成为了内部阴影而无法接受光照（也就不能反射光）。 masking现象 而有一些反射光被内部遮挡，他们的反射光无法被观察到，虽然有反射光可以多次反弹后再被视点观察到，但在微平面理论里可以忽略不计了。 正因为有这种现象，所以需要有一个Geometry Function G()，来代表反射光的可见度，所以G()是在0~1之间的一个范围值，在着色模型里，有时会和其他参数合并称为V()（Visiblity）。和D()一样，因为微平面有凹凸感，当它的粗糙度提高时，shadow和masking的现象也会增加，粗糙度高的平面会光滑平面更阴暗一些，G()也要收到roughness参数的影响。另外G()也是下面要讲的能量守恒的一个基础，它使得反射光不会高于平面的入射光。 ","date":"2021-12-07 13:39:26","objectID":"/pbr%E7%AC%94%E8%AE%B0/:0:10","tags":["shader","笔记"],"title":"PBR笔记","uri":"/pbr%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"能量守恒 PBR是如何实现近似的能量守恒呢？ 为了回答这个问题，先弄清楚镜面反射（specular）和漫反射（diffuse）的区别。 一束光照到材质表面上，通常会分成反射（reflection）部分和折射（refraction）部分。反射部分直接从表面反射出去，而不进入物体内部，由此产生了镜面反射光。折射部分会进入物体内部，被吸收或者散射产生漫反射。 折射进物体内部的光如果没有被立即吸收，将会持续前进，与物体内部的微粒产生碰撞，每次碰撞有一部分能量损耗转化成热能，直至光线能量全部消耗。有些折射光线在跟微粒发生若干次碰撞之后，从物体表面射出，便会形成漫反射光。 照射在平面的光被分成镜面反射和折射光，折射光在跟物体微粒发生若干次碰撞之后，有可能发射出表面，成为漫反射。 通常情况下，PBR会简化折射光，将平面上所有折射光都视为被完全吸收而不会散开。而有一些被称为 次表面散射(Subsurface Scattering) 技术的着色器技术会计算折射光散开后的模拟，它们可以显著提升一些材质（如皮肤、大理石或蜡质）的视觉效果，不过性能也会随着下降。 金属(Metallic)材质会立即吸收所有折射光，故而金属只有镜面反射，而没有折射光引起的漫反射。 回到能量守恒话题。反射光与折射光它们二者之间是互斥的，被表面反射出去的光无法再被材质吸收。故而，进入材质内部的折射光就是入射光减去反射光后余下的能量。 根据上面的能量守恒关系，可以先计算镜面反射部分，此部分等于入射光线被反射的能量所占的百分比。而折射部分可以由镜面反射部分计算得出。 float kS = calculateSpecularComponent(...); // 反射/镜面 部分 float kD = 1.0 - ks; // 折射/漫反射 部分 通过以上代码可以看出，镜面反射部分与漫反射部分的和肯定不会超过1.0，从而近似达到能量守恒的目的。 ","date":"2021-12-07 13:39:26","objectID":"/pbr%E7%AC%94%E8%AE%B0/:0:11","tags":["shader","笔记"],"title":"PBR笔记","uri":"/pbr%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"反射方程（Reflectance Equation） ( 渲染方程 ) 渲染方程(Render Equation)是用来模拟光的视觉效果最好的模型。而PBR的渲染方程是用以抽象地描述PBR光照计算过程的特化版本的渲染方程，被称为反射方程。 PBR的反射方程可抽象成下面的形式： 参数说明： fr ( p , ωi , ω0 ) ： 双向反射分布函数(BRDF) Li ( p , ωi ) : 灯光颜色*灯光强度（radiance=lightColor*attenuation） n⋅ωi : dot(N,L) ωi : 光源方向（L） ω0 : 视线方向（V） p : 当前点（或者是任意一个点 n : 法线(N) 反射方程计算了点𝑝在所有视线方向𝜔0上被反射出来的辐射率𝐿0(𝑝,𝜔0)的总和。换言之：𝐿0计算的是在𝜔i方向的眼睛观察到的𝑝点的总辐照度。 反射方程看似很复杂，但如果拆分各个部分加以解析，就可以揭开其神秘的面纱。 为了更好地理解反射方程，先了解辐射度量学(Radiometry)。辐射度量学是一种用来度量电磁场辐射（包括可见光）的手段。有很多种辐射度量(radiometric quantities)可以用来测量曲面或者某个方向上的光，此处只讨论和反射方程有关的一种量，它就是辐射率(Radiance)，用𝐿来表示。 先用一个表展示辐射度量学涉及的概念、名词、公式等信息，后面会更加详细地介绍。 辐射通量(Radiant Flux)：辐射通量Φ表示的是一个光源所输出的能量，以瓦特为单位。 立体角(Solid Angle)：立体角用ω表示，它可以为我们描述投射到单位球体上的一个截面的大小或者面积。投射到这个单位球体上的截面的面积就被称为立体角(Solid Angle)，你可以把立体角想象成为一个带有体积的方向： 可以把自己想象成为一个站在单位球面的中心的观察者，向着投影的方向看。这个投影轮廓的大小就是立体角。 辐射强度(Radiant Intensity)：辐射强度(Radiant Intensity)表示的是在单位球面上，一个光源向每单位立体角所投送的辐射通量。举例来说，假设一个全向光源向所有方向均匀的辐射能量，辐射强度就能帮我们计算出它在一个单位面积（立体角）内的能量大小： 计算辐射强度的公式如下所示： (其中I表示辐射通量Φ除以立体角ω)。 在理解了辐射通量，辐射强度与立体角的概念之后，我们终于可以开始讨论辐射率的方程式了。这个方程表示的是，一个拥有辐射强度Φ的光源在单位面积A，单位立体角ω上的辐射出的总能量： 辐射率：是辐射度量学上表示一个区域平面上光线总量的物理量，它受到入射(Incident)（或者来射）光线与平面法线间的夹角θ的余弦值cosθ的影响：当直接辐射到平面上的程度越低时，光线就越弱，而当光线完全垂直于平面时强度最高。cosθ就直接对应于光线的方向向量和平面法向量的点积： float cosTheta = dot(lightDir, N); 辐射率方程很有用，因为它把大部分我们感兴趣的物理量都包含了进去。如果我们把立体角ω和面积A看作是无穷小的，那么我们就能用辐射率来表示单束光线穿过空间中的一个点的通量。这就使我们可以计算得出作用于单个（片段）点上的单束光线的辐射率，我们实际上把立体角ω转变为方向向量ω然后把面A转换为点p。这样我们就能直接在我们的着色器中使用辐射率来计算单束光线对每个片段的作用了。 事实上，当涉及到辐射率时，我们通常关心的是所有投射到点p上的光线的总和，而这个和就称为辐射照度或者辐照度(Irradiance)。在理解了辐射率和辐照度的概念之后，让我们再回过头来看看反射率方程： 我们知道在渲染方程中L代表通过某个无限小的立体角ωi在某个点p的辐射率，而立体角可以视作是入射光方向向量ωi。将用来衡量入射光与平面法线夹角对能量的影响的cos𝜃分量移出辐射率方程，作为反射方程的单独项𝑛⋅𝜔i 。 反射方程计算了点𝑝在所有视线方向𝜔0上被反射出来的辐射率𝐿0(𝑝,𝜔0)的总和。换言之：𝐿0计算的是在𝜔i方向的眼睛观察到的𝑝点的总辐照度。 反射方程里面使用的辐照度，必须要包含所有以𝑝点为中心的半球Ω内的入射光，而不单单只是某一个方向的入射光。这个半球指的是围绕面法线𝑛的那一个半球： 笔者注：为什么只计算半球而不计算整个球体呢？ 因为另外一边的半球因与视线方向相反，不能被观察，也就是辐射通量贡献量为0，所以被忽略。 为了计算这个区域（半球）内的所有值，在反射方程中使用了一个称作为积分的数学符号 ∫，来计算半球 Ω 内所有的入射向量𝑑𝜔i。 积分计算面积的方法，有解析(analytically)和渐近(numerically)两种方法。目前尚没有可以满足渲染计算的解析法，所以只能选择离散渐近法来解决这个积分问题。 具体做法是在半球Ω按一定的步长将反射方程离散地求解，然后再按照步长大小将所得到的结果平均化，这种方法被称为黎曼和(Riemann sum)。 至此，反射方程中，只剩下𝑓𝑟项未描述。𝑓r就是双向反射分布函数(Bidirectional Reflectance Distribution Function, BRDF)，它的作用是基于表面材质属性来对入射辐射度进行缩放或者加权。 ","date":"2021-12-07 13:39:26","objectID":"/pbr%E7%AC%94%E8%AE%B0/:0:12","tags":["shader","笔记"],"title":"PBR笔记","uri":"/pbr%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"什么是BRDF 双向反射分布函数(Bidirectional Reflectance Distribution Function,BRDF)是一个使用入射光方向𝜔i作为输入参数的函数，输出参数为出射光𝜔0，表面法线为𝑛，参数𝑎表示的是微平面的粗糙度。 更笼统地说，它描述了入射光线经过某个表面反射后如何在各个出射方向上分布这可以是从理想镜面反射到漫反射、各向同性或者各向异性的各种反射。 BRDF函数是近似的计算在一个给定了属性的不透明表面上每个单独的光线对最终的反射光的贡献量。假如表面是绝对光滑的（比如镜子），对于所有入射光𝜔i的BRDF函数都将会返回0.0，除非出射光线𝜔𝑜方向的角度跟入射光线𝜔i方向的角度以面法线为中轴线完全对称，则返回1.0。 ","date":"2021-12-07 13:39:26","objectID":"/pbr%E7%AC%94%E8%AE%B0/:0:13","tags":["shader","笔记"],"title":"PBR笔记","uri":"/pbr%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"怎么实现BRDF BRDF有好几种模拟表面光照的算法，然而，基本上所有的 实时渲染管线使用的都是Cook-Torrance BRDF。 Cook-Torrance BRDF分为 漫反射 和 镜面反射 两个部分： 其中𝑘𝑑是入射光中被折射的比例，𝑘𝑠是另外一部分被镜面反射的入射光。BRDF等式左边的𝑓𝑙𝑎𝑚𝑏𝑒𝑟𝑡表示的是漫反射部分，这部分叫做伦勃朗漫反射（Lambertian Diffuse）。它类似于我们之前的漫反射着色，是一个恒定的算式： 其中𝑐代表的是Albedo或表面颜色，类似漫反射表面纹理。除以𝜋是为了规格化漫反射光，为后期的BRDF积分做准备。 此处的伦勃朗漫反射跟以前用的漫反射之间的关系：以前的漫反射是用表面的漫反射颜色乘以法线与入射光方向的点积，这个点积依然存在，只不过是被移到了BRDF外面，写作𝑛⋅𝜔i，放在反射方程𝐿𝑜靠后的位置。 BRDF的高光（镜面反射）部分更复杂： Cook-Torrance镜面反射BRDF由3个函数（𝐷，𝐹，𝐺）和一个标准化因子构成。𝐷，𝐹，𝐺符号各自近似模拟了特定部分的表面反射属性： 𝐷(Normal Distribution Function，NDF)：法线分布函数，估算在受到表面粗糙度的影响下，取向方向与中间向量一致的微平面的数量。这是用来估算微平面的主要函数。 𝐹(Fresnel equation)：菲涅尔方程，描述的是在不同的表面角下表面反射的光线所占的比率。 𝐺(Geometry function)：几何函数，描述了微平面自成阴影的属性。当一个平面相对比较粗糙的时候，平面表面上的微平面有可能挡住其他的微平面从而减少表面所反射的光线。 以上的每一种函数都是用来估算相应的物理参数的，而且你会发现用来实现相应物理机制的每种函数都有不止一种形式。它们有的非常真实，有的则性能高效。你可以按照自己的需求任意选择自己想要的函数的实现方法。 Epic Games公司的Brian Karis对于这些函数的多种近似实现方式进行了大量的研究。这里将采用Epic Games在Unreal Engine 4中所使用的函数，其中𝐷使用Trowbridge-Reitz GGX，𝐹使用Fresnel-Schlick近似法(Approximation)，而𝐺使用Smith’s Schlick-GGX。 𝐷(Normal Distribution Function，NDF) 法线分布函数，从统计学上近似的表示了与某些（如中间）向量ℎ(半角向量)取向一致的微平面的比率。 目前有很多种NDF都可以从统计学上来估算微平面的总体取向度，只要给定一些粗糙度的参数以及一个我们马上将会要用到的参数Trowbridge-Reitz GGX（GGXTR）： 这里的ℎ是用来测量微平面的半角向量，𝛼是表面的粗糙度，𝑛是表面法线。 如果将ℎ放到表面法线和光线方向之间，并使用不同的粗糙度作为参数，可以得到下面的效果： 当粗糙度很低（表面很光滑）时，与中间向量ℎ取向一致的微平面会高度集中在一个很小的半径范围内。由于这种集中性，NDF最终会生成一个非常明亮的斑点。但是当表面比较粗糙的时候，微平面的取向方向会更加的随机，与向量ℎ取向一致的微平面分布在一个大得多的半径范围内，但是较低的集中性也会让最终效果显得更加灰暗。 Trowbridge-Reitz GGX的NDF实现代码： float DistributionGGX(vec3 N, vec3 H, float a) { float a2 = a*a; float NdotH = max(dot(N, H), 0.0); float NdotH2 = NdotH*NdotH; float nom = a2; float denom = (NdotH2 * (a2 - 1.0) + 1.0); denom = PI * denom * denom; return nom / denom; } 𝐹 (Fresnel equation) 菲涅尔方程定义的是在不同观察方向上，表面上被反射的光除以被折射的光的比例。在一束光击中了表面的一瞬间，菲涅尔根据表面与观察方向之间的夹角，计算得到光被反射的百分比。根据这个比例和能量守恒定律我们可以直接知道剩余的能量就是会被折射的能量。 当我们垂直观察每个表面或者材质时都有一个基础反射率，当我们以任意一个角度观察表面时所有的反射现象都会变得更明显（反射率高于基础反射率）。你可以从你身边的任意一件物体上观察到这个现象，当你以90度角观察你的桌子你会法线反射现象将会变得更加的明显，理论上以完美的90度观察任意材质的表面都应该会出现全反射现象（所有物体、材质都有菲涅尔现象）。 菲涅尔方程同样是个复杂的方程，但是幸运的是菲涅尔方程可以使用Fresnel-Schlick来近似： 𝐹0表示的是表面基础反射率，这个我们可以使用一种叫做Indices of refraction(IOR)的方法计算得到。运用在球面上的效果就是你看到的那样，观察方向越是接近掠射角（grazing angle，又叫切线角，与正视角相差90度），菲涅尔现象导致的反射就越强： 菲涅尔方程中有几个微妙的地方，一个是Fresnel-Schlick算法仅仅是为电介质（绝缘体）表面定义的算法。对于金属表面，使用电介质的折射率来计算基础反射率是不合适的，我们需要用别的菲涅尔方程来计算。对于这个问题，我们需要预先计算表面在正视角(即以0度角正视表面)下的反应（𝐹0），然后就可以跟之前的Fresnel-Schlick算法一样，根据观察角度来进行插值。这样我们就可以用一个方程同时计算金属和电介质了。 表面在正视角下的反映或者说基础反射率可以在这个数据库中找到，下面是Naty Hoffman的在SIGGRAPH公开课中列举的一些常见材质的值： 这里可以观察到的一个有趣的现象，所有电介质材质表面的基础反射率都不会高于0.17，这其实是例外而非普遍情况。导体材质表面的基础反射率起点更高一些并且（大多）在0.5和1.0之间变化。此外，对于导体或者金属表面而言基础反射率一般是带有色彩的，这也是为什么要用RGB三原色来表示的原因（法向入射的反射率可随波长不同而不同）。这种现象我们只能在金属表面观察的到。 金属表面这些和电介质表面相比所独有的特性引出了所谓的金属工作流的概念。也就是我们需要额外使用一个被称为金属度(Metalness)的参数来参与编写表面材质。金属度用来描述一个材质表面是金属还是非金属的。 通过预先计算电介质与导体的值，我们可以对两种类型的表面使用相同的Fresnel-Schlick近似，但是如果是金属表面的话就需要对基础反射率添加色彩。我们一般是按下面这个样子来实现的： vec3 F0 = vec3(0.04); F0 = mix(F0, surfaceColor.rgb, metalness); 我们为大多数电介质表面定义了一个近似的基础反射率。**𝐹0**取最常见的电解质表面的平均值，这又是一个近似值。不过对于大多数电介质表面而言使用0.04作为基础反射率已经足够好了，而且可以在不需要输入额外表面参数的情况下得到物理可信的结果。然后，基于金属表面特性，我们要么使用电介质的基础反射率要么就使用𝐹0作来为表面颜色。因为金属表面会吸收所有折射光线而没有漫反射，所以我们可以直接使用表面颜色纹理来作为它们的基础反射率。 Fresnel Schlick近似可以用GLSL代码实现： vec3 fresnelSchlick(float cosTheta, vec3 F0) { return F0 + (1.0 - F0) * pow(1.0 - dot(n, v), 5.0); } 𝐺 (Geometry function) 几何函数模拟微平面相互遮挡导致光线的能量减少或丢失的现象。 类似NDF，几何函数也使用粗糙度作为输入参数，更粗糙意味着微平面产生自阴影的概率更高。几何函数使用由GGX和Schlick-Beckmann组合而成的模拟函数Schlick-GGX： 这里的𝑘是使用粗糙度𝛼计算而来的，用于直接光照和IBL光照的几何函数的参数： 需要注意的是这里𝛼的值取决于你的引擎怎么将粗糙度转化成𝛼，在接下来的教程中我们将会进一步讨论如何和在什么地方进行这个转换。 为了有效地模拟几何体，我们需要同时考虑两个视角，视线方向（几何遮挡）跟光线方向（几何阴影），我们可以用Smith函数将两部分放到一起： 其中𝑣表示视线向量，𝐺𝑠𝑢𝑏(𝑛,𝑣,𝑘)表示视线方向的几何遮挡；𝑙表示光线向量，𝐺𝑠𝑢𝑏(𝑛,𝑙,𝑘)表示光线方向的几何阴影。使用Smith函数与Schlick-GGX作为𝐺𝑠𝑢𝑏可以得到如下所示不同粗糙度R的视觉效果： 几何函数是一个值域为[0.0, 1.0]的乘数，其中白色(1.0)表示没有微平面阴影，而黑色(0.0)则表示微平面彻底被遮蔽。 使用GLSL编写的几何函数代码如下： float GeometrySchlickGGX(float NdotV, float k) { float nom = NdotV; float denom = NdotV * (1.0 - k) + k; return nom / denom; } float GeometrySmith(vec3 N, vec3 V, vec3 L, float k) { float NdotV = max(dot(N, V), 0.0); float NdotL = max(dot(N, L), 0.0); float ggx1 = GeometrySchlickGGX(NdotV","date":"2021-12-07 13:39:26","objectID":"/pbr%E7%AC%94%E8%AE%B0/:0:14","tags":["shader","笔记"],"title":"PBR笔记","uri":"/pbr%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"PBR参数 反射率（Albedo）：反射率纹理指定了材质表面每个像素的颜色，如果材质是金属那纹理包含的就是基础反射率。这个跟我们之前用过的漫反射纹理非常的类似，但是不包含任何光照信息。漫反射纹理通常会有轻微的阴影和较暗的裂缝，这些在Albedo贴图里面都不应该出现，仅仅只包含材质的颜色（金属材质是基础反射率）。 法线（Normal）：法线纹理跟我们之前使用的是完全一样的。法线贴图可以逐像素指定表面法线，让平坦的表面也能渲染出凹凸不平的视觉效果。 金属度（Metallic）：金属度贴图逐像素的指定表面是金属还是电介质。根据PBR引擎各自的设定，金属程度即可以是[0.0，1.0]区间的浮点值也可以是非0即1的布尔值。 粗糙度（Roughness）：粗糙度贴图逐像素的指定了表面有多粗糙，粗糙度的值影响了材质表面的微平面的平均朝向，粗糙的表面上反射效果更大更模糊，光滑的表面更亮更清晰。有些PBR引擎用光滑度贴图替代粗糙度贴图，因为他们觉得光滑度贴图更直观，将采样出来的光滑度使用（1-光滑度）= 粗糙度 就能转换成粗糙度了。 环境光遮挡（Ambient Occlusion，AO）：AO贴图为材质表面和几何体周边可能的位置，提供了额外的阴影效果。比如有一面砖墙，在两块砖之间的缝隙里Albedo贴图包含的应该是没有阴影的颜色信息，而让AO贴图来指定这一块需要更暗一些，这个地方光线更难照射到。AO贴图在光照计算的最后一步使用可以显著的提高渲染效果，模型或者材质的AO贴图一般是在建模阶段手动生成的。 ","date":"2021-12-07 13:39:26","objectID":"/pbr%E7%AC%94%E8%AE%B0/:0:15","tags":["shader","笔记"],"title":"PBR笔记","uri":"/pbr%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"PBR的光照实现 上面阐述了Cook-Torrance反射方程的理论和公式意义。这节将探讨如何将前面讲到的理论转化成一个基于直接光照的渲染器：比如点光源，方向光和聚光灯。 辐照度计算 上面解释了Cook-Torrance反射方程的大部分含义，但有一点未提及：具体要怎么处理场景中的辐照度（Irradiance，也就是辐射的总能量𝐿）？在计算机领域，场景的辐射率𝐿度量的是来自光源光线的辐射通量𝜙穿过指定的立体角𝜔，在这里我们假设立体角𝜔无限小，小到辐射度衡量的是光源射出的一束经过指定方向向量的光线的通量。 有了这个假设，我们又要怎么将之融合到之前教程讲的光照计算里去呢？想象我们有一个辐射通量以RGB表示为（23.47, 21.31, 20.79）的点光源，这个光源的辐射强度等于辐射通量除以所有出射方向。当为平面上某个特定的点𝑝着色的时候，所有可能的入射光方向都会经过半球Ω，但只有一个入射方向𝜔i是直接来自点光源的，又因为我们的场景中只包含有一个光源，且这个光源只是一个点，所以𝑝点所有其它的入射光方向的辐射率都应该是0. 如果我们暂时不考虑点光源的距离衰减问题，且无论光源放在什么地方入射光线的辐射率都一样大（忽略入射光角度cos𝜃对辐射度的影响），又因为点光源朝各个方向的辐射强度都是一样的，那么有效的辐射强度就跟辐射通量完全一样：恒定值（23.47, 21.31, 20.79）。 然而，辐射率需要使用位置𝑝作为输入参数，因为现实中的灯光根据点𝑝和光源之间距离的不同，辐射强度多少都会有一定的衰减。另外，从原始的辐射方程中我们可以发现，面法线𝑛于入射光方向向量𝜔i的点积也会影响结果。 用更精炼的话来描述：在点光源直接光照的情况里，辐射率函数𝐿计算的是灯光颜色，经过到𝑝点距离的衰减之后，再经过𝑛⋅𝜔i缩放。能击中点𝑝的光线方向𝜔i就是从𝑝点看向光源的方向。把这些写成代码： vec3 lightColor = vec3(23.47, 21.31, 20.79); vec3 wi = normalize(lightPos - fragPos); float cosTheta = max(dot(N, Wi), 0.0); // 计算光源在点fragPos的衰减系数 float attenuation = calculateAttenuation(fragPos, lightPos); // 英文原版的radiance类型有误，将它改成了vec3 vec3 radiance = lightColor * (attenuation * cosTheta); 你应该非常非常熟悉这段代码：这就是以前我们计算漫反射光的算法！在只有单光源直接光照的情况下，辐射率的计算方法跟我们以前的光照算法是类似的。 要注意我们这里假设点光源无限小，只是空间中的一个点。如果我们使用有体积的光源模型，那么就有很多的入射光方向的辐射率是非0的。 对那些基于点的其他类型光源我们可以用类似的方法计算辐射率，比如平行光源的入射角的恒定的且没有衰减因子，聚光灯没有一个固定的辐射强度，而是围绕一个正前方向量来进行缩放的。 这也将我们带回了在表面半球Ω的积分∫。我们知道，多个单一位置的光源对同一个表面的同一个点进行光照着色并不需要用到积分，我们可以直接拿出这些数目已知的光源来，分别计算这些光源的辐照度后再加到一起，毕竟每个光源只有一束方向光能影响物体表面的辐射率。这样只需要通过相对简单的循环计算每个光源的贡献就能完成整个PBR光照计算。当我们需要使用IBL将环境光加入计算的时候我们才会需要用到积分，因为环境光可能来自任何方向。 PBR直接光照(Direct lighting) 示例代码LearnOpenGL的网站:lighting ","date":"2021-12-07 13:39:26","objectID":"/pbr%E7%AC%94%E8%AE%B0/:0:16","tags":["shader","笔记"],"title":"PBR笔记","uri":"/pbr%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"基于图像的光照（Image Based Lighting, IBL） 基于图像的光照（IBL）是对光源物体的技巧集合，与直接光照不同，它将周围环境当成一个大光源。IBL通常结合cubemap环境贴图，cubemap通常采集自真实的照片或从3D场景生成，这样可以将其用于光照方程：将cubemap的每个像素当成一个光源。这样可以更有效地捕获全局光照和常规感观，使得被渲染的物体更好地融入所处的环境中。 当基于图像的光照算法获得一些（全局的）环境光照时，它的输入被当成更加精密形式的环境光照，甚至是一种粗糙的全局光照的模拟。这使得IBL有助于PBR的渲染，使得物体渲染效果更真实。 在介绍IBL结合PBR之前，先回顾一下反射方程： 如之前所述，我们的主目标是解决所有入射光𝑤𝑖通过半球Ω的积分∫。与直接光照不同的是，在IBL中，每一个来自周围环境的入射光𝜔𝑖都可能存在辐射，这些辐射对解决积分有着重要的作用。为解决积分有两个要求： 需要用某种方法获得给定任意方向向量𝜔i的场景辐射。 解决积分需尽可能快并实时。 对第一个要求，相对简单，采用环境cubemap。给定一个cubemap，可以假设它的每个像素是一个单独的发光光源。通过任意方向向量𝜔𝑖采样cubemap，可以获得场景在这个方向的辐射。 获取任意方向向量𝜔𝑖的场景辐射很简单，如下： vec3 radiance = texture(_cubemapEnvironment, w_i).rgb; 对要求二，解决积分能只考虑一个方向的辐射，要考虑环境贴图的半球Ω的所有可能的方向𝜔i，但常规积分方法在片元着色器中开销非常大。为了有效解决积分问题，可采用预计算或预处理的方法。因此，需要深究一下反射方程： 可将上述的𝑘𝑑和𝑘𝑠项拆分： 拆分后，可分开处理漫反射和镜面反射的积分。先从漫反射积分开始。 间接光的漫反射IBL（Indirect Diffuse IBL） 仔细分析上面方程的漫反射积分部分，发现Lambert漫反射是个常量项（颜色𝑐，折射因子𝑘𝑑和𝜋）并且不依赖积分变量。因此，可见常量部分移出漫反射积分： 因此，积分只依赖𝜔i（假设𝑝在环境贴图的中心）。据此，可以计算或预计算出一个新的cubemap，这个cubemap存储了用卷积（convolution）计算出的每个采样方向（或像素）𝜔𝑜的漫反射积分结果。 卷积（convolution）是对数据集的每个入口应用一些计算，假设其它所有的入口都在这个数据集里。此处的数据集就是场景辐射或环境图。因此，对cubemap的每个采样方向，我们可以顾及在半球Ω的其它所有的采样方向。 为了卷积环境图，我们要解决每个输出𝜔𝑜采样方向的积分，通过离散地采样大量的在半球Ω的方向𝜔i并取它们辐射的平均值。采样方向𝜔i的半球是以点𝑝为中心以𝜔𝑜为法平面的。 这个预计算的为每个采样方向𝜔𝑜存储了积分结果的cubemap，可被当成是预计算的在场景中所有的击中平行于𝜔𝑜表面的非直接漫反射的光照之和。这种cubemap被称为 辐照度图（Irradiance map）。 辐射方程依赖于位置𝑝，假设它在辐照度图的中心。这意味着所有非直接漫反射光需来自于同一个环境图，它可能打破真实的幻觉（特别是室内）。渲染引擎用放置遍布场景的反射探头（reflection probe）来解决，每个反射探头计算其所处环境的独自的辐照度图。这样，点p的辐射率（和辐射）是与其最近的反射探头的辐照度插值。这里我们假设总是在环境图的中心采样。反射探头将在其它章节探讨。 下面是cubemap环境图(下图左）和对应的辐照度图（下图右）： 通过存储每个cubemap像素卷积的结果，辐照度图有点像环境的平均颜色或光照显示。从这个环境图采样任意方向，可获得这个方向的场景辐照度。 辐射度图提供了漫反射部分的积分，该积分表示来自非直接的所有方向的环境光辐射之和。由于辐射度图被当成是无方向性的光源，所以可以将漫反射镜面反射合成环境光。 在之前所述的反射方程中，非直接光依旧包含了漫反射和镜面反射两个部分，所以我们需要加个权重给漫反射。依旧使用菲涅尔方程来计算漫反射因子： vec3 kS = fresnelSchlick(max(dot(N, V), 0.0), F0); vec3 kD = 1.0 - kS; vec3 irradiance = texture(ambientCubeMap, N).rgb; vec3 diffuse = irradiance * albedo; vec3 ambient = (kD * diffuse) * ao; 由于环境光来自在半球内所有围绕着法线N的方向，没有单一的半向量去决定菲涅尔因子。为了仍然能模拟菲涅尔，这里采用了法线和视线的夹角。之前的算法采用了受表面粗糙度影响的微平面半向量，作为菲涅尔方程的输入。这里，我们并不考虑粗糙度，表面的反射因子被视作相当大。 非直接光照将沿用直接光照的相同的属性，所以，期望越粗糙的表面镜面反射越少。由于不考虑表面粗糙度，非直接光照的菲涅尔方程强度被视作粗糙的非金属表面（下图）。 为了缓解这个问题，可在Fresnel-Schlick方程注入粗糙度项（该方程的来源）： vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) { return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0); } 考虑了表面粗糙度后，菲涅尔相关计算最终如下： vec3 kS = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness); vec3 kD = 1.0 - kS; vec3 irradiance = texture(ambientCubeMap, N).rgb; vec3 diffuse = irradiance * albedo; vec3 ambient = (kD * diffuse) * ao; 如上所述，实际上，基于图片的光照计算非常简单，只需要单一的cubemap纹理采样。大多数的工作在于预计算或卷积环境图到辐射度图。 加入了IBL的渲染效果如下（竖向是金属度增加，水平是粗糙度增加）： 间接光的镜面反射IBL（Indirect Specular IBL） 上面描述的是IBL的漫反射部分，本节将讨论IBL的镜面反射部分先回顾一下反射方程： 上述的镜面反射部分（被𝑘𝑠相乘）不是恒定的，并且依赖于入射光方向和视线入射方向，尝试实时地计算所有入射光和所有入射视线的积分是几乎不可能的。Epic Games推荐折中地使用预卷积镜面反射部分的方法来解决实时渲染的性能问题，这就是分裂和近似法（split sum approximation）。 分裂和近似法将镜面反射部分从反射方程分离出两个部分，这样可以单独地对它们卷积，后面在PBR的shader中为镜面的非直接IBL将它们结合起来。跟预卷积辐射度图类似，分裂和近似法需要HDR环境图作为输入。为了更好地理解分裂和近似法，下面着重关注反射方程的镜面部分： 出于跟辐射度图相同的性能问题的考虑，我们要预计算类似镜面IBL图的积分，并且用片元的法线采样这个图。辐射度图的预计算只依赖于𝜔i，并且我们可以将漫反射项移出积分。但这次从BRDF可以看出，不仅仅是依赖于𝜔i： 如上方程所示，还依赖𝜔𝑜，并且我们不能用两个方向向量来采样预计算的cubemap。预计算所有𝜔i和𝜔𝑜的组合在实时渲染环境中不实际的。 Epic Games的分裂和近似法将镜面反射部分从反射方程分离出两个部分，这样可以单独地对它们卷积，后面在PBR的shader中为镜面的非直接IBL将它们结合起来。分离后的方程如下： 第一部分是预过滤环境图（pre-filtered environment map），类似于辐射度图的预计算环境卷积图，但会加入粗糙度。随着粗糙度等级的增加，环境图使用更多的散射采样向量来卷积，创建出更模糊的反射。 对每个卷积的粗糙度等级，循环地在预过滤环境图的mimap等级存储更加模糊的结果。下图是5个不同粗糙度等级的预过滤环境图： 生成采样向量和它们的散射强度，需要用到Cook-Torrance BRDF的法线分布图（NDF），而其带了两个输入：法线和视线向量。当卷积环境图时并不知道视线向量，Epic Games用了更近一步的模拟法：假设视线向量（亦即镜面反射向量）总是等于输出采样向量𝜔𝑜。所以代码变成如下所示： vec3 N = normalize(w_o); vec3 R = N; vec3 V = R; 这种方式预过滤环境图卷积不需要关心视线方向。这就意味着当从某个角度看向下面这张图的镜面表面反射时，无法获得很好的掠射镜面反射（grazing specular reflections）。然而通常这被认为是一个较好的妥协： 第二部分 是镜面积分。假设所有方向的入射辐射率是全白的（那样𝐿(𝑝,𝑥)=1.0），那就可以用给定的粗糙度和一个法线𝑛和光源方向𝜔i之间的角度或𝑛⋅𝜔i来预计算BRDF的值。Epic Games存储了用变化的粗糙度来预计算每一个法线和光源方向组合的BRDF的值，该粗糙度存储于2D采样纹理（LUT）中，它被称为BRDF积分图（BRDF integration map）。 2D采样纹理输出一个缩放（红色）和一个偏移值（绿色）给表面的菲涅尔方程式（Fresnel response），以便提供第二部分的镜面积分： 上图","date":"2021-12-07 13:39:26","objectID":"/pbr%E7%AC%94%E8%AE%B0/:0:17","tags":["shader","笔记"],"title":"PBR笔记","uri":"/pbr%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"PBR的两种工作流程 基础参数说明： Albedo 可以理解为物体的基础色Base Color,即该物体本身颜色，也是漫反射光的颜色。 其实该颜是色光的折射被物质吸收并形成漫反射后，成为不同波长的光，这就赋予了物体颜色。比如说物体呈现蓝色，是因为其把除了蓝色的光都吸收了，散射出来的光的波长是在蓝色所在范围内。 Metallic 即金属度，表示了反射时发生镜面反射和漫反射的光线的占比。 Metallic度越大，发生镜面反射的占比越大，漫反射diffuse占比越小，一般金属物体的金属度比较大：70% ~ 100%之间； Metallic越小，发生镜面反射的占比越小，漫反射diffuse占比越大，一般非金属物质金属度比较小；2% ~ 5%之间，宝石的大概8%； 金属是没有漫反射的，折射进表面的光照全部被吸收。但是一些腐蚀性的金属，其腐蚀的部分具有漫反射。 Specular 这个没什么好说的，就是镜面反射，对于非金属物质，其镜面反射的sRBG范围在40 ~ 75；对于金属物质，其sRGB范围在155 ~ 255 其也是表示0度时的菲涅尔系数RF（0°）。 Roughness 即粗糙度，其与Smoothness（光滑度，也称为Glossiness光泽度）相反。其表示了物体表面的不规则程度，决定了在发生镜面反射时入射光线与法线的夹角大小。 粗糙度roughness越大，镜面反射的出射光线分散的角度就越大，光照越模糊； 粗糙度roughness越小，镜面反射的出射光线分散的角度就越小，光照越尖锐； 在真实的生活中，视觉效果的呈现，主要取决于： 自然光照下，物体呈现的颜色（BasedColor/Albedo）； 物体表面对光线的镜面反射角度(Roughness)； 物体表面对光线镜面反射和漫反射的比例(Metallic/Specular)； Metal-Roughness（金属工作流） UE4使用该工作流 在Metal-Rougnness流程中，分别对应BaseColor，Roughness，Metallic这三个参数； 在Metal-Roughness流程中，只要按照流程，分别设置好BaseColor，Roughness，Metallic，就可以基本确定物体材质的视觉效果； Specular-Glossiness（高光工作流） Unity使用该工作流 在Specular-Glossiness流程中，参数发生了变化，分别为Diffuse，Glossiness，Specular三个参数； 在Specular-Glossiness流程中，Diffuse和Specular共同决定了物体的basecolor，和表面镜面反射和漫反射的比例，与第一种流程的区别在于，此流程直接指定确定的占比值，第一种是根据Metallic属性，自动匹配相应的占比值； ","date":"2021-12-07 13:39:26","objectID":"/pbr%E7%AC%94%E8%AE%B0/:0:18","tags":["shader","笔记"],"title":"PBR笔记","uri":"/pbr%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"两个流程的区别 共同点 都需要使用AO、Normal、Height纹理。 不同点 Metal/Roughness工作流程使用：Base Color、Roughness、Metallic三种纹理来作为基础纹理（最常用的工作流）。 Specular/Glossiness工作流程使用：Diffuse Map、Glossiness、Specular三种纹理来作为基础纹理。 参考： PBR原理 由浅入深学习PBR的原理和实现 LearnOpenGL:PBR理论 LearnOpenGL:PBR Lighting ","date":"2021-12-07 13:39:26","objectID":"/pbr%E7%AC%94%E8%AE%B0/:0:19","tags":["shader","笔记"],"title":"PBR笔记","uri":"/pbr%E7%AC%94%E8%AE%B0/"},{"categories":[],"content":"Bloom实现分为4步： 提取亮度阈值 降采样 升采样 合并 Bloom.shader Shader \"Hidden/Bloom\" { Properties { _MainTex(\"Texture\", 2D) = \"white\" {} _BlurOffset(\"BlurOffset\",Float) = 1 } CGINCLUDE #include \"UnityCG.cginc\" sampler2D _MainTex; sampler2D _BloomTex; float4 _MainTex_TexelSize; float _Threshold; float _Intensity; float _BlurRadius; //阈值 half4 frag_PreFilter(v2f_img i) : SV_Target { //提取阈值 half4 d = _MainTex_TexelSize.xyxy * half4(-1,-1,1,1)* _BlurRadius; half4 color = 0; color += tex2D(_MainTex, i.uv); float br = max(max(color.r, color.g), color.b); br = max(0.0f, (br - _Threshold)) / max(br,0.00001f); //降采样 color = 0; color += tex2D(_MainTex, i.uv + d.xy); color += tex2D(_MainTex, i.uv + d.zy); color += tex2D(_MainTex, i.uv + d.xw); color += tex2D(_MainTex, i.uv + d.zw); color *= 0.25; color.rgb *= br; return color; } //降采样模糊,BoxBlur half4 frag_DownsampleBox(v2f_img i) : SV_Target { half4 d = _MainTex_TexelSize.xyxy * half4(-1,-1,1,1)* _BlurRadius; half4 s = 0; s += tex2D(_MainTex, i.uv + d.xy); s += tex2D(_MainTex, i.uv + d.zy); s += tex2D(_MainTex, i.uv + d.xw); s += tex2D(_MainTex, i.uv + d.zw); s *= 0.25; return s; } //升采样模糊,BoxBlur half4 frag_UpsampleBox(v2f_img i) : SV_Target { half4 d = _MainTex_TexelSize.xyxy * half4(-1,-1,1,1)* _BlurRadius; half4 color = 0; color += tex2D(_MainTex, i.uv + d.xy); color += tex2D(_MainTex, i.uv + d.zy); color += tex2D(_MainTex, i.uv + d.xw); color += tex2D(_MainTex, i.uv + d.zw); color *= 0.25; half4 color2 = tex2D(_BloomTex, i.uv); return color + color2; } //合并 half4 frag_Combine(v2f_img i) : SV_Target { half4 base_color = tex2D(_MainTex, i.uv); half4 bloom_color = tex2D(_BloomTex, i.uv); half3 final_color = base_color.rgb + bloom_color.rgb * _Intensity; return half4(final_color,1.0); } ENDCG SubShader { Cull Off ZWrite Off ZTest Always //0 阈值 Pass { CGPROGRAM #pragma vertex vert_img #pragma fragment frag_PreFilter ENDCG } //1 降采样模糊 Pass { CGPROGRAM #pragma vertex vert_img #pragma fragment frag_DownsampleBox ENDCG } //2 升采样模糊 Pass { CGPROGRAM #pragma vertex vert_img #pragma fragment frag_UpsampleBox ENDCG } //3 合并 Pass { CGPROGRAM #pragma vertex vert_img #pragma fragment frag_Combine ENDCG } } } Bloom.cs using System.Collections; using System.Collections.Generic; using UnityEngine; [ExecuteInEditMode()] [RequireComponent(typeof(Camera))] public class Bloom : MonoBehaviour { public Shader shader; private Material material; [Range(0, 10)] public float _Intensity = 1; [Range(0, 10)] public float _Threshold = 1; [Range(0, 5)] public float _BlurRadius = 1.0f; [Range(0, 9)] public int _Iteration = 4; private List\u003cRenderTexture\u003e ls; private void Awake() { if (shader == null) { shader = Shader.Find(\"Hidden/Bloom\"); } } void OnEnable() { if (shader == null || shader.isSupported == false) { enabled = false; return; } if (material == null) { material = new Material(shader); } if (ls == null) { ls = new List\u003cRenderTexture\u003e(_Iteration); } } const RenderTextureFormat format= RenderTextureFormat.DefaultHDR; void OnRenderImage(RenderTexture source, RenderTexture destination) { float intensity = Mathf.Exp(_Intensity / 10.0f * 0.693f) - 1.0f; material.SetFloat(\"_Intensity\", intensity); material.SetFloat(\"_Threshold\", _Threshold); material.SetFloat(\"_BlurRadius\", _BlurRadius); if (_Iteration == 0 || intensity == 0 || _BlurRadius == 0) { Graphics.Blit(source, destination); return; } int width = (int)(source.width / 2); int height = (int)(source.height / 2); RenderTexture RT1, RT2; RT1 = RenderTexture.GetTemporary(width, height, 0, format); //提取亮度阈值 Graphics.Blit(source, RT1, material, 0); //这里提取阈值且进行一次降采样 ls.Add(RT1); //降采样 for (int i = 0; i \u003c _Iteration - 1; i++) { width /= 2; height /= 2; RT2 = RenderTexture.GetTemporary(width, height, 0, format); Graphics.Blit(RT1, RT2, material, 1); ls.Add(RT1 = RT2); } //升采样 for (int i = _Iteration - 1; i \u003e= 1; i--) { width *= 2; height *= 2; material.SetTexture(\"_BloomTex\", ls[i - 1]); RT2 = RenderTexture.GetTemporary(width, height, 0, format); Graphics.Blit(RT1, RT2, material, 2); ls.","date":"2021-08-09 20:28:47","objectID":"/bloom%E5%AE%9E%E7%8E%B0/:0:0","tags":[],"title":"泛光（Bloom）实现","uri":"/bloom%E5%AE%9E%E7%8E%B0/"},{"categories":["shader","笔记"],"content":"SRP/URP/HDRP之间的关系 ","date":"2021-07-26 14:36:31","objectID":"/unity-urp%E7%AC%94%E8%AE%B0/:1:0","tags":["shader"],"title":"Unity URP笔记","uri":"/unity-urp%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"SRP是什么？ SRP全称为Scriptable Render Pipeline（可编程渲染管线/脚本化渲染管线），是Unity提供的新渲染系统，可以在Unity通过C#脚本调用一系列API配置和执行渲染命令的方式来实现渲染流程，SRP将这些命令传递给Unity底层图形体系结构，然后再将指令发送给图形API。 说白了就是我们可以用SRP的API来创建自定义的渲染管线，可用来调整渲染流程或修改或增加功能。 它主要把渲染管线拆分成二层： 一层是比较底层的渲染API层，像OpenGL，D3D等相关的都封装起来。 另一层是渲染管线上层，上层代码使用C#来编写。在C#这层不需要关注底层在不同平台上渲染API的差别，也不需要关注具体如何做一个Draw Call ","date":"2021-07-26 14:36:31","objectID":"/unity-urp%E7%AC%94%E8%AE%B0/:2:0","tags":["shader"],"title":"Unity URP笔记","uri":"/unity-urp%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"URP是什么？ 它的全称为Universal Render Pipeline(通用渲染管线)，简称 Universal RP, 它是Unity官方基于SRP提供的模板，它的前身是 LWRP(Lightweight RP 即轻量级渲染管线), 在2019.3开始改名为URP，它涵盖了范围广泛的不同平台，是针对跨平台开发而构建的，性能比内置管线要好，另外可以进行自定义，实现不同风格的渲染，通用渲染管线未来将成为在Unity中进行渲染的基础 。 **平台范围：**可以在Unity当前支持的任何平台上使用 ","date":"2021-07-26 14:36:31","objectID":"/unity-urp%E7%AC%94%E8%AE%B0/:3:0","tags":["shader"],"title":"Unity URP笔记","uri":"/unity-urp%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"HDRP是什么？ 它的全称为High Definition Render Pipeline（高清晰度渲染管线），它也是Unity官方基于SRP提供的模板，它更多是针对高端设备，如游戏主机和高端台式机，它更关注于真实感图形和渲染，该管线仅于以下平台兼容： Windows和Windows Store，带有DirectX 11或DirectX 12和Shader Model 5.0 现代游戏机（Sony PS4和Microsoft Xbox One） 使用金属图形的MacOS（最低版本10.13） 具有Vulkan的Linux和Windows平台 在此文章对HDRP不过多描述。 ","date":"2021-07-26 14:36:31","objectID":"/unity-urp%E7%AC%94%E8%AE%B0/:4:0","tags":["shader"],"title":"Unity URP笔记","uri":"/unity-urp%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"为什么诞生SRP？ 内置渲染管线的缺陷 定制性差：过去，Unity有一套内置渲染管线，渲染管线全部写在引擎的源码里。大家基本上不能改动，除非是买了Unity源码客户，当然大部分开发者是不会去改源码，所以过去的管线对开发者来说，很难进行定制。 代码脓肿，效果效率无法做到最佳：内置渲染管线在一个渲染管线里面支持所有的二十多个平台，包括非常高端的PC平台，也包括非常低端的平台，很老的手机也要支持，所以代码越来越浓肿，很难做到使效率和效果做到最佳。 目的 为了解决仅有一个默认渲染管线，造成的可配置型、可发现性、灵活性等问题。决定在C++端保留一个非常小的渲染内核，让C#端可以通过API暴露出更多的选择性，也就是说，Unity会提供一系列的C# API以及内置渲染管线的C#实现；这样一来，一方面可以保证C++端的代码都能严格通过各种白盒测试，另一方面C#端代码就可以在实际项目中调整。 渲染流水线图： ref: https://blog.csdn.net/qq_30259857/article/details/108318528 ref: https://blog.csdn.net/qq_33700123/article/details/114092028 ","date":"2021-07-26 14:36:31","objectID":"/unity-urp%E7%AC%94%E8%AE%B0/:5:0","tags":["shader"],"title":"Unity URP笔记","uri":"/unity-urp%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"SRPBatcher 详解参考官方文档: 可编程渲染管线 SRP Batcher ","date":"2021-07-26 14:36:31","objectID":"/unity-urp%E7%AC%94%E8%AE%B0/:6:0","tags":["shader"],"title":"Unity URP笔记","uri":"/unity-urp%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"URP 面板详解 面板详解: 通用渲染管线(URP)_学习笔记 ","date":"2021-07-26 14:36:31","objectID":"/unity-urp%E7%AC%94%E8%AE%B0/:7:0","tags":["shader"],"title":"Unity URP笔记","uri":"/unity-urp%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"UniversalRenderPipeline 源码分析 UnityEngine.Rendering.Universal.UniversalRenderPipeline public sealed partial class UniversalRenderPipeline : RenderPipeline 不包括XR，SceneView,Camera Preview，只是前向渲染的分析；不包括RenderingMode.Deferred的分析 ","date":"2021-07-26 14:36:31","objectID":"/unity-urp%E7%AC%94%E8%AE%B0/:8:0","tags":["shader"],"title":"Unity URP笔记","uri":"/unity-urp%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"Render分析 protected override void Render(ScriptableRenderContext renderContext, Camera[] cameras)的执行流程 BeginFrameRendering(renderContext, cameras); 配置GraphicsSettings 设置Shader全局变量 SetupPerFrameShaderConstants(); SortCameras(cameras); // 根据camera.depth排序 RenderCameraStack(renderContext, camera); UpdateVolumeFramework(baseCamera, baseCameraAdditionalData); BeginCameraRendering(renderContext, camera); UpdateVolumeFramework(camera, null); RenderSingleCamera(renderContext, camera); EndCameraRendering(renderContext, camera); EndFrameRendering(renderContext, cameras); protected override void Render(ScriptableRenderContext renderContext, Camera[] cameras) { BeginFrameRendering(renderContext, cameras); GraphicsSettings.lightsUseLinearIntensity = (QualitySettings.activeColorSpace == ColorSpace.Linear); GraphicsSettings.useScriptableRenderPipelineBatching = asset.useSRPBatcher; SetupPerFrameShaderConstants(); SortCameras(cameras); for (int i = 0; i \u003c cameras.Length; ++i){ var camera = cameras[i]; if (IsGameCamera(camera)) { RenderCameraStack(renderContext, camera); } else { BeginCameraRendering(renderContext, camera); UpdateVolumeFramework(camera, null); RenderSingleCamera(renderContext, camera); EndCameraRendering(renderContext, camera); } } EndFrameRendering(renderContext, cameras); } public static void RenderSingleCamera(ScriptableRenderContext context, Camera camera) { UniversalAdditionalCameraData additionalCameraData = null; if (IsGameCamera(camera)) camera.gameObject.TryGetComponent(out additionalCameraData); InitializeCameraData(camera, additionalCameraData, true, out var cameraData); RenderSingleCamera(context, cameraData, cameraData.postProcessEnabled); } /// \u003csummary\u003e /// Renders a single camera. This method will do culling, setup and execution of the renderer. /// \u003c/summary\u003e /// \u003cparam name=\"context\"\u003eRender context used to record commands during execution.\u003c/param\u003e /// \u003cparam name=\"cameraData\"\u003eCamera rendering data. This might contain data inherited from a base camera.\u003c/param\u003e /// \u003cparam name=\"anyPostProcessingEnabled\"\u003eTrue if at least one camera has post-processing enabled in the stack, false otherwise.\u003c/param\u003e static void RenderSingleCamera(ScriptableRenderContext context, CameraData cameraData, bool anyPostProcessingEnabled) { Camera camera = cameraData.camera; var renderer = cameraData.renderer; if (!TryGetCullingParameters(cameraData, out var cullingParameters)) return; ScriptableRenderer.current = renderer; bool isSceneViewCamera = cameraData.isSceneViewCamera; CommandBuffer cmd = CommandBufferPool.Get(); renderer.Clear(cameraData.renderType); renderer.SetupCullingParameters(ref cullingParameters, ref cameraData); context.ExecuteCommandBuffer(cmd); // Send all the commands enqueued so far in the CommandBuffer cmd, to the ScriptableRenderContext context cmd.Clear(); var cullResults = context.Cull(ref cullingParameters); InitializeRenderingData(asset, ref cameraData, ref cullResults, anyPostProcessingEnabled, out var renderingData); renderer.Setup(context, ref renderingData); renderer.Execute(context, ref renderingData); context.ExecuteCommandBuffer(cmd); // Sends to ScriptableRenderContext all the commands enqueued since cmd.Clear, i.e the \"EndSample\" command CommandBufferPool.Release(cmd); context.Submit(); // Actually execute the commands that we previously sent to the ScriptableRenderContext context } /// \u003csummary\u003e // Renders a camera stack. This method calls RenderSingleCamera for each valid camera in the stack. // The last camera resolves the final target to screen. /// \u003c/summary\u003e /// \u003cparam name=\"context\"\u003eRender context used to record commands during execution.\u003c/param\u003e /// \u003cparam name=\"camera\"\u003eCamera to render.\u003c/param\u003e static void RenderCameraStack(ScriptableRenderContext context, Camera baseCamera) { baseCamera.TryGetComponent\u003cUniversalAdditionalCameraData\u003e(out var baseCameraAdditionalData); // Overlay cameras will be rendered stacked while rendering base cameras if (baseCameraAdditionalData != null \u0026\u0026 baseCameraAdd","date":"2021-07-26 14:36:31","objectID":"/unity-urp%E7%AC%94%E8%AE%B0/:8:1","tags":["shader"],"title":"Unity URP笔记","uri":"/unity-urp%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"RenderSingleCamera 分析 static void RenderSingleCamera(ScriptableRenderContext context, CameraData cameraData, bool anyPostProcessingEnabled)的执行流程 ScriptableRender renderer= cameraData.renderer; 剔除操作，返回一个剔除参数（被摄象机渲染的游戏物体和光照的列表 ）TryGetCullingParameters(cameraData, out var cullingParameters) static bool TryGetCullingParameters(CameraData cameraData, out ScriptableCullingParameters cullingParams) cameraData.camera.TryGetCullingParameters(false, out cullingParams) 修改剔除参数（是否投射阴影，最大灯光数量，阴影距离shadowDistance，）renderer.SetupCullingParameters(ref cullingParameters, ref cameraData); public virtual void SetupCullingParameters(ref ScriptableCullingParameters cullingParameters, ref CameraData cameraData) context.ExecuteCommandBuffer(cmd); public void ExecuteCommandBuffer(CommandBuffer commandBuffer); 根据剔除参数执行剔除，获得剔除结果 var cullResults = context.Cull(ref cullingParameters); public CullingResults Cull(ref ScriptableCullingParameters parameters) 初始化渲染数据RenderingData（灯光数据，阴影数据，后处理数据,是否动态批处理，是否启用后处理，相机数据，剔除结果数据）InitializeRenderingData(asset, ref cameraData, ref cullResults, anyPostProcessingEnabled, out var renderingData); static void InitializeRenderingData(UniversalRenderPipelineAsset settings, ref CameraData cameraData, ref CullingResults cullResults, bool anyPostProcessingEnabled, out RenderingData renderingData) renderer.Setup(context, ref renderingData) public abstract void Setup(ScriptableRenderContext context, ref RenderingData renderingData); 如果获取深度 ConfigureCameraTarget(BuiltinRenderTextureType.CameraTarget, BuiltinRenderTextureType.CameraTarget); AddRenderPasses(ref renderingData); EnqueuePass(m_RenderOpaqueForwardPass); // TODO: Do we need to inject transparents and skybox when rendering depth only camera? They don't write to depth. EnqueuePass(m_DrawSkyboxPass); EnqueuePass(m_RenderTransparentForwardPass); ConfigureCameraColorTarget(activeColorRenderTargetId); AddRenderPasses(ref renderingData); // rendererFeatures AddRenderPasses CreateCameraRenderTarget(context, ref cameraTargetDescriptor, createColorTexture, createDepthTexture); // CameraRenderType.Base EnqueuePass(m_MainLightShadowCasterPass); EnqueuePass(m_AdditionalLightsShadowCasterPass); EnqueuePass(m_DepthNormalPrepass);或者 EnqueuePass(m_DepthPrepass); EnqueuePass(m_ColorGradingLutPass); EnqueuePass(m_RenderOpaqueForwardPass); EnqueuePass(m_DrawSkyboxPass); EnqueuePass(m_CopyDepthPass); EnqueuePass(m_CopyColorPass); EnqueuePass(m_TransparentSettingsPass); EnqueuePass(m_RenderTransparentForwardPass); EnqueuePass(m_OnRenderObjectCallbackPass); EnqueuePass(m_PostProcessPass); EnqueuePass(m_FinalPostProcessPass); EnqueuePass(m_CapturePass); EnqueuePass(m_FinalBlitPass); EnqueuePass(m_PostProcessPass); renderer.Execute(context, ref renderingData); public void Execute(ScriptableRenderContext context, ref RenderingData renderingData) ref CameraData cameraData = ref renderingData.cameraData; InternalStartRendering(context, ref renderingData); SetPerCameraShaderVariables(cmd, ref cameraData); SetShaderTimeValues(cmd, time, deltaTime, smoothDeltaTime); context.ExecuteCommandBuffer(cmd); SortStable(m_ActiveRenderPassQueue); // Sort the render pass queue SetupLights(context, ref renderingData); 执行所有Pass的Execute方法 ExecuteBlock(RenderPassBlock.BeforeRendering, in renderBlocks, context, ref renderingData); // Before Render Block. This render blocks always execute in mono rendering. // Camera is not setup. Lights are not setup. // Used to render input textures like shadowmaps. void ExecuteBlock(int blockIndex, in RenderBlocks renderBlocks,ScriptableRenderContext context, ref RenderingData renderingData, bool submit = false) { foreach (int currIndex in renderBlocks.GetRange(blockIndex)) //循环所有Pass {var renderPass = m_ActiveRenderPassQueue[currIndex]; ExecuteRenderPass(context, renderPass, ref renderingData);} if (submit) context.Submit();} void ExecuteRenderPass(ScriptableRenderContext context, ScriptableRenderPass renderPass, ref RenderingData renderingData){ using var profScope = new Profiling","date":"2021-07-26 14:36:31","objectID":"/unity-urp%E7%AC%94%E8%AE%B0/:8:2","tags":["shader"],"title":"Unity URP笔记","uri":"/unity-urp%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"URP笔记 ","date":"2021-07-26 14:36:31","objectID":"/unity-urp%E7%AC%94%E8%AE%B0/:9:0","tags":["shader"],"title":"Unity URP笔记","uri":"/unity-urp%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"URP LightModeTags 说明 Tags{“LightMode” = “XXX”} UniversalForward：前向渲染物件之用，SRPDefaultUnlit也用该pass渲染 ShadowCaster： 投射阴影之用 DepthOnly：只用来产生深度图 Mata：来用烘焙光照图之用 Universal2D ：做2D游戏用的，用来替代前向渲染 UniversalGBuffer ： 貌似与延迟渲染相关（开发中）, Does GI + emission. All additional lights are done deferred as well as fog UniversalForwardOnly: NormalsRendering: SceneSelectionPass:Scene view outline pass. Picking:Scene picking buffer pass DepthNormals: 只是用俩产生法线贴图_CameraNormalsTexture ","date":"2021-07-26 14:36:31","objectID":"/unity-urp%E7%AC%94%E8%AE%B0/:9:1","tags":["shader"],"title":"Unity URP笔记","uri":"/unity-urp%E7%AC%94%E8%AE%B0/"},{"categories":[],"content":" IDE支持 DirectX11 和 DirectX12 vs2019自带了DirectX，所以不要很复杂且繁琐的配置。但是如果安装的时候，没有勾选正确的包，后面就无法找到自带的DirectX。 启动Visual Studio Installer 勾选下图所示的两个安装包 第二个安装包，如果不够选也是无法看到DirectX的。 在通用Windows平台开发中，需要勾选如下所示包 这样在创建项目的时候，就可以看见DirectX11了 开发者模式也需要打开 然后，运行一下模板 ref: https://juejin.cn/post/6916331857856430088 ","date":"2021-07-24 16:24:05","objectID":"/directx%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:0","tags":[],"title":"DirectX环境搭建(Win10+VS2019+dx11\u0026\u0026dx12)","uri":"/directx%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":null,"content":" 绍跳点搜索(JPS)算法 IL学习： C#基础拾遗系列之一：先看懂IL代码 读懂IL代码就这么简单 (一) c# IL 指令集 c#的逆向工程-IL指令集 IL指令详细表 ","date":"2021-07-23 14:06:35","objectID":"/csharp%E7%AC%94%E8%AE%B0/:0:0","tags":null,"title":"CSharp笔记","uri":"/csharp%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"vs中设置IL ( ildasm.exe ) 我这里的路径： C:\\Program Files (x86)\\Microsoft SDKs\\Windows\\v10.0A\\bin\\NETFX 4.8 Tools\\x64\\ildasm.exe ","date":"2021-07-23 14:06:35","objectID":"/csharp%E7%AC%94%E8%AE%B0/:0:1","tags":null,"title":"CSharp笔记","uri":"/csharp%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"int强转 enum过程 结论：int强转enum和enum正常赋值是一样的，强转失败不会报异常，且赋值成功 using System; namespace EnumTest { internal class Program { enum Hello { A=0xfff0, B= 0xfff1, } static void Main(string[] args) { int n = 0xfff0; int m = 0xfff2; // int强转enum和enum正常赋值是一样的开销 不做越界处理 Hello h1=(Hello)n; int b1 = m; Console.WriteLine(h1); Console.WriteLine(b1); Console.ReadKey(); } } } 生成exe（Debug模式下，Release模式下代码被优化）后查看id代码 //Debug模式 .method private hidebysig static void Main(string[] args) cil managed { .entrypoint // 代码大小 43 (0x2b) .maxstack 1 .locals init ([0] int32 n, [1] int32 m, [2] valuetype EnumTest.Program/Hello h1, [3] int32 b1) //局部变量索引 IL_0000: nop IL_0001: ldc.i4 0xfff0 //入栈 IL_0006: stloc.0 // n赋值 栈顶出栈 IL_0007: ldc.i4 0xfff2 //入栈 IL_000c: stloc.1 // m赋值 栈顶出栈 IL_000d: ldloc.0 //加载 入栈 n IL_000e: stloc.2 // h1=n 栈顶出栈 IL_000f: ldloc.1 // 加载 入栈 m IL_0010: stloc.3 // b1=m 栈顶出栈 IL_0011: ldloc.2 //加载 入栈 h1 IL_0012: box EnumTest.Program/Hello //栈顶h1出栈 装箱结果入栈 IL_0017: call void [mscorlib]System.Console::WriteLine(object) //使用一个参数，使用后栈顶出栈 IL_001c: nop IL_001d: ldloc.3 //加载 入栈 b1 IL_001e: call void [mscorlib]System.Console::WriteLine(int32) IL_0023: nop IL_0024: call valuetype [mscorlib]System.ConsoleKeyInfo [mscorlib]System.Console::ReadKey() IL_0029: pop IL_002a: ret } // end of method Program::Main //Relase模式 .method private hidebysig static void Main(string[] args) cil managed { .entrypoint // 代码大小 36 (0x24) .maxstack 2 .locals init ([0] int32 m, [1] int32 b1) IL_0000: ldc.i4 0xfff0 IL_0005: ldc.i4 0xfff2 IL_000a: stloc.0 // m=0xfff2 IL_000b: ldloc.0 IL_000c: stloc.1 // b1=0xfff0 IL_000d: box EnumTest.Program/Hello IL_0012: call void [mscorlib]System.Console::WriteLine(object) IL_0017: ldloc.1 //加载b1 IL_0018: call void [mscorlib]System.Console::WriteLine(int32) IL_001d: call valuetype [mscorlib]System.ConsoleKeyInfo [mscorlib]System.Console::ReadKey() IL_0022: pop IL_0023: ret } // end of method Program::Main ","date":"2021-07-23 14:06:35","objectID":"/csharp%E7%AC%94%E8%AE%B0/:0:2","tags":null,"title":"CSharp笔记","uri":"/csharp%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"int强转成enum且越界 结论：int强转成enum越界时赋值会成功，但是输出是int的值 代码 using System; namespace EnumTest { internal class Program { enum Hello { A=0xfff0, B= 0xfff1, } static void Main(string[] args) { int n = 0xfff0; int m = 0xfff2; Hello h1=(Hello)n; int b1 = m; Console.WriteLine(h1.ToString()); h1 = (Hello)100; //int强转成enum越界时赋值会成功，但是输出是int的值 Console.WriteLine(h1.ToString()); Console.WriteLine(b1); Console.ReadKey(); } } } 输出: A 100 65522 ","date":"2021-07-23 14:06:35","objectID":"/csharp%E7%AC%94%E8%AE%B0/:0:3","tags":null,"title":"CSharp笔记","uri":"/csharp%E7%AC%94%E8%AE%B0/"},{"categories":["Unity"],"content":" 插件大全 Editor Console Pro RenderDoc 调试 ","date":"2021-06-29 16:02:18","objectID":"/renderdoc-%E8%B0%83%E8%AF%95/:0:0","tags":["Unity","opengl","RenderDoc"],"title":"RenderDoc 调试","uri":"/renderdoc-%E8%B0%83%E8%AF%95/"},{"categories":["Unity"],"content":"RenderDoc Android真机调试 连接手机时需要在手机上安装apk，然后开启所有请求的权限 开发者选项–\u003e USB安装 开启 开发者选项–\u003e USB调试(安全设置) 开启 开发者选项–\u003e 通过USB验证应用 关闭 开发者选项–\u003e 启动GPU调试层 开启 使用小米手机测试 ( RedMi K30 Ultra ) ","date":"2021-06-29 16:02:18","objectID":"/renderdoc-%E8%B0%83%E8%AF%95/:1:0","tags":["Unity","opengl","RenderDoc"],"title":"RenderDoc 调试","uri":"/renderdoc-%E8%B0%83%E8%AF%95/"},{"categories":["Unity"],"content":"RenderDoc 调试MuMU模拟器 参考 用RenderDoc和安卓模拟器抓帧手游 Windows 环境变量 RENDERDOC_HOOK_EGL = 0 。 (这个是为了防止 RenderDoc 把模拟器里面实现的 GLES API 给 Hook 了的同时还 Hook 了 DirectX 造成冲突) 在 RenderDoc Tools-\u003eSettings-\u003eGeneral 里面找到 Allow global process hooking 并勾选 找到模拟器的核心文件，一般是一个叫 XXXHeadLess.exe 的文件(也可能是其他的。找到的方法很简单，模拟器里面随便运行一个手游，然后任务管理器里面按照 CPU 使用排序，排在最前面的就是，右键点击之，选择打开文件所在位置。就可以找到核心文件的位置)。 我的路径C:\\Program Files\\NemuVbox\\Hypervisor 在 RenderDoc 的 Launch Application 页面里面。Executable Path 选择刚才找到的模拟器核心。然后在下面 Global Process Hook 里面点 Enable Global Hook，如果提示需要 Administrator 启动就确定以后再点 Enable Global Hook 按钮。 操作完后： 退掉所有模拟器，（注意一定要退干净，有时候模拟器界面关掉了，核心还在后台运行。可以在任务管理器里面查看模拟器的核心是否还在运行，还在运行的话用任务管理器杀掉）然后重新启动模拟器，这时候应该能看到模拟器画面左上角已经显示 RenderDoc 的信息了，如果没有，请检查前面操作是否正确，没有RenderDoc的显示信息说明完全没有加载成功。 上面操作后打不开模拟器则关闭hook启动模拟器修改设置，然后关闭模拟器，打开hook再重新打开模拟器试试 RenderDoc File 菜单 Attach to Running Instance , 在 localhost 下面可以看到模拟器核心程序，选中并点击 Connect to app ，之后就正常抓帧即可。 ","date":"2021-06-29 16:02:18","objectID":"/renderdoc-%E8%B0%83%E8%AF%95/:2:0","tags":["Unity","opengl","RenderDoc"],"title":"RenderDoc 调试","uri":"/renderdoc-%E8%B0%83%E8%AF%95/"},{"categories":[],"content":" 转自 冯乐乐 《unity shader 入门精要》 :https://blog.csdn.net/linuxheik/article/details/79446780/ Unity 从相机空间 通过透视投影变换（裁剪矩阵）后到裁剪空间，然后通过透视除法变换到归一化的设备坐标（Normalized Device Coordinates, NDC）,然后转换到视口坐标 。 z 分量从ndc [-1,1]到屏幕坐标[0,1]的映射方法： 其中，d对应了深度纹理中的像素值，Zndc对应了NDC坐标中的z分量的值。 透视变换 正交变换 ","date":"2021-04-24 15:08:25","objectID":"/lineareyedepth%E6%8E%A8%E5%AF%BC/:0:0","tags":[],"title":"LinearEyeDepth推导","uri":"/lineareyedepth%E6%8E%A8%E5%AF%BC/"},{"categories":[],"content":"推导 参考:透视投影变换推导 , 屏幕空间变换 根据前面透视投影变换推导和屏幕空间变换，我们使用透视投影的裁剪矩阵Pclip对相机空间下的一个顶点进行变换，裁剪空间下顶点的z分量和w分量分别为： 其中，Far 和 Near 分别是远近裁剪平面的距离。然后，我们通过齐次除法就可以得到NDC下的z分量： 之前我们知道，深度纹理中的深度值是 通过下面的公式由NDC计算而得的： 由上面的这些式子，我们可以推导出用d表示而得的Zvisw的表达式： d=0.5((f+n)/(f-n) +2nf/((f-n)z))+0.5 d-0.5=0.5((f+n)/(f-n) +2nf/((f-n)z)) 2d-1=((f+n)/(f-n) +2nf/((f-n)z)) 2d-1=(((f+n)z +2nf)/((f-n)z)) (f+n)z+2nf=(2d-1)(f-n)z (2d-1)(f-n)z-(f+n)z=2nf ((2d-1)(f-n)-(f+n))z=2nf z=2nf/((2d-1)(f-n)-(f+n)) z=2nf/(2d(f-n)-(f-n)-(f+n)) z=2nf/(2d(f-n)-2f) z=nf/(d(f-n)-f) z=1/((f-n)d/(nf)-1/n) 由于在Unity使用的视角空间中，摄像机正向对应的z值均为负值，因此为了得到深度值的正数表示，我们需要对上面的结果取反，最后得到的结果如下： 它的取值范围就是视锥体深度范围，即[Near,Far]。如果我们想要得到范围在[0, 1]之间的深度值，只需要把上面得到的结果除以Far即可。这样，0就表示该点与摄像机位于同一位置，1表示该点位于视锥体的远裁剪平面上。结果如下： 运的是，Unity提供了两个辅助函数来为我们进行上述的计算过程 LinearEyeDepth 和 Linear01Depth: LinearEyeDepth 负责把深度纹理的采样结果转换到视角空间下的深度值，也 就是我们上面得到的Zvisw。 Linear01Depth 则会返回一个范围在[0, 1]的线性深度值，也就是我们上面得到的Z01，这两个函数内部使用了内置的 _ZBufferParams 变量来得到远近裁剪平面的距离。 LinearEyeDepth 方法和 Linear01Depth 方法： // Z buffer to linear depth inline float LinearEyeDepth( float z ) { return 1.0 / (_ZBufferParams.z * z + _ZBufferParams.w); } // Z buffer to linear 0..1 depth (0 at eye, 1 at far plane) inline float Linear01Depth( float z ) { return 1.0 / (_ZBufferParams.x * z + _ZBufferParams.y); } //其中_ZBufferParams的定义如下： //double zc0, zc1; // OpenGL would be this: // zc0 = (1.0 - m_FarClip / m_NearClip) / 2.0; // zc1 = (1.0 + m_FarClip / m_NearClip) / 2.0; // D3D is this: //zc0 = 1.0 - m_FarClip / m_NearClip; //zc1 = m_FarClip / m_NearClip; // now set _ZBufferParams with (zc0, zc1, zc0/m_FarClip, zc1/m_FarClip); _ZBufferParams 参数：(1-Far/Near, Far/Near, x/Far, y/Far) ","date":"2021-04-24 15:08:25","objectID":"/lineareyedepth%E6%8E%A8%E5%AF%BC/:1:0","tags":[],"title":"LinearEyeDepth推导","uri":"/lineareyedepth%E6%8E%A8%E5%AF%BC/"},{"categories":[],"content":"使用 ","date":"2021-04-24 15:08:25","objectID":"/lineareyedepth%E6%8E%A8%E5%AF%BC/:2:0","tags":[],"title":"LinearEyeDepth推导","uri":"/lineareyedepth%E6%8E%A8%E5%AF%BC/"},{"categories":[],"content":"屏幕坐标 (Screen Space) 通过投影变换后，坐标系变换到裁剪空间了，然后从裁剪空间变换到屏幕空间，这里分为两步完成： 首先进行齐次除法（homegeneous division），也被称为透视除法（perspective division）,这一步很简单，就是用齐次坐标系的w分量去除以x,y,z分量，在OpenGL中这一步得到的坐标也叫归一化的设备坐标（Normalized Device Coordinates,NDC）。经过这一步，从齐次裁剪坐标空间转换到NDC中。 然后将NDC转换到屏幕空间。 在Unity中，屏幕空间左下角的像素坐标是(0,0),右上角的像素坐标是(pixelWidth,pixelHeight)。由于当前齐次坐标x和y都在[-1,1]范围内，因此映射过程就是一个缩放过程。 z分量被用于深度缓冲，一个传统方式是把clipz/clipw的值直接存进深度缓冲中，但不是必须的。 ","date":"2021-04-23 20:11:20","objectID":"/%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E5%8F%98%E6%8D%A2/:1:0","tags":[],"title":"屏幕空间变换","uri":"/%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E5%8F%98%E6%8D%A2/"},{"categories":[],"content":"视口坐标 (Viewport Space) 屏幕坐标系是左下角为原点，右上角为分辨率大小的坐标系，而视口坐标系是左下角为原点 (0,0),右上角是 (1,1)的坐标系。 我们将齐次除法和视口坐标映射的过程使用下面公式来完成： 如果在定点着色器只是经过ComputeScreenPos（函数输入参数：经过MVP矩阵变换后在裁剪空间的顶点坐标）计算，实际输出的结果是： ComputeScreenPos在顶点着色器中没有做除以 clipw 的操作，需要在片元着色器进行除以 clipw 操作。 ComputeScreenPos 方法： ","date":"2021-04-23 20:11:20","objectID":"/%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E5%8F%98%E6%8D%A2/:2:0","tags":[],"title":"屏幕空间变换","uri":"/%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E5%8F%98%E6%8D%A2/"},{"categories":[],"content":" 在3D渲染中，输入数据是一些primitive信息，包括顶点位置、颜色、纹理坐标等等。在光栅化阶段，primitive(一般为三角形)被转化成一系列的fragment(或者称为像素),这些fragment接下来要做ps操作，此时每个fragment都有位置、颜色、纹理坐标这些属性信息，这些属性信息通过顶点属性用插值方法得到的。比如下面的primtive，输入数据中只有a,b,c三个顶点的信息，则三角形内部经过扫描转化得到的像素f的颜色则是通过插值得到，d是a、b的差值，e是a、c的差值，然后f又是d、e的插值。 ","date":"2021-04-22 16:01:08","objectID":"/%E9%80%8F%E8%A7%86%E6%A0%A1%E6%AD%A3%E5%B7%AE%E5%80%BC/:0:0","tags":[],"title":"透视校正差值","uri":"/%E9%80%8F%E8%A7%86%E6%A0%A1%E6%AD%A3%E5%B7%AE%E5%80%BC/"},{"categories":[],"content":"推导 下图是clip裁剪锥体的xz平面，从图中可以看出，在投影平面的均匀插值(一系列蓝色的标记)，它们实际位置距离并不是均匀的，距离投影平面越远，实际位置距离越长，所以这是我们采用线性插值的话，可能最终的结果并不是我们所想要的。（坐标系为相机空间\u003c观察空间\u003e下，设O点是相机位置，-e所在的平面（水平线）为近裁剪面 ） 那么如何得到均匀的顶点属性插值呢？稍等一下，我们先看看深度插值： 点O是视点位置，从视点观察物体的投射线和投影平面相交的点即为物体在投影平面上的投射点，比如(x1,z1)在投影平面上的投射点为(p1,-e)，投射线的方程为ax+bz =c ， 其中c不能等于0，假设点(x,z)和O在投影平面的交点为(p,-e)(注意z坐标总是-e)，则有 解出x，并把它带入到ax+bz=c中，得到 转化为 已知线段\u003cx1,z1\u003e-\u003cx2,z2\u003e的投影坐标线段为\u003cp1,-e\u003e-\u003cp2,-e\u003e，假定p3=(1-t)p1+tp2 (0\u003c=t\u003c=1)，则p3是点\u003cp1,-e\u003e和\u003cp2,-e\u003e在投影平面上的线性差值点的x分量，则有下面的推导公式： 可见，z的倒数是线性插值，所以我们可以用顶点的z值来插值求得primitive内部fragment的属性值，比如颜色等等。 ","date":"2021-04-22 16:01:08","objectID":"/%E9%80%8F%E8%A7%86%E6%A0%A1%E6%AD%A3%E5%B7%AE%E5%80%BC/:1:0","tags":[],"title":"透视校正差值","uri":"/%E9%80%8F%E8%A7%86%E6%A0%A1%E6%AD%A3%E5%B7%AE%E5%80%BC/"},{"categories":[],"content":"几何推导 通过几何推导得出结论：假设EF=k*FG;则得出(1/h1 - 1/h2) = k( 1/h2 - 1/h3 );（可以将h理解为z，这里只是表面h的倒数呈现线性关系） ","date":"2021-04-22 16:01:08","objectID":"/%E9%80%8F%E8%A7%86%E6%A0%A1%E6%AD%A3%E5%B7%AE%E5%80%BC/:2:0","tags":[],"title":"透视校正差值","uri":"/%E9%80%8F%E8%A7%86%E6%A0%A1%E6%AD%A3%E5%B7%AE%E5%80%BC/"},{"categories":[],"content":"举例 假定\u003cx1,z1\u003e的颜色为b1, \u003cx2,z2\u003e的颜色为把b2，则\u003cx,z\u003e的颜色为b3为： 根据 可解得 可见用深度倒数来插值顶点属性是合适的。 转自：https://www.cnblogs.com/mikewolf2002/archive/2012/11/25/2787480.html https://zhuanlan.zhihu.com/p/174802008 ","date":"2021-04-22 16:01:08","objectID":"/%E9%80%8F%E8%A7%86%E6%A0%A1%E6%AD%A3%E5%B7%AE%E5%80%BC/:3:0","tags":[],"title":"透视校正差值","uri":"/%E9%80%8F%E8%A7%86%E6%A0%A1%E6%AD%A3%E5%B7%AE%E5%80%BC/"},{"categories":[],"content":" 转自: https://blog.csdn.net/zhuiqiuzhuoyue583/article/details/95228010 ","date":"2021-04-21 22:56:01","objectID":"/%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87%E7%9A%84%E6%84%8F%E4%B9%89/:0:0","tags":[],"title":"齐次坐标的意义","uri":"/%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87%E7%9A%84%E6%84%8F%E4%B9%89/"},{"categories":[],"content":"问题：两条平行线可以相交于一点 在欧氏几何空间，同一平面的两条平行线不能相交，这是我们都熟悉的一种场景。 然而，在透视空间里面，两条平行线可以相交，例如：火车轨道随着我们的视线越来越窄，最后两条平行线在无穷远处交于一点。 欧氏空间（或者笛卡尔空间）描述2D/3D几何非常适合，但是这种方法却不适合处理透视空间的问题（实际上，欧氏几何是透视几何的一个子集合），2维笛卡尔坐标可以表示为（x,y）。 如果一个点在无穷远处，这个点的坐标将会(∞,∞)，在欧氏空间，这变得没有意义。 平行线在透视空间的无穷远处交于一点，但是在欧氏空间却不能，数学家发现了一种方式来解决这个问题。 ","date":"2021-04-21 22:56:01","objectID":"/%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87%E7%9A%84%E6%84%8F%E4%B9%89/:1:0","tags":[],"title":"齐次坐标的意义","uri":"/%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87%E7%9A%84%E6%84%8F%E4%B9%89/"},{"categories":[],"content":"方法：齐次坐标 简短的解释： 齐次坐标就是将一个原本是n维的向量用一个n+1维向量来表示。 我们可以在一个2D笛卡尔坐标末尾加上一个额外的变量w来形成2D齐次坐标，因此，一个点(X,Y)在齐次坐标里面变成了（x,y,w），并且有 X = x/w Y = y/w 例如，笛卡尔坐标系下（1，2）的齐次坐标可以表示为（1，2，1），如果点（1，2）移动到无限远处，在笛卡尔坐标下它变为(∞,∞)，然后它的齐次坐标表示为（1，2，0），因为(1/0, 2/0) = (∞,∞)，我们可以不用”∞\"来表示一个无穷远处的点了，哈哈。 ","date":"2021-04-21 22:56:01","objectID":"/%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87%E7%9A%84%E6%84%8F%E4%B9%89/:2:0","tags":[],"title":"齐次坐标的意义","uri":"/%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87%E7%9A%84%E6%84%8F%E4%B9%89/"},{"categories":[],"content":"为什么叫齐次坐标？ 我们把齐次坐标转化为笛卡尔坐标的方法是前面n-1个坐标分量分别除以最后一个分量即可。 转化齐次坐标到笛卡尔坐标的过程中，我们有一个发现，例如： 你会发现(1, 2, 3), (2, 4, 6) 和(4, 8, 12)对应同一个Euclidean point (1/3, 2/3)，任何标量的乘积，例如(1a, 2a, 3a) 对应 笛卡尔空间里面的(1/3, 2/3) 。因此，这些点是“齐次的”，因为他们代表了笛卡尔坐标系里面的同一个点。换句话说，齐次坐标有规模不变性。 证明：两条直线可以相交 考虑如下方程组： 我们知道在笛卡尔坐标系里面，该方程组无解，因为C ≠ D,如果C=D,两条直线就相同了。让我们在透视空间里面，用齐次坐标x/w, y/w代替x ,y 现在我们有一个解(x, y, 0)，两条直线相交于(x, y, 0)，这个点在无穷远处。 ","date":"2021-04-21 22:56:01","objectID":"/%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87%E7%9A%84%E6%84%8F%E4%B9%89/:3:0","tags":[],"title":"齐次坐标的意义","uri":"/%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87%E7%9A%84%E6%84%8F%E4%B9%89/"},{"categories":[],"content":"意义 ","date":"2021-04-21 22:56:01","objectID":"/%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87%E7%9A%84%E6%84%8F%E4%B9%89/:4:0","tags":[],"title":"齐次坐标的意义","uri":"/%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87%E7%9A%84%E6%84%8F%E4%B9%89/"},{"categories":[],"content":"齐次坐标的意义1： 使用齐次坐标，可以表示 平行线在透视空间的无穷远处交于一点。在欧氏空间，这变得没有意义，所以欧式坐标不能表示。 即：齐次坐标可以表示无穷远处的点。例如： 如果点（1，2）移动到无限远处，在笛卡尔坐标下它变为(∞,∞)，然后它的齐次坐标表示为（1，2，0），因为(1/0, 2/0) =(∞,∞)，我们可以不用”∞\"来表示一个无穷远处的点了。 ","date":"2021-04-21 22:56:01","objectID":"/%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87%E7%9A%84%E6%84%8F%E4%B9%89/:4:1","tags":[],"title":"齐次坐标的意义","uri":"/%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87%E7%9A%84%E6%84%8F%E4%B9%89/"},{"categories":[],"content":"齐次坐标的意义2： 许多图形应用涉及到几何变换，主要包括平移、旋转、缩放。以矩阵表达式来计算这些变换时，平移是矩阵相加，旋转和缩放则是矩阵相乘，综合起来可以表示为 x=R∗X+t（注：因为习惯的原因，实际使用时一般使用变化矩阵左乘向量）(R 旋转缩放矩阵，t 为平移矩阵，X为原向量，x 为变换后的向量)。  齐次坐标的作用，把各种变换都统一了起来，即 把缩放，旋转，平移等变换都统一起来，都表示成一连串的矩阵相乘的形式。保证了形式上的线性一致性。 引入齐次坐标的目的主要是合并矩阵运算中的乘法和加法，表示为x=P∗X的形式。即它提供了用矩阵运算把二维、三维甚至高维空间中的一个点集从一个坐标系变换到另一个坐标系的有效方法。 “齐次坐标表示是计算机图形学的重要手段之一，它既能够用来明确区分向量和点，同时也更易用于进行仿射（线性）几何变换。”—— F.S. Hill, JR","date":"2021-04-21 22:56:01","objectID":"/%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87%E7%9A%84%E6%84%8F%E4%B9%89/:4:2","tags":[],"title":"齐次坐标的意义","uri":"/%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87%E7%9A%84%E6%84%8F%E4%B9%89/"},{"categories":[],"content":"透视投影是3D固定流水线的重要组成部分，是将相机空间中的点从视锥体(frustum)变换到规则观察体(Canonical View Volume)中，待裁剪完毕后进行透视除法的行为。在算法中它是通过透视矩阵乘法和透视除法(perspective division)（又叫齐次除法 homogeneous division）两步完成的。  透视投影变换是令很多刚刚进入3D图形领域的开发人员感到迷惑乃至神秘的一个图形技术。其中的理解困难在于步骤繁琐，对一些基础知识过分依赖，一旦对它们中的任何地方感到陌生，立刻导致理解停止不前。 没错，主流的3D APIs如OpenGL、D3D的确把具体的透视投影细节封装起来，比如 gluPerspective(…)就可以根据输入生成一个透视投影矩阵。而且在大多数情况下不需要了解具体的内幕算法也可以完成任务。但是你不觉得，如果想要成为一个职业的图形程序员或游戏开发者，就应该真正降伏透视投影这个家伙么？我们先从必需的基础知识着手，一步一步深入下去（这些知识在很多地方可以单独找到，但我从来没有在同一个地方全部找到，但是你现在找到了）。 我们首先介绍两个必须掌握的知识。有了它们，我们才不至于在理解透视投影变换的过程中迷失方向（这里会使用到向量几何、矩阵的部分知识，如果你对此不是很熟悉，可以参考《向量几何在游戏编程中的使用》系列文章） ","date":"2021-04-21 20:09:51","objectID":"/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%E6%8E%A8%E5%AF%BC/:0:0","tags":[],"title":"透视投影(Perspective Projection)变换推导过程","uri":"/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%E6%8E%A8%E5%AF%BC/"},{"categories":[],"content":"1.齐次坐标 透视投影变换是在齐次坐标下进行的，而齐次坐标本身就是一个令人迷惑的概念，这里我们先把它理解清楚。 简短的解释：齐次坐标就是将一个原本是n维的向量用一个n+1维向量来表示。 “齐次坐标表示是计算机图形学的重要手段之一，它既能够用来明确区分向量和点，同时也更易用于进行仿射（线性）几何变换。”—— F.S. Hill, JR 参考：齐次坐标的意义 ","date":"2021-04-21 20:09:51","objectID":"/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%E6%8E%A8%E5%AF%BC/:0:1","tags":[],"title":"透视投影(Perspective Projection)变换推导过程","uri":"/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%E6%8E%A8%E5%AF%BC/"},{"categories":[],"content":"2.线性插值 这是在图形学中普遍使用的基本技巧，我们在很多地方都会用到，比如2D位图的放大、缩小，Tweening变换，以及我们即将看到的透视投影变换等等。基本思想是：给一个x属于[a, b]，找到y属于[c, d]，使得x与a的距离比上ab长度所得到的比例，等于y与c的距离比上cd长度所得到的比例，用数学表达式描述很容易理解： 这样，从a到b的每一个点都与c到d上的唯一一个点对应。有一个x，就可以求得一个y。 此外，如果x不在[a, b]内，比如x \u003c a或者x \u003e b，则得到的y也是符合y \u003c c或者y \u003e d，比例仍然不变，插值同样适用。 ","date":"2021-04-21 20:09:51","objectID":"/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%E6%8E%A8%E5%AF%BC/:0:2","tags":[],"title":"透视投影(Perspective Projection)变换推导过程","uri":"/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%E6%8E%A8%E5%AF%BC/"},{"categories":[],"content":"投影变换（推导方案一） 转自：http://blog.csdn.net/popy007/article/details/1797121 好，有了上面两个理论知识，我们开始分析这次的主角——透视投影变换。这里我们选择OpenGL的透视投影变换进行分析，其他的APIs会存在一些差异，但主体思想是相似的，可以类似地推导。经过相机矩阵的变换，顶点被变换到了相机空间。这个时候的多边形也许会被视锥体裁剪，但在这个不规则的体中进行裁剪并非那么容易的事情，所以经过图形学前辈们的精心分析，裁剪被安排到规则观察体(Canonical View Volume, CVV)中进行，CVV是一个正方体，x, y, z的范围都是[-1，1]，多边形裁剪就是用这个规则体完成的。所以，事实上是透视投影变换由两步组成：  1） 用透视变换矩阵把顶点从视锥体中变换到裁剪空间的CVV中。 2） CVV裁剪完成后进行透视除法（一会进行解释）。 我们一步一步来，我们先从一个方向考察投影关系。 上图是右手坐标系中顶点在相机空间中的情形。设P(x,z)是经过相机变换之后的点，视锥体由eye——眼睛位置，np——近裁剪平面，fp——远裁剪平面组成。N是眼睛到近裁剪平面的距离，F是眼睛到远裁剪平面的距离。投影面可以选择任何平行于近裁剪平面的平面，这里我们选择近裁剪平面作为投影平面。设P’(x’,z’)是投影之后的点，则有z’ = -N。通过相似三角形性质，我们有关系： 同理，有 这样，我们便得到了P投影后的点P’ 从上面可以看出，投影的结果z’始终等于-N，在投影面上。实际上，z’对于投影后的P’已经没有意义了，这个信息点已经没用了。但对于3D图形管线来说，为了便于进行后面的片元操作，例如z缓冲消隐算法，有必要把投影之前的z保存下来，方便后面使用。因此，我们利用这个没用的信息点存储z，处理成： 这个形式最大化地使用了3个信息点，达到了最原始的投影变换的目的，但是它太直白了，有一点蛮干的意味，我感觉我们最终的结果不应该是它，你说呢？我们开始结合CVV进行思考，把它写得在数学上更优雅一致，更易于程序处理。假入能够把上面写成这个形式：  那么我们就可以非常方便的用矩阵以及齐次坐标理论来表达投影变换：  其中   哈，看到了齐次坐标的使用，这对于你来说已经不陌生了吧？这个新的形式不仅达到了上面原始投影变换的目的，而且使用了齐次坐标理论，使得处理更加规范化。注意在把 变成 的一步我们是使用齐次坐标变普通坐标的规则完成的。这一步在透视投影过程中称为透视除法（Perspective Division），这是透视投影变换的第2步，经过这一步，就丢弃了原始的z值（得到了CVV中对应的z值，后面解释），顶点才算完成了投影。而在这两步之间的就是CVV裁剪过程，所以裁剪空间使用的是齐次坐标 ，主要原因在于透视除法会损失一些必要的信息（如原始z，第4个-z保留的）从而使裁剪变得更加难以处理，这里我们不讨论CVV裁剪的细节，只关注透视投影变换的两步。 矩阵 就是我们投影矩阵的第一个版本。你一定会问为什么要把z写成   有三个原因： 后面投影之后的光栅化阶段，要通过x’和y’对z进行线性插值，以求出三角形内部片元的z，进行z缓冲深度测试。在数学上，投影后的x’和y’，与z不是线性关系，与1/z才是线性关系。而正 是1/z的线性关系，即-a+b/z。用这个1/z的线性组合值和x’、y’进行插值才是正确的。 P’的3个代数分量统一地除以分母-z，易于使用齐次坐标变为普通坐标来完成，使得处理更加一致、高效。 后面的CVV是一个x,y,z的范围都为[-1，1]的规则体，便于进行多边形裁剪。而我们可以适当的选择系数a和b，使得 这个式子在z = -N的时候值为-1，而在z = -F的时候值为1，从而在z方向上构建CVV。 上面是原始作者列举的原因，但我认为主要是一个原因：由于在光栅化的过程中，要进行 Z 坐标的倒数的插值,参考透视校正插值)。 接下来我们就求出a和b：  这样我们就得到了透视投影矩阵的第一个版本： 使用这个版本的透视投影矩阵可以从z方向上构建CVV，但是x和y方向仍然没有限制在[-1,1]中，我们的透视投影矩阵的下一个版本就要解决这个问题。 为了能在x和y方向把顶点从Frustum情形变成CVV情形，我们开始对x和y进行处理。先来观察我们目前得到的最终变换结果： 我们知道-Nx / z的有效范围是投影平面的左边界值（记为left）和右边界值（记为right），即[left, right]，-Ny / z则为[bottom, top]。而现在我们想把-Nx / z属于[left, right]映射到x属于[-1, 1]中，-Ny / z属于[bottom, top]映射到y属于[-1, 1]中。你想到了什么？哈，就是我们简单的线性插值，你都已经掌握了！我们解决掉它： 则我们得到了最终的投影点： 下面要做的就是从这个新形式出发反推出下一个版本的透视投影矩阵。注意到 是 经过透视除法的形式，而P’只变化了x和y分量的形式，az+b和-z是不变的，则我们做透视除法的逆处理——给P’每个分量乘上-z，得到 而这个结果又是这么来的： 则我们最终得到： M就是最终的透视变换矩阵。相机空间中的顶点，如果在视锥体中，则变换后就在CVV中。如果在视锥体外，变换后就在CVV外。而CVV本身的规则性对于多边形的裁剪很有利。OpenGL在构建透视投影矩阵的时候就使用了M的形式。注意到M的最后一行不是(0 0 0 1)而是(0 0 -1 0)，因此可以看出透视变换不是一种仿射变换，它是非线性的。另外一点你可能已经想到，对于投影面来说，它的宽和高大多数情况下不同，即宽高比不为1，比如640/480。而CVV的宽高是相同的，即宽高比永远是1。这就造成了多边形的失真现象，比如一个投影面上的正方形在CVV的面上可能变成了一个长方形。解决这个问题的方法就是在对多变形进行透视变换、裁剪、透视除法之后，在归一化的设备坐标(Normalized Device Coordinates)上进行的视口(viewport)变换中进行校正，它会把归一化的顶点之间按照和投影面上相同的比例变换到视口中，从而解除透视投影变换带来的失真现象。进行校正前提就是要使投影平面的宽高比和视口的宽高比相同。  便利的投影矩阵生成函数  3D APIs都提供了诸如gluPerspective(fov, aspect, near, far)或者D3DXMatrixPerspectiveFovLH(pOut, fovY, Aspect, zn, zf)这样的函数为用户提供快捷的透视矩阵生成方法。我们还是用OpenGL的相应方法来分析它是如何运作的。  gluPerspective(fov, aspect, near, far)  fov即视野，是视锥体在xz平面或者yz平面的开角角度，具体哪个平面都可以。OpenGL和D3D都使用yz平面。  aspect即投影平面的宽高比。  near是近裁剪平面的距离  far是远裁剪平面的距离。 上图中左边是在xz平面计算视锥体，右边是在yz平面计算视锥体。可以看到左边的第3步top = right / aspect使用了除法（图形程序员讨厌的东西），而右边第3步right = top x aspect使用了乘法，这也许就是为什么图形APIs采用yz平面的原因吧！  到目前为止已经完成了对透视投影变换的阐述，我想如果你一直跟着我的思路下来，应该能够对透视投影变换有一个细节层次上的认识。当然，很有可能你已经是一个透视投影变换专家，如果是这样的话，一定给我写信，指出我认识上的不足，我会非常感激。Bye! ","date":"2021-04-21 20:09:51","objectID":"/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%E6%8E%A8%E5%AF%BC/:1:0","tags":[],"title":"透视投影(Perspective Projection)变换推导过程","uri":"/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%E6%8E%A8%E5%AF%BC/"},{"categories":[],"content":"投影变换（推导方案二） 个人更倾向这种推导 转自：https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/opengl-perspective-projection-matrix 我们从相机的原点到要投影的点 P 画一条线，该线与图像平面的交点表示投影点 Ps 的位置。在OpenGL中，图像平面位于附近的剪切平面上（而不是与相机原点精确地相差一个单位）,这里是近剪切面。 ( 假设相机空间下任意一点 P ,首先投影到近裁剪面所在平面的点为 Ps，然后将 Ps 变换到NDC立方体空间) 图1：我们使用相似三角形的属性来找到 Ps 的位置。 相似的三角形ΔABC 和 ΔDEF是相似的。因此我们可以这样写： 如果我们用n 替代AB，近裁剪平面，DE用 Pz替代 （P的z坐标）和EF用 Py替代（P的y坐标），我们可以将该等式重写为（等式1）： 根据类似的原理得到方程式(等式2) 图2：相机的视锥范围或观看量由相机的视场，近和远裁剪平面以及图像纵横比定义。在OpenGL中，点投影在视锥的正面（靠近剪切平面）上。 ","date":"2021-04-21 20:09:51","objectID":"/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%E6%8E%A8%E5%AF%BC/:2:0","tags":[],"title":"透视投影(Perspective Projection)变换推导过程","uri":"/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%E6%8E%A8%E5%AF%BC/"},{"categories":[],"content":"计算 x和y的范围（[-1,1]） 现在我们有两个值 Psx 和 Psÿ我们仍然需要解释它们与OpenGL透视矩阵的关系。投影矩阵的目标是将投影到图像平面上的值重新映射到一个单位立方体（一个最小和最大范围分别为（-1，-1，-1）和（1,1,1）的立方体）。但是，一旦将点P投影到图像平面上，如果其x和y坐标包含在x的[left，rigtht]和y [bottom，top]的范围内，则Ps是可见的。如图2所示。这些坐标定义了可见点（包含在视锥体中并投影在图像平面上的所有点）在图像平面上的界限或边界。如果我们假设PsX 是可见的，那么我们可以这样写： 然后对该不等式进行变换， 再进行变换 上面不等式都乘以Pz后得到新的不等式，我们用矩阵的形式对不等式编码。将不等式的第一项系数和第二项系数替换矩阵的第一行第一列和第三列的系数，得到的结果： 请记住，OpenGL矩阵使用colum-major排序，因此我们将不得不使用列向量在矩阵的右边以及点坐标处写入乘法符号： 根据矩阵计算出Psx结果: 然后除以 -Pz后 根据上面的推导，我们可以推导出Psy 的不等式： 然后将系数带入矩阵 得出结果： 根据矩阵运算得出： 然后除以 -Pz后： ","date":"2021-04-21 20:09:51","objectID":"/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%E6%8E%A8%E5%AF%BC/:2:1","tags":[],"title":"透视投影(Perspective Projection)变换推导过程","uri":"/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%E6%8E%A8%E5%AF%BC/"},{"categories":[],"content":"计算 z的范围([-1,1]) 我们剩下要做的就是找到一种将投影点的z坐标重新映射到[-1,1]范围的方法。我们知道P的x和y坐标对投影点z坐标的计算没有帮助。因此，将要与P x和y坐标相乘的矩阵第三行的第一和第二系数必须为零（绿色）。我们在矩阵中剩下两个未知的系数A和B（红色）。 如果我们写方程式来计算 Ps然后除以 -Pž后 使用这个矩阵，我们得到（记住 Psž 也除以 Psw 当点从齐次坐标转换为笛卡尔坐标时，同时 Pw = 1）： 我们需要找到A和B的值。希望我们知道 Pž 躺在附近的裁剪平面上， Psž 需要重新映射为-1以及当 Pž 躺在远的剪裁平面上， Psž 需要重新映射为1。因此，我们需要替换 Psž 经过 ñ 和 F 在方程中得到两个新方程（请注意，投影在像面上的所有点的z坐标为负，但 ñ 和 F 是正数，因此我们将使用 − n 和 - f 取反）： 让我们求解方程式（1）中的B： B = − n + A n 。 并用该等式代入方程式(2)中的B： -fA − n + A n = f。 然后求解A和B： 我们可以替换在矩阵中为A和B找到的解决方案，最后得到： 这就是OpenGL透视投影矩阵 ","date":"2021-04-21 20:09:51","objectID":"/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%E6%8E%A8%E5%AF%BC/:2:2","tags":[],"title":"透视投影(Perspective Projection)变换推导过程","uri":"/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%E6%8E%A8%E5%AF%BC/"},{"categories":[],"content":"z-fighting 图3：投影点的z坐标的重新映射是非线性的。此图显示了结果Psž 对于Near = 1和far = 5。 z坐标的重映射(我们选择将z重映射到[-1,1]范围。从技术上讲，您可以将其重新映射为所需的任何内容，但[-1,1]也是常见的选择。)具有以比距离更远的点更高的数值精度来表示距离摄像机更近的点的属性。当缺乏数值精度导致某些相邻样本在投影到屏幕后，当它们的z坐标在世界上时，它们具有相同的深度值时，此属性可能会成为问题。空间实际上是不同的，这个问题称为 Z战 (z-fighting) 。这个问题不能真正解决（我们始终局限于可以存储在单精度浮点数中的精度，尽管如果将近剪切面和远剪切面分别设置得尽可能接近，则可以将问题最小化。场景中最接近和最远的物体，这就是为什么总是建议调整剪切平面的原因)。 最后翻译可能不准确，这里给出原文： (we are always limited to the precision that can be stored in a single-precision floating-point number though the problem can be minimised if the near and flar clipping planes are fit respectively as closely as possible to the nearest and furthest object visible in the scene. This is the reason why adjusting the clipping planes is always recommended.) ","date":"2021-04-21 20:09:51","objectID":"/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%E6%8E%A8%E5%AF%BC/:2:3","tags":[],"title":"透视投影(Perspective Projection)变换推导过程","uri":"/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%E6%8E%A8%E5%AF%BC/"},{"categories":[],"content":"简单概括透视投影变换 先变换x,y 将透视视椎体P投影到近裁剪面上P1 将在近裁剪面上P1变换到NDC正方形[-1,1]范围内 再变换z 使用 (A*z+B)/(-Pz) 的代数形式根据取值范围[-1,1]求解A和B 注意求解A和B时： 方程式： (A*(-n)+B)/(-(-n))=-1 (A*(-f)+B)/(-(-f))=1 为啥-n带入后是-1,因为是从相机空间（右手坐标系）变换到ndc空间（左手坐标系）,因为坐标系变换所以不等式代入-n后对应ndc空间是-1，不等式代入-f后对应ndc空间是1 ","date":"2021-04-21 20:09:51","objectID":"/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%E6%8E%A8%E5%AF%BC/:3:0","tags":[],"title":"透视投影(Perspective Projection)变换推导过程","uri":"/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%E6%8E%A8%E5%AF%BC/"},{"categories":[],"content":"Unity中透视投影变换 根据上面推导的结果按照右边yz平面计算视锥体，得出最终Unity中用的透视矩阵： 按照OpenGL计算的，不讨论DirectX OpenGL Projection Matrix ","date":"2021-04-21 20:09:51","objectID":"/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%E6%8E%A8%E5%AF%BC/:4:0","tags":[],"title":"透视投影(Perspective Projection)变换推导过程","uri":"/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%E6%8E%A8%E5%AF%BC/"},{"categories":[],"content":" 断言工具 特性 [Conditional(\"UNITY_ASSERTIONS\")] Asserts 有手动检查的一些优势: 简单易读的代码 错误消息是 干净和 可读性强的 assert 错误消息 默认情况下断言在 non-development模式 (你不需要使用预处理器), building 游戏时就扒掉。 断言在development下执行，非development 则代码自动删除 非development下如果要用则增加编译符号 UNITY_ASSERTIONS(Edit -\u003e Project Settings -\u003e Player的 Script Define Symbolsxx下增加),断言不中断执行,资产将只打印错误和会继续执行 如果你想要它只是作为exceptions(中断执行)，请确保从您的代码将 Assert.raiseExceptions 设置为 true. Assert.cs using System; using UnityEngine; using UnityEngine.Assertions; //using UnityEngine.Assertions.Must; //using UnityEngine.Assertions.Comparers; /// \u003csummary\u003e /// Unity 断言 /// \u003c/summary\u003e public class Assert { /// \u003csummary\u003e /// Whether Unity should throw an exception on a failure. /// 是否抛出异常 /// \u003c/summary\u003e public static bool raiseExceptions { get { return UnityEngine.Assertions.Assert.raiseExceptions; } set { UnityEngine.Assertions.Assert.raiseExceptions = value; } } /// \u003csummary\u003e /// 期待的值为True /// 如果是condition是false 则抛出异常 msg /// \u003c/summary\u003e /// \u003cparam name=\"condition\"\u003efalse 则抛出异常 msg\u003c/param\u003e /// \u003cparam name=\"msg\"\u003e\u003c/param\u003e public static void IsTrue(bool condition,string msg=null) { UnityEngine.Assertions.Assert.IsTrue(condition, msg); } public static void IsTrue(bool condition, String format, params object[] args) { UnityEngine.Assertions.Assert.IsTrue(condition, string.Format(format, args)); } public static void IsFalse(bool condition, string msg = null) { UnityEngine.Assertions.Assert.IsFalse(condition, msg); } public static void IsFalse(bool condition, String format, params object[] args) { UnityEngine.Assertions.Assert.IsFalse(condition, string.Format(format, args)); } public static void IsNull\u003cT\u003e(T value, string message=null) where T : class { UnityEngine.Assertions.Assert.IsNull\u003cT\u003e(value, message); } public static void IsNull(UnityEngine.Object value, string message = null) { UnityEngine.Assertions.Assert.IsNull(value, message); } public static void IsNotNull\u003cT\u003e(T value, string message = null) where T : class { UnityEngine.Assertions.Assert.IsNotNull\u003cT\u003e(value, message); } public static void IsNotNull(UnityEngine.Object value, string message = null) { UnityEngine.Assertions.Assert.IsNotNull(value, message); } } 参考文章：https://blog.csdn.net/u010019717/article/details/50375226 ","date":"2021-04-16 19:57:20","objectID":"/unity-assert%E6%96%AD%E8%A8%80%E5%B7%A5%E5%85%B7/:0:0","tags":[],"title":"Unity Assert断言工具","uri":"/unity-assert%E6%96%AD%E8%A8%80%E5%B7%A5%E5%85%B7/"},{"categories":["shader","笔记"],"content":" Shader Language目前主要有3种语言 基于OpenGL的OpenGL Shading Language，简称 GLSL; 基于DirectX的High Level Shading Language,简称 HLSL; 还有NVIDIA公司的C for Graphic，简称 Cg 语言 渲染相关博客及网站 catlikecoding :render相关博客 ","date":"2021-04-07 21:39:06","objectID":"/shader%E7%AC%94%E8%AE%B0/:0:0","tags":["shader","笔记"],"title":"Shader笔记","uri":"/shader%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"渲染管线流程 CPU应用阶段： 视锥体剔除，渲染顺序，提交Drawcall 顶点处理 ： 顶点MVP空间变换，自定义参数 光栅化操作 ： 裁剪，NDC归一化，背面剔除，屏幕坐标，图元装配，光栅化 片元处理 ： 光照着色，纹理着色 输出合并 ： Alpha测试，模版测试，深度测试，颜色混合 最后输出到帧缓冲区 CPU应用程序渲染逻辑 a. 剔除： 视锥体剔除（Frustum Culling） 层级剔除（Layer Culling Mask），遮挡剔除（Occlusion Culling）等规则 b. 渲染排序： 渲染队列 RenderQueue 不透明队列（RenderQueue \u003c 2500） 按摄像机 从前往后 排序 半透明队列（RenderQueue \u003e2500） 按摄像机 从后往前 排序（为了保证效果的正确性） c. 打包数据（Batch）：大量数据，参数发送到gpu 模型信息 顶点坐标 法线 UV 切线 顶点颜色 索引列表 矩阵 世界变换矩阵 VP矩阵：根据射线机位置和fov等参数构建VP矩阵 当矩阵的w分量为0的时候Unity会将其视为向量，而当w分量为1的时候Unity将其视为位置 灯光，材质参数 Shader 材质参数 灯光信息 d. 调用Shader SetPassCall（Shader，背面剔除等参数，设置渲染数据），DrawCall GPU渲染管线 CPU端调用DrawCall后 在GPU端启动顶点shader执行顶点处理 顶点Shader：最主要的处理是将模型空间的顶点变换到裁剪空间 顶点处理 ： 顶点MVP空间变换，自定义参数 光栅化操作 ： 裁剪，NDC归一化，背面剔除，屏幕坐标，图元装配，光栅化 片元处理 ： 光照着色，纹理着色 输出合并 ： Alpha测试，模版测试，深度测试，颜色混合 裁剪操作是在长方体或者正方体范围内进行的，不是视锥体，这里图中只是表达要进行三角形剔除 颜色混合 常用颜色混合类型 正常（Alpha Blend），即透明度混合 Blend SrcAlpha OneMinusSrcAlpha Particle Additive Blend SrcAlpha One 柔和叠加(Soft Additive) Blend OneMinusDstColor One 线性减淡（Additive,Linear Dodge） Blend One One (“LightMode” = “ForwardAdd” 光源叠加Pass使用的混合模式) 正片叠底（Multiply），即相乘 Blend DstColor Zero 两倍相乘（2x Multiply） Blend DstColor SrcColor 变暗（Darken） BlendOp Min Blend One One 变亮（Lighten） BlendOp Max Blend One One 滤色（Screen） Blend OneMinusDstColor One Blend One OneMinusSrcColor ","date":"2021-04-07 21:39:06","objectID":"/shader%E7%AC%94%E8%AE%B0/:0:1","tags":["shader","笔记"],"title":"Shader笔记","uri":"/shader%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"空间变换 模型空间（M）（左手坐标系） 世界空间（W）（左手坐标系） 观察空间（V）（右手坐标系） 裁剪空间（P）（左手坐标系） 屏幕空间（左手坐标系） 裁剪空间是正方形或者长方形，下一步ndc归一化是除以w就到正负1范围内，（z轴在opengl 范围是正负1，在dx中范围是从0到1） NDC归一化后进行背面剔剔除（Back Face Culling）根据三角形的索引顺序进行判定背面（三角形索引顺序是顺时针）或者正面（三角形索引顺序是逆时针），然后剔除对应三角形 ","date":"2021-04-07 21:39:06","objectID":"/shader%E7%AC%94%E8%AE%B0/:0:2","tags":["shader","笔记"],"title":"Shader笔记","uri":"/shader%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"类型长度 float：32位 half ：16位 精度范围-60000～+60000 fixed：11位 精度范围-2.0～+2.0;也可能是8位 一般使用fixed存储颜色和单位矢量 ","date":"2021-04-07 21:39:06","objectID":"/shader%E7%AC%94%E8%AE%B0/:0:3","tags":["shader","笔记"],"title":"Shader笔记","uri":"/shader%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"Gamma校正（Gamma Correct） 参考：https://zhuanlan.zhihu.com/p/66558476 点线代表线性颜色/亮度值（译注：这表示的是理想状态，Gamma为1），实线代表监视器显示的颜色。 Gamma校正(Gamma Correction)的思路是在最终的颜色输出上应用监视器Gamma的倒数。回头看前面的Gamma曲线图，你会有一个短划线，它是监视器Gamma曲线的翻转曲线。我们在颜色显示到监视器的时候把每个颜色输出都加上这个翻转的Gamma曲线，这样应用了监视器Gamma以后最终的颜色将会变为线性的。我们所得到的中间色调就会更亮，所以虽然监视器使它们变暗，但是我们又将其平衡回来了。 显示器的输出在Gamma2.2空间。(显示器自动计算) 伽马校正会将颜色转换到Gamma0.45空间。 伽马校正和显示器输出平衡之后，结果就是Gamma1.0的线性空间。 //为了有效解决color的值域问题，我们可以使用色调映射（Tone Map）和曝光控制（Exposure Map），用它们将color的高动态范围（HDR）映射到LDR之后再做伽马校正： color = color / (color + vec3(1.0)); // 色调映射（Tone Map） color = pow(color, vec3(1.0/2.2)); // 伽马校正 ","date":"2021-04-07 21:39:06","objectID":"/shader%E7%AC%94%E8%AE%B0/:0:4","tags":["shader","笔记"],"title":"Shader笔记","uri":"/shader%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"sRGB纹理 基于gamma0.45的颜色空间叫做sRGB颜色空间（Gamma 空间）。 把sRGB纹理变回线性空间： float gamma = 2.2; vec3 linear_diffuseColor = pow(texture(sRGB_diffuse, texCoords).rgb, vec3(gamma)); 变回线性空间后可以进行光照计算等等一系列计算 线性空间转到Gamma空间： float gamma = 2.2; vec3 gamma_diffuseColor = pow(linear_color, vec3(1.0/gamma)); Unity中sRGB(Color Texture)选项说明： sRGB (Color Texture) 启用此属性可指定将纹理存储在伽马空间中。对于非 HDR 颜色纹理（例如反照率和镜面反射颜色），应始终选中此复选框。如果纹理存储了有特定含义的信息，并且您需要着色器中的确切值（例如，平滑度或金属度），请禁用此属性。默认情况下会启用此属性。 ","date":"2021-04-07 21:39:06","objectID":"/shader%E7%AC%94%E8%AE%B0/:0:5","tags":["shader","笔记"],"title":"Shader笔记","uri":"/shader%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"linear和srgb,HDR区别 linear模式 在PBR流程中，环境光线效果需要使用linear模式，原来的gamma模式不再适用。因为gamma模式本身是为了使其他技术渲染出来的模型具有更真实而效果，对环境光进行了修正。但是在pbr中，贴图在设计的时候，完全是按照真实的环境中的光照去计算的，所以此处不再需要修正。 HDR(High Dynamic Range) 也叫 高动态范围 。 显示器被限制为只能显示值为0.0到1.0间的颜色（LDR），但是在光照方程中却没有这个限制。通过使片段的颜色超过1.0，我们有了一个更大的颜色范围，这也被称作HDR(High Dynamic Range, 高动态范围)。有了HDR，亮的东西可以变得非常亮，暗的东西可以变得非常暗，而且充满细节。 人眼有光线自适应的特性，这样也是能让人在暗的场景里看到更多东西，在亮的场景里能分辨更多东西，这种效果一般从电影院这样昏暗的场所里走出来更能体会，眼睛会有一个慢慢适应的过程。现在摄像头一般也会自适应曝光度，但是工业需求的有些还是需要不自动的，三维渲染之中，如果把这种真实完全模拟的图像给人眼看到，会感觉比我们人眼看到灰暗的多，所以一般会在硬件方面做一个反曲线最后变成srgb的色彩空间让人看到。 游戏引擎里面最终效果给人看到，当然是这种强化过的适应人眼的色彩空间，但是我做光照计算和贴图就不行，因为会由于多次的色彩强化导致最终画面强烈失真，这时候就是需要linear的色彩空间，计算时候用真实色彩，直到输出这一步把色彩强化一遍以适合人眼。unity很早就是linear的色彩空间，但是由于后期最后一部的矫正方面很多从业人士的素养不足，或者完全没有这个意识，做出来的效果完全是不正确，或者缺乏调整弹性的。而unreal则在工作流上面几乎是整合和后期的色表，去解决这个问题。 而HDR是模拟人眼的过程,能看到更广范围的光（就是亮的时候能更亮瞎），HDR图像的一般色域也超过普通的RGB色域（但也可以不超过）。HDR在unity中需要勾选摄像机上的HDR选项和使用延迟渲染deferred才能（否则会有滤镜提示The camera is not HDR enabled 这是没使用延迟渲染），要看出效果还要加个bloom之类的 ","date":"2021-04-07 21:39:06","objectID":"/shader%E7%AC%94%E8%AE%B0/:0:6","tags":["shader","笔记"],"title":"Shader笔记","uri":"/shader%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"法线 法线一般用切线空间存储，优点：自由度高，uv动画扰动，可以重用，可以压缩（只存储两个方向的数据） 切线空间（右手坐标系）： 切线方向（X轴）（和uv的u方向相同,有的是和v方向相同），次法线方向（Y轴）,法线方向（Z轴） half3 normal_data=UnpackNormal(normalmap); float3x3 TBN=float3x3(tangent_dir,binormal_dir,normal_dir); normal_dir=normalize(mul(normal_data.xyz,TBN)); // 和上面矩阵相乘结果一样 //normal_dir=normalize(tangent_dir*normal_data.x+binormal_dir*normal_data.y+normal_dir*normal_data.z); ","date":"2021-04-07 21:39:06","objectID":"/shader%E7%AC%94%E8%AE%B0/:0:7","tags":["shader","笔记"],"title":"Shader笔记","uri":"/shader%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"纹理 漫反射纹理 法线纹理 渐变纹理（卡通风格，从冷色调到暖色调） u方向渐变纹理 LUT（查找表，lookup table）纹理 遮罩纹理 高光强度遮罩 高光指数遮罩 边缘光强度遮罩 自发光遮罩 立方体纹理(天空盒) 渲染纹理（渲染目标纹理，RT） 程序纹理 AO贴图 AO贴图会根据模型某一部分相对于其他组成部分或者其他模型之间的几何距离，模拟模型的光影效果，比如一些夹角会更暗或者更亮，某一些面因为其他模型部分的影响，可能光照更少。 Height贴图，高度图，视差贴图（视差偏移，视差映射） height贴图会给模型本身根据实际需要增加凸起或者凹陷的几何效果。比如木质模型，某处被敲打而导致的凹陷效果。 粗糙度贴图 动画纹理（VAT） FlowMap ","date":"2021-04-07 21:39:06","objectID":"/shader%E7%AC%94%E8%AE%B0/:0:8","tags":["shader","笔记"],"title":"Shader笔记","uri":"/shader%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"光照 漫反射： lambert:max(0,dot(n,l)) halflambert:dot(n,l)*0.5+0.5 diffuse=basecolor*lightcolor*lambert ( or halflambert ) 镜面反射（高光，各向异性高光，kk高光）： phong:pow(max(dot(v,r),0),_Gloss) blinn-phong:pow(max(dot(n,h),0),_Gloss) //性能比phong要好 speccolor=lightcolor*_SpecIntensitylambertblinn-phong ( or phong ) 间接光漫反射：可以用 光照探针（light Probe） ，使用 SH 球谐光照模拟 间接光镜面反射:可以用 反射探针（reflection Probe），使用 IBL （基于图像的照明）模拟 菲涅尔： float fresnel=_FresnelScale+(1-_FresnelScale)*pow(1-saturate(ndotv),_FresnelPower); float reflectionFactor = _FresnelBias + _FresnelScale * pow(1 + dot(i, n), _FresnelPower); 环境光(ambient): 环境光可以理解为间接光的一部分(可以用 间接光漫反射和 间接光镜面反射代替) half3 ambient_color = UNITY_LIGHTMODEL_AMBIENT.rgb * base_color.xyz; 自发光 Matcap: float2 uv_mapcap=(vNormal*0.5+0.5).xy;使用观察空间下的法线代表uv坐标 Phong 光照模型： max(dot(n,l),0)+pow(max(dot(v,r),0),smoothness)+ambient=Phong 基础光照模型=直接光漫反射(Direct Diffuse)+直接光镜面反射(Direct Specular)+间接光漫反射(Indirect Diffuse)+间接光镜面反射(Indirect Specular) 直接光镜面反射: PBR中的GGX光照模型 环境贴图 环境贴图 （存储环境光或者间接光的漫反射和镜面反射的图像载体），环境光可以理解为间接光的一部分。 环境贴图一般转成立方体贴图（Cubemap）使用，原因：直接采样环境贴图会造成贴图空间的浪费及采样会出现失真情况，所以先转成立方体贴图 Cubemap立方体贴图的局限性： 只根据方向来采样 Cubemap 会造成采样点错误，这也是为什么Cubemap技术不适合用于平面模型作反射的原因 立方体贴图（Cubemap）采样：texCUBE(_CubeMap, reflect_dir) CubeMap samplerCUBE _CubeMap; float4 _CubeMap_HDR; half3 view_dir = normalize(_WorldSpaceCameraPos.xyz - i.pos_world); half3 reflect_dir = reflect(-view_dir, normal_dir); half4 color_cubemap = texCUBE(_CubeMap, reflect_dir); half3 env_color = DecodeHDR(color_cubemap, _CubeMap_HDR);//确保在移动端能拿到HDR信息 IBL_Specular samplerCUBE _CubeMap; float4 _CubeMap_HDR; half3 reflect_view_dir = reflect(-view_dir, normal_dir); float roughness = tex2D(_RoughnessMap, i.uv); roughness = saturate(pow(roughness, _RoughnessContrast) * _RoughnessBrightness); roughness = lerp(_RoughnessMin, _RoughnessMax, roughness); roughness = roughness * (1.7 - 0.7 * roughness); float mip_level = roughness * 6.0; half4 color_cubemap = texCUBElod(_CubeMap, float4(reflect_view_dir, mip_level)); half3 env_color = DecodeHDR(color_cubemap, _CubeMap_HDR);//确保在移动端能拿到HDR信息 IBL_Diffuse samplerCUBE _CubeMap; float4 _CubeMap_HDR; float roughness = tex2D(_RoughnessMap, i.uv); roughness = saturate(pow(roughness, _RoughnessContrast) * _RoughnessBrightness); roughness = lerp(_RoughnessMin, _RoughnessMax, roughness); roughness = roughness * (1.7 - 0.7 * roughness); float mip_level = roughness * 6.0; float4 uv_ibl = float4(normal_dir, mip_level); half4 color_cubemap = texCUBElod(_CubeMap, uv_ibl); half3 env_color = DecodeHDR(color_cubemap, _CubeMap_HDR);//确保在移动端能拿到HDR信息 half3 final_color = env_color * ao * _Tint.rgb * _Tint.rgb * _Expose; IBL_Reflection-Probe(环境光镜面反射)（unity捕捉生成的,unity最多支持两个反射探针） half3 view_dir = normalize(_WorldSpaceCameraPos.xyz - i.pos_world); half3 reflect_view_dir = reflect(-view_dir, normal_dir); reflect_view_dir = RotateAround(_Rotate, reflect_view_dir); float roughness = tex2D(_RoughnessMap, i.uv); roughness = saturate(pow(roughness, _RoughnessContrast) * _RoughnessBrightness); roughness = lerp(_RoughnessMin, _RoughnessMax, roughness); roughness = roughness * (1.7 - 0.7 * roughness); float mip_level = roughness * 6.0; half4 color_cubemap = UNITY_SAMPLE_TEXCUBE_LOD(unity_SpecCube0, reflect_view_dir, mip_level); half3 env_color = DecodeHDR(color_cubemap, unity_SpecCube0_HDR);//确保在移动端能拿到HDR信息 IBL_Light-Probe（环境光漫反射，内部使用SH读取） half3 env_color = ShadeSH9(float4(normal_dir,1.0)); //unity 内置函数 SH球谐光照（环境光漫反射可以使用SH）（可以替代IBL_Diffuse，节省性能，不用读取cube贴图） float4 normalForSH = float4(normal_dir, 1.0); //SHEvalLinearL0L1 half3 x; x.r = dot(custom_SHAr, normalForSH); x.g = dot(custom_SHAg, normalForSH); x.b = dot(custom_SHAb, normalForSH); //SHEvalLinearL2 half3 x1, x2; // 4 of the quadratic (L2) polynomials half4 vB = normalForSH.xyzz * normalForSH.yzzx; x1.r = dot(custom_SHBr, vB); x1.g = dot(custom_SHBg, vB); x1.b = dot(custom_SHBb, vB); // Final (5th) quadratic (L2) polynomial half vC = normalForSH.x*normalForSH.x - normalForSH.y*normalForSH.y; x2 = custom_SHC.rgb * vC; float3 sh = max(float3","date":"2021-04-07 21:39:06","objectID":"/shader%E7%AC%94%E8%AE%B0/:0:9","tags":["shader","笔记"],"title":"Shader笔记","uri":"/shader%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"角色渲染 ","date":"2021-04-07 21:39:06","objectID":"/shader%E7%AC%94%E8%AE%B0/:0:10","tags":["shader","笔记"],"title":"Shader笔记","uri":"/shader%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"动画 uv动画 顶点动画 1. 顶点动画贴图（VAT） （风力动画可以用这种）`比较细腻`(旗帜燃烧CS06) 2. 关键帧动画 骨骼动画 ","date":"2021-04-07 21:39:06","objectID":"/shader%E7%AC%94%E8%AE%B0/:0:11","tags":["shader","笔记"],"title":"Shader笔记","uri":"/shader%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"屏幕后处理 亮度 fixed3 finalColor=baseCol.rgb*_Brightness 饱和度 fixed luminance=0.2125*baseCol.r+0.7154*baseCol.g+0.0721*baseCol.b; fixed3 luminanceCol=fixed(luminance,luminance,luminance); finalCol = lerp(luminanceCol,finalCol,_Saturation); 对比度 fixed3 avgColor=fixed3(0.5,0.5,0.5); finalCol=lerp(avgColor,finalCol,_Constrast); 晕影/暗角（Vignette） //暗角/晕影 float2 d=abs(i.uv-half2(0.5,0.5))*_VignetteIntensity; d=pow(saturate(d),_VignetteRoundness); float dist=length(d); float vfactor=pow(saturate(1.0-dist*dist),_VignetteSmoothness); 边缘检测 模糊（Blur） 参考：高品质后处理：十种图像模糊算法的总结与实现 方框模糊（Box Blur） 高斯模糊（Gaussian Blur） 双重模糊（Dual Blur） Kawase模糊（DualKawaseBlur） 运动模糊 泛光 （Bloom） 光晕 ","date":"2021-04-07 21:39:06","objectID":"/shader%E7%AC%94%E8%AE%B0/:0:12","tags":["shader","笔记"],"title":"Shader笔记","uri":"/shader%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"深度纹理和法线纹理 设置 camera.depthTextureMode=DepthTextureMode.DepthNormals; _CameraDepthTexture ","date":"2021-04-07 21:39:06","objectID":"/shader%E7%AC%94%E8%AE%B0/:0:13","tags":["shader","笔记"],"title":"Shader笔记","uri":"/shader%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"全局雾效 ","date":"2021-04-07 21:39:06","objectID":"/shader%E7%AC%94%E8%AE%B0/:0:14","tags":["shader","笔记"],"title":"Shader笔记","uri":"/shader%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"卡通风格渲染 ","date":"2021-04-07 21:39:06","objectID":"/shader%E7%AC%94%E8%AE%B0/:0:15","tags":["shader","笔记"],"title":"Shader笔记","uri":"/shader%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"素描风格渲染 ","date":"2021-04-07 21:39:06","objectID":"/shader%E7%AC%94%E8%AE%B0/:0:16","tags":["shader","笔记"],"title":"Shader笔记","uri":"/shader%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"色调映射(Tone-Mapping) 用Tone-Mapping压缩高光范围 HDR颜色通过色调映射转到（0-1）范围内 一般用于屏幕后处理 // Tone-Mapping 需要将x从Gamma空间转到Lear线性空间使用，结果再转到Gamma空间下 inline float3 ACESFilm(float3 x) { float a=2.51f; float b= 0.03f; float c=2.43f; float d=0.59f; float e=0.14f; return saturate((x*(a*x+b))/(x*(c*x+d)+e)) } // Gamma空间 转Lear空间 color_lear=pow(color_gamma,2.2); // Lear空间转Gamma空间 color_gamma=pow(color_lear,1.0/2.2); ","date":"2021-04-07 21:39:06","objectID":"/shader%E7%AC%94%E8%AE%B0/:0:17","tags":["shader","笔记"],"title":"Shader笔记","uri":"/shader%E7%AC%94%E8%AE%B0/"},{"categories":["shader","笔记"],"content":"渲染优化 开销成因 CPU 过多的drawcall 复杂的脚本或者物理模拟 GPU 顶点处理 过多的顶点 过多的逐顶点计算 片元处理 过多的片元（可能分辨率高或者overdraw） 过多的逐片元计算 带宽 使用尺寸很大且未压缩的纹理 分辨率过高的帧缓存 优化方案 【Unity技巧】Unity中的优化技术 CPU 静态批处理（static batching）降低drawcall 动态批处理（顶点属性小于900（如果使用顶点坐标，法线和纹理坐标则顶点数量小于300），lightmap必须参数相同指向同一位置，多pass打断合并）降低drawcall 使用图集 共享材质 GPU 减少顶点数量 优化几何体 使用模型lod（Level of Detail）技术（unity中使用LOD Group组件） 使用遮挡剔除（Occlusion Culling）技术 使用mesh压缩 减少片元数量（核心降低overdraw） 控制绘制顺序 警惕透明物体 减少实时光照和阴影 减少计算复杂度 使用Shader的LOD技术 设置Shader.maximumLDO或者Shader.globalMaximumLOD来允许最大的LOD Shader代码优化 把高斯模糊和边缘计算计算放到顶点shader中 float存储顶点坐标等变量，half存储一些标量和纹理坐标等信息，fixed适用于大多数颜色变量和归一化的方向矢量 节省内存带宽 减少纹理大小 mipmap 关闭readwrite 纹理压缩（ETC2 8bit，ASTC 4x4 block，PVRTC） 降低屏幕分辨率 待处理 7.4.2 遮罩纹理的使用 data2 着色器替换技术（Shader Replacement） 常用素材资料： https://sketchfab.com/ ","date":"2021-04-07 21:39:06","objectID":"/shader%E7%AC%94%E8%AE%B0/:0:18","tags":["shader","笔记"],"title":"Shader笔记","uri":"/shader%E7%AC%94%E8%AE%B0/"},{"categories":["unity"],"content":"Unity中使用Texture2D的SetPixel大量调用的时候耗时非常严重。 在使用战争迷雾时需要不断的更新迷雾数据，当进入场景时需要先初始化迷雾数据，将数据转换成纹理（Texture2D），一张图片，使用public void SetPixel(int x, int y, Color color);时耗时非常严重。这里提供使用纹理原始数据直接修改的办法public NativeArray\u003cT\u003e GetRawTextureData\u003cT\u003e() where T : struct;，耗时优化明显提升。 使用GetRawTextureData\u003cT\u003e()该方法时遇到了一个问题： 当使用texture.GetRawTextureData\u003cColor32\u003e()时获取数据的长度是正常的。 当使用texture.GetRawTextureData\u003cColor\u003e()时获取数据的长度是原始长度的四分之一。 unity官方测试例子： using UnityEngine; public class ExampleScript : MonoBehaviour { void Start() { var texture = new Texture2D(128, 128, TextureFormat.RGBA32, false); GetComponent\u003cRenderer\u003e().material.mainTexture = texture; // RGBA32 texture format data layout exactly matches Color32 struct var data = texture.GetRawTextureData\u003cColor32\u003e(); // fill texture data with a simple pattern Color32 orange = new Color32(255, 165, 0, 255); Color32 teal = new Color32(0, 128, 128, 255); int index = 0; for (int y = 0; y \u003c texture.height; y++) { for (int x = 0; x \u003c texture.width; x++) { data[index++] = ((x \u0026amp; y) == 0 ? orange : teal); } } // upload to the GPU texture.Apply(); } } 测试代码： public void Awake() { MapComponent.Instance.fogComponent = this; jiesuoQueue.Clear(); if (DCFog.InstanceFog.Data == null) { Log.Error(\"FogComponent::DCFog.InstanceFog.Data=null\"); return; } if (!CheckFog) { GameObject warFogObj = GameObject.Find(\"WarFog\");//TODO TEMP if (warFogObj != null) { warFogObj.SetActive(false); } return; } Debug.Log($\"FOG LOADType::{LoadType}\"); long starttime = DateTime.UtcNow.Ticks; ProfilerHelper.BeginSample(\"FogComponent::Awake:UpdateLogicCell\"); int cell = SN01GameConstCategory.FogSide; int size = (int)(MapFactory.MAP_SIZE / cell); //texture = new Texture2D(size, size, TextureFormat.R8,false); texture = new Texture2D(MapFactory.MAP_SIZE, MapFactory.MAP_SIZE, TextureFormat.ARGB32, false); //Debug.Log(\"FogComponent::texture size:\"+MapFactory.MAP_SIZE+\" texture:\"+texture+\" data len:\"+ DCFog.InstanceFog.Data.Length); texture.filterMode = FilterMode.Point; texture.wrapMode = TextureWrapMode.Clamp; texture.name = \"fogtexture\"; texture.anisoLevel = 0; if(LoadType==0) { for (int i = 0; i \u003c size; i++) { for (int j = 0; j \u003c size; j++) { byte v = 0; if (DCFog.InstanceFog.Data.Length == 0) { v = 1; } else { v = DCFog.InstanceFog.Data[i * size + j]; } //if(v==1) //{ //ProfilerHelper.BeginSample(\"UpdateCell\"); UpdateLogicCell(i, j, v); //ProfilerHelper.EndSample(); //} } } } else { var array = texture.GetRawTextureData\u003cColor32\u003e(); //Debug.Log($\"fog::::===\u003e\u003earray:{array.Length},texture:({texture.width},{texture.height}),mipmap:{texture.mipmapCount},curlevel:{texture.loadedMipmapLevel}\"); for (int i = 0; i \u003c size; i++) { for (int j = 0; j \u003c size; j++) { byte v = 0; if (DCFog.InstanceFog.Data.Length == 0) { v = 1; } else { v = DCFog.InstanceFog.Data[i * size + j]; } for (int m = 0; m \u003c cell; m++) { for (int n = 0; n \u003c cell; n++) { array[(i * cell + m) + (j * cell + n) * MapFactory.MAP_SIZE] = v !=0 ? closeCol : openCol; } } } } } //ProfilerHelper.EndSample(); //ProfilerHelper.BeginSample(\"Apply\"); texture.Apply(); ProfilerHelper.EndSample(); Debug.LogError((DateTime.UtcNow.Ticks - starttime)/10000); #if UNITY_EDITOR float time = Time.realtimeSinceStartup; ProfilerHelper.BeginSample(\"FogComponent::Awake:WritePNG\"); Debug.LogError(System.IO.Path.Combine(Environment.CurrentDirectory, \"fog.png\")); System.IO.File.WriteAllBytes(System.IO.Path.Combine(Environment.CurrentDirectory, \"fog.png\"), texture.EncodeToPNG()); ProfilerHelper.EndSample(); Log.Error(\"EDITOR FogComponent::Awake:WritePNG Time: \" + (Time.realtimeSinceStartup - time)); #endif FogBlur fogBlur = Camera.main.GetComponent\u003cFogBlur\u003e(); if(fogBlur!=null) { //ProfilerHelper.BeginSample(\"FogComponent::ComputeShaderBlur\"); fogBlur.Source = texture; fogBlur.ComputeShaderBlurTextureOfFog(texture, Camera.main.GetComponent\u003cFogBlur\u003e().PrintTexture); //ProfilerHelper.EndSample(); } else { Debug.LogWarning(\"have no fogBlur\"); } //List\u003cint\u003e ls = new List\u003cint\u003e(); //ls.Add(1024*4+500); //ls.Add(1024 * 9 + 500); //ls.Add","date":"2020-10-10 18:02:43","objectID":"/unity-texture2d%E7%9A%84setpiexl%E4%B8%A5%E9%87%8D%E8%80%97%E6%97%B6%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/:0:0","tags":["Unity"],"title":"Unity Texture2D的SetPiexl严重耗时的优化方案","uri":"/unity-texture2d%E7%9A%84setpiexl%E4%B8%A5%E9%87%8D%E8%80%97%E6%97%B6%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":" UGUI关于富文本RichText参考 UGUI使用富文本RichText 可能有些开发人员碰到过做开发时发现UGUI的Text不能换行，有的朋友就会说可以通过\\n换行，并附上了整条字符串，但解决办法并非如此。 这么说吧，通过代码直接给Text组件的text赋值\"\u003ccolor=red\u003eXXXX\u003c/color\u003e\\nXXXX\"绝对是可以换行效果的；然而，在Inspector面板的Text组件里输入同样的内容就不行，哪怕手动复制进去都不对，那出现这个问题的原因是为什么？ 后来发现，原来它把\\n偷偷变成了\\\\n了，所以我们只要把它变回来就行啦！ using UnityEngine; using UnityEngine.UI; public class RyanTextLineFeed : MonoBehaviour { Text myText; void Start () { myText = GetComponent\u003cText\u003e (); myText.text = myText.text.Replace (\"\\\\n\", \"\\n\"); } } 转自：UGUI Text换行问题 ","date":"2020-10-06 13:49:43","objectID":"/ugui-text%E6%8D%A2%E8%A1%8C%E9%97%AE%E9%A2%98/:0:0","tags":["UGUI"],"title":"UGUI Text换行问题","uri":"/ugui-text%E6%8D%A2%E8%A1%8C%E9%97%AE%E9%A2%98/"},{"categories":["个人记录"],"content":"垃圾回收的基本知识: https://github.com/dotnet/docs.zh-cn/blob/live/docs/standard/garbage-collection/fundamentals.md 垃圾回收的基本知识: https://docs.microsoft.com/zh-cn/dotnet/standard/garbage-collection/fundamentals 清理未托管资源: https://docs.microsoft.com/zh-cn/dotnet/standard/garbage-collection/unmanaged .NET documentation 中文版： https://docs.microsoft.com/zh-cn/dotnet/fundamentals/ ","date":"2020-09-23 18:50:06","objectID":"/csharp%E8%AE%B0%E5%BD%95/:0:0","tags":[],"title":"C# 记录","uri":"/csharp%E8%AE%B0%E5%BD%95/"},{"categories":["Unity Tool"],"content":" 用C#实现md5计算，获取十六进制md5 MD5Helper.cs文件： using System.IO; using System.Security.Cryptography; namespace Codingriver { public static class MD5Helper { /// \u003csummary\u003e /// 计算文件的md5 /// \u003c/summary\u003e /// \u003cparam name=\"fileName\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static string CalculateMD5File(string fileName) { string md5Str = null; if (File.Exists(fileName)) { using (FileStream fs = new FileStream(fileName, FileMode.Open, FileAccess.Read)) { MD5 md5 = new MD5CryptoServiceProvider(); byte[] bts = md5.ComputeHash(fs); md5Str = bts.ToHex(); } } return md5Str; } /// \u003csummary\u003e /// 计算字符串的md5 /// \u003c/summary\u003e /// \u003cparam name=\"text\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static string CalculateMD5(string text) { MemoryStream stream = new MemoryStream(); StreamWriter sw = new StreamWriter(stream); sw.Write(text); sw.Flush(); return CalculateMD5(stream); } public static string CalculateMD5(Stream stream) { string md5Str = null; if (stream != null) { stream.Position = 0; MD5 md5 = new MD5CryptoServiceProvider(); byte[] bts = md5.ComputeHash(stream); md5Str = bts.ToHex(); } return md5Str; } public static string CalculateMD5(byte[] data) { string md5Str = null; if (data != null) { MD5 md5 = new MD5CryptoServiceProvider(); byte[] bts = md5.ComputeHash(data); md5Str = bts.ToHex(); } return md5Str; } public static string CalculateMD5(byte[] data, int offset, int count) { string md5Str = null; if (data != null) { MD5 md5 = new MD5CryptoServiceProvider(); byte[] bts = md5.ComputeHash(data, offset, count); md5Str = bts.ToHex(); } return md5Str; } } } ","date":"2020-09-19 18:45:30","objectID":"/md5%E8%AE%A1%E7%AE%97%E5%B7%A5%E5%85%B7/:0:0","tags":["Unity Tool","md5工具"],"title":"MD5计算工具","uri":"/md5%E8%AE%A1%E7%AE%97%E5%B7%A5%E5%85%B7/"},{"categories":["Unity Tool"],"content":" 用C#实现压缩和解压缩的方法，支持Zip压缩解压缩和Gzip压缩解压缩（后缀gz） 信息 使用ICSharpCode.SharpZipLib.dll来压缩/解压（压缩效率比GZip要高一点） ICSharpCode.SharpZipLib.dll下载： https://github.com/codingriver/tools/tree/master/thirdPlugins ZipHelper.cs文件： using System.IO; using System.IO.Compression; using ICSharpCode.SharpZipLib.Zip.Compression; namespace Codingriver { public static class ZipHelper { //压缩字节 //1.创建压缩的数据流 //2.设定compressStream为存放被压缩的文件流,并设定为压缩模式 //3.将需要压缩的字节写到被压缩的文件流 public static byte[] GZipCompress(byte[] bytes) { using (MemoryStream compressStream = new MemoryStream()) { using (var zipStream = new GZipStream(compressStream, CompressionMode.Compress)) zipStream.Write(bytes, 0, bytes.Length); byte[] data= compressStream.ToArray(); compressStream.Dispose(); return data; } } //解压缩字节 //1.创建被压缩的数据流 //2.创建zipStream对象，并传入解压的文件流 //3.创建目标流 //4.zipStream拷贝到目标流 //5.返回目标流输出字节 public static byte[] GZipDecompress(byte[] bytes) { using (var compressStream = new MemoryStream(bytes)) { using (var zipStream = new GZipStream(compressStream, CompressionMode.Decompress)) { using (var resultStream = new MemoryStream()) { zipStream.CopyTo(resultStream); UnityEngine.Debug.Log(resultStream.Capacity); return resultStream.ToArray(); } } } } /// \u003csummary\u003e /// Zip /// \u003c/summary\u003e /// \u003cparam name=\"content\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static byte[] Compress(byte[] content) { //return content; Deflater compressor = new Deflater(); compressor.SetLevel(Deflater.BEST_COMPRESSION); compressor.SetInput(content); compressor.Finish(); using (MemoryStream bos = new MemoryStream(content.Length)) { var buf = new byte[1024]; while (!compressor.IsFinished) { int n = compressor.Deflate(buf); bos.Write(buf, 0, n); } return bos.ToArray(); } } /// \u003csummary\u003e /// Unzip /// \u003c/summary\u003e /// \u003cparam name=\"content\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static byte[] Decompress(byte[] content) { return Decompress(content, 0, content.Length); } public static byte[] Decompress(byte[] content, int offset, int count) { //return content; Inflater decompressor = new Inflater(); decompressor.SetInput(content, offset, count); using (MemoryStream bos = new MemoryStream(content.Length)) { var buf = new byte[1024]; while (!decompressor.IsFinished) { int n = decompressor.Inflate(buf); bos.Write(buf, 0, n); } return bos.ToArray(); } } } } /* using System.IO; using System.IO.Compression; namespace Codingriver { public static class ZipHelper { public static byte[] Compress(byte[] content) { using (MemoryStream ms = new MemoryStream()) using (DeflateStream stream = new DeflateStream(ms, CompressionMode.Compress, true)) { stream.Write(content, 0, content.Length); return ms.ToArray(); } } public static byte[] Decompress(byte[] content) { return Decompress(content, 0, content.Length); } public static byte[] Decompress(byte[] content, int offset, int count) { using (MemoryStream ms = new MemoryStream()) using (DeflateStream stream = new DeflateStream(new MemoryStream(content, offset, count), CompressionMode.Decompress, true)) { byte[] buffer = new byte[1024]; while (true) { int bytesRead = stream.Read(buffer, 0, 1024); if (bytesRead == 0) { break; } ms.Write(buffer, 0, bytesRead); } return ms.ToArray(); } } } } */ ","date":"2020-09-19 18:44:48","objectID":"/ziphelper%E5%8E%8B%E7%BC%A9%E5%B7%A5%E5%85%B7/:0:0","tags":["Unity Tool","Zip压缩工具"],"title":"ZipHelper压缩工具","uri":"/ziphelper%E5%8E%8B%E7%BC%A9%E5%B7%A5%E5%85%B7/"},{"categories":["Unity Tool"],"content":" 这里是C#生成分布式唯一ID，不重复的id，不会产生碰撞 雪花ID介绍，雪花算法: 雪花ID是用一个64位的整形数字来做ID，对应.net中的long，数据库中的bigint，雪花算法的原始版本是scala版，用于生成分布式ID（纯数字，时间顺序）,订单编号等。 自增ID：对于数据敏感场景不宜使用，且不适合于分布式场景。 GUID：采用无意义字符串，数据量增大时造成访问过慢，且不宜排序。 算法描述： 最高位是符号位，始终为0，不可用。 41位的时间序列，精确到毫秒级，41位的长度可以使用69年。时间位还有一个很重要的作用是可以根据时间进行排序。 10位的机器标识，10位的长度最多支持部署1024个节点。 12位的计数序列号，序列号即一系列的自增id，可以支持同一节点同一毫秒生成多个ID序号，12位的计数序列号支持每个节点每毫秒产生4096个ID序号。 时钟回拨 雪花ID严重依赖系统当前时间，当系统时间被人为反后调整时，算法会出问题，可能会出重复ID．Snowflake原算法是在检测到系统时间被回调后直接抛异常．本代码在时钟回拨后,会将生成的ID时间戳停留在最后一次时间戳上(每当序列溢出时会往前走一毫秒),等待系统时间追上后即可以避过时钟回拨问题. 这种处理方式的优点是时钟回拨后不会异常，能一直生成出雪花ID，但缺点是雪花ID中的时间戳不是系统的当前时间，会是回拨前的最后记录的一次时间戳，但相差也不大．不知道有没有什么生产系统会对这个时间戳要求非常严格，无法使用这种补救方式的？ 当然停掉系统后的时钟回拨是无法处理的,这种还是会有可能出现重复ID的． IdGenerater.cs代码： using System; using System.Text; namespace Codingriver { public class IdGenerater { public class SnowflakeId { private static readonly long twepoch = new DateTime(2020, 1, 1, 0, 0, 0, DateTimeKind.Utc).Ticks; private static readonly DateTime Jan1st1970 = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc); /// \u003csummary\u003e /// 机器id所占位数 /// \u003c/summary\u003e private const int workerIdBits = 2; // 数据标识id所占的位数 private const int datacenterIdBits = 2; // 支持的最大机器id，结果是3 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) private const long maxWorkerId = -1L ^ (-1L \u003c\u003c workerIdBits); // 支持的最大数据标识id，结果是3 private const long maxDatacenterId = -1L ^ (-1L \u003c\u003c datacenterIdBits); // 序列在id中占的位数 private const int sequenceBits = 18; // 数据标识id向左移20位(18+2) private const int datacenterIdShift = sequenceBits + workerIdBits; // 机器ID向左移18位 private const int workerIdShift = sequenceBits; // 时间截向左移22位(2+2+18) private const int timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; // 生成序列的掩码，这里为262143 (0b111111111111111111=0x3ffff=262143) private const long sequenceMask = -1L ^ (-1L \u003c\u003c sequenceBits); // 数据中心ID(0~3) public long datacenterId { get; private set; } // 工作机器ID(0~3) public long workerId { get; private set; } // 毫秒内序列(0~262143) public long sequence { get; private set; } // 上次生成ID的时间截 public long lastTimestamp { get; private set; } /// \u003csummary\u003e /// 获取当前时间戳,毫秒 /// \u003c/summary\u003e /// \u003creturns\u003e\u003c/returns\u003e private static long GetCurrentTimestamp() { long stamp = (DateTime.UtcNow.Ticks - twepoch) / 10000; return stamp; } /// \u003csummary\u003e /// 雪花ID /// \u003c/summary\u003e /// \u003cparam name=\"datacenterId\"\u003e数据中心ID\u003c/param\u003e /// \u003cparam name=\"workerId\"\u003e工作机器ID\u003c/param\u003e public SnowflakeId(long datacenterId, long workerId) { if (datacenterId \u003e maxDatacenterId || datacenterId \u003c 0) { throw new Exception(string.Format(\"datacenter Id can't be greater than {0} or less than 0\", maxDatacenterId)); } if (workerId \u003e maxWorkerId || workerId \u003c 0) { throw new Exception(string.Format(\"worker Id can't be greater than {0} or less than 0\", maxWorkerId)); } this.workerId = workerId; this.datacenterId = datacenterId; this.sequence = 0L; this.lastTimestamp = -1L; } /// \u003csummary\u003e /// 获得下一个ID /// \u003c/summary\u003e /// \u003creturns\u003e\u003c/returns\u003e public long NextId() { lock (this) { long timestamp = GetCurrentTimestamp(); if (timestamp \u003e lastTimestamp) //时间戳改变，毫秒内序列重置 { sequence = 0L; } else if (timestamp == lastTimestamp) //如果是同一时间生成的，则进行毫秒内序列 { sequence = (sequence + 1) \u0026 sequenceMask; if (sequence == 0) //毫秒内序列溢出 { timestamp = GetNextTimestamp(lastTimestamp); //阻塞到下一个毫秒,获得新的时间戳 } } else //当前时间小于上一次ID生成的时间戳，证明系统时钟被回拨，此时需要做回拨处理 { sequence = (sequence + 1) \u0026 sequenceMask; if (sequence \u003e 0) { timestamp = lastTimestamp; //停留在最后一次时间戳上，等待系统时间追上后即完全度过了时钟回拨问题。 } else //毫秒内序列溢出 { timestamp = lastTimestamp + 1; //直接进位到下一个毫秒 } //throw new Exception(string.Format(\"Clock moved backwards. Refusing to generate id for {0} milliseconds\", lastTimestamp - timestamp)); } lastTimestamp = timestamp; //上次生成ID的时间截 //移位并通过或运算拼到一起组成64位的ID var id = ((timestamp) \u003c\u003c timestampLeftShift) | (datacenterId \u003c\u003c datacenterIdShift) | (workerId \u003c\u003c workerIdShift) | sequence; return id; } } /// \u003csummary\u003e /// 解析雪花ID /// \u003c/summary\u003e /// \u003creturns\u003e\u003c/returns\u003e public static string AnalyzeId(long Id) { StringBuilder sb = new StringBuilder(); var timestamp = (Id \u003e\u003e timestampLeftShift); v","date":"2020-09-18 18:08:02","objectID":"/%E7%94%9F%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8F%E5%94%AF%E4%B8%80id/:0:0","tags":["Unity Tool"],"title":"生成分布式唯一ID","uri":"/%E7%94%9F%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8F%E5%94%AF%E4%B8%80id/"},{"categories":["Unity Tool"],"content":" C#实现URL编码解码 URL编码解码原理参考 URL编码与解码原理 URLHelper实现URL编码和URL解码 ( 这些解码编码不支持空格和字符+转换 ) ： Escape 和 Unescape EncodeURI 和 DecodeURI EncodeURIComponent 和 DecodeURIComponent 还有 UrlEncode和UrlDecode方法支持支持空格和字符+转换 URLHelper.cs代码👇👇👇 using System; using System.Collections.Generic; using System.Net; using System.Text; using System.Web; namespace Codingriver { public static class URLHelper { /// \u003csummary\u003e /// URL编码（不支持空格和字符+转换） /// 使用UTF-16 /// \u003c/summary\u003e /// \u003cparam name=\"url\"\u003e\u003c/param\u003e /// \u003cparam name=\"encoding\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static string Escape(string url) { StringBuilder builder = new StringBuilder(url.Length * 2); for (int i = 0; i \u003c url.Length; i++) { char c = url[i]; ushort value = url[i]; if (c \u003e= '0' \u0026\u0026 c \u003c= '9' || c \u003e= 'A' \u0026\u0026 c \u003c= 'Z' || c \u003e= 'a' \u0026\u0026 c \u003c= 'z') { builder.Append(c); continue; } switch (c) { case '*': case '/': case '@': case '+': case '-': case '.': case '_': builder.Append(c); continue; default: break; } if(value\u003c= 255) { builder.AppendFormat(\"%{0:X2}\",value); } else { builder.AppendFormat(\"%u{0:X2}{1:X2}\", (value \u0026 0xFF00)\u003e\u003e8, value \u0026 0xFF); } } return builder.ToString(); } /// \u003csummary\u003e /// URL解码（不支持空格和字符+转换） /// 使用UTF-16 /// \u003c/summary\u003e /// \u003cparam name=\"escapeUrl\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static string Unescape(string escapeUrl) { StringBuilder builder = new StringBuilder(escapeUrl.Length); int index = 0; int len = escapeUrl.Length; while (index \u003c len) { if (escapeUrl[index] != '%') { builder.Append(escapeUrl[index]); index++; continue; } else if (escapeUrl[index+1] == 'u') { // unicode if (index + 5 \u003e= len) { throw new Exception(\"error url not match\"); } ushort value = 0; int high = ByteHelper.Parse(escapeUrl[index + 2]); int low = ByteHelper.Parse(escapeUrl[index + 3]); value = (byte)((high \u003c\u003c 4) | low); high = ByteHelper.Parse(escapeUrl[index + 4]); low = ByteHelper.Parse(escapeUrl[index + 5]); value = (ushort)((value\u003c\u003c8) |((high \u003c\u003c 4) | low)); builder.Append((char)value); index = index + 6; } else { // ascii if (index + 2 \u003e= len) { throw new Exception(\"error url not match\"); } ushort value = 0; int high = ByteHelper.Parse(escapeUrl[index + 1]); int low = ByteHelper.Parse(escapeUrl[index + 2]); value = (byte)((high \u003c\u003c 4) | low); builder.Append((char)value); index = index + 3; } } return builder.ToString(); } /// \u003csummary\u003e /// URL编码（支持空格和字符+转换） /// 使用UTF-16 /// \u003c/summary\u003e /// \u003cparam name=\"str\"\u003e\u003c/param\u003e /// \u003cparam name=\"encoding\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static string UrlEncode(string str, Encoding encoding = null) { if (encoding == null) return HttpUtility.UrlEncode(str); else return HttpUtility.UrlEncode(str, encoding); } /// \u003csummary\u003e /// URL解码（支持空格和字符+转换） /// 使用UTF-16 /// \u003c/summary\u003e /// \u003cparam name=\"str\"\u003e\u003c/param\u003e /// \u003cparam name=\"encoding\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static string UrlDecode(string str, Encoding encoding = null) { if (encoding == null) return HttpUtility.UrlDecode(str); else return HttpUtility.UrlDecode(str, encoding); } /// \u003csummary\u003e /// URL编码（不支持空格和字符+转换） /// \u003c/summary\u003e /// \u003cparam name=\"url\"\u003e\u003c/param\u003e /// \u003cparam name=\"encoding\"\u003e默认使用UTF-8\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static string EncodeURI(string url, Encoding encoding = null) { if (encoding == null) { encoding = Encoding.UTF8; } StringBuilder builder = new StringBuilder(url.Length * 2); char[] cArr = new char[1]; for (int i = 0; i \u003c url.Length; i++) { char c = url[i]; ushort value = url[i]; if (c \u003e= '0' \u0026\u0026 c \u003c= '9' || c \u003e= 'A' \u0026\u0026 c \u003c= 'Z' || c \u003e= 'a' \u0026\u0026 c \u003c= 'z') { builder.Append(c); continue; } switch (c) { case '!': case '#': case '$': case '\u0026': case '\\'': case '(': case ')': case '*': case '+': case ',': case '/': case ':': case ';': case '=': case '?': case '@': case '-': case '.': case '_': case '~': case '\"': builder.Append(c); continue; default: break; } cArr[0] = c; byte[] bts = encoding.GetBytes(cArr); for (int j = 0; j \u003c bts.Length; j++) { builder.AppendFormat(\"%{0:X2}\", bts[j]); } } return builder.ToString(); } /// \u003csummary\u003e /// URL解码（不支持空格和字符+转换） /// /// \u003c/s","date":"2020-09-17 20:47:11","objectID":"/urlhelper-url%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E5%B7%A5%E5%85%B7/:0:0","tags":["Unity Tool","Unicode编码","URL编码解码","encodeURI"],"title":"URLHelper URL编码解码工具","uri":"/urlhelper-url%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E5%B7%A5%E5%85%B7/"},{"categories":["计算机基础"],"content":" URL编码与解码原理 三个函数的安全字符: escape（69个）：*/@+-._0-9a-zA-Z encodeURI（82个）：!#$\u0026'()*+,/:;=?@-._~0-9a-zA-Z encodeURIComponent：（71个）：!'()*-._~0-9a-zA-Z 代码实现：URL编码解码工具 ","date":"2020-09-17 18:18:42","objectID":"/url%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81%E5%8E%9F%E7%90%86/:0:0","tags":["Unicode编码","URL编码解码","encodeURI"],"title":"URL编码与解码原理","uri":"/url%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81%E5%8E%9F%E7%90%86/"},{"categories":["计算机基础"],"content":"1、从escape和encodeURI讲起 假设你已经了解escape的编码： 不对 ASCII 字母、数字进行编码。 不对 *@-_+./ 进行编码。 其他所有的字符都会被转义序列替换。 escape('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789') // \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\" escape('*@-_+./') // \"*@-_+./\" 假设你已经了解encodeURI的编码： 不对 ASCII 字母和数字进行编码。 不对 -_.!~*'();/?:@\u0026=+$,# 这20个ASCII 标点符号进行编码。 其他所有的字符都会被转义序列替换。 encodeURI('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789') // \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\" encodeURI(\"-_.!~*'();/?:@\u0026=+$,#\") // \"-_.!~*'();/?:@\u0026=+$,#\" 掐指一算，escape的不编码集（69个） 是 encodeURI的不编码集（82个） 的子集。 当然，escape和encodeURI 是对 凹凸 进行编码的： escape('凹凸') //\"%u51F9%u51F8\" encodeURI('凹凸') // \"%E5%87%B9%E5%87%B8\" 嗯，了解细节 看 下面 👇 ","date":"2020-09-17 18:18:42","objectID":"/url%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81%E5%8E%9F%E7%90%86/:1:0","tags":["Unicode编码","URL编码解码","encodeURI"],"title":"URL编码与解码原理","uri":"/url%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81%E5%8E%9F%E7%90%86/"},{"categories":["计算机基础"],"content":"2、百分号编码 很诧异，escape和encodeURI 对 凹凸 的编码结果竟然不一样。 但是他们有个共同点，转化后形式类似 %*。 嗯，这个就是百分号编码了。 信息 百分号编码(Percent-encoding), 也称作URL编码(URL encoding), 是特定上下文的统一资源定位符 (URL)的编码机制。 escape和encodeURI的百分号编码的根本区别在于，encodeURI是W3C的标准（RFC 3986），而escape是非标准。 共同点： 对于需要编码的ASCII字符，将其表示为两个16进制的数字，然后在其前面放置转义字符(%)，置入URI中的相应位置。 区别： 标准：对于非ASCII字符, 需要转换为UTF-8字节序, 然后每个字节按照上述方式表示。 非标准：对于非ASCII字符在URI中表示为: %uxxxx, 其中xxxx是用4个十六进制数字表示的Unicode的码位值。 因为凹凸不是ASCII字符，所以encodeURI 对 凹凸 先转换为UTF-8字节序，一个字符有三个字节，每个字节转化为%xx，所以最后有6个%xx。 escape直接对凹凸转成了%u51F9%u51F8。 ","date":"2020-09-17 18:18:42","objectID":"/url%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81%E5%8E%9F%E7%90%86/:2:0","tags":["Unicode编码","URL编码解码","encodeURI"],"title":"URL编码与解码原理","uri":"/url%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81%E5%8E%9F%E7%90%86/"},{"categories":["计算机基础"],"content":"3、保留、未保留及受限的字符 RFC3986文档规定，Url中只允许包含未保留字符以及所有保留字符。 未保留字符包含英文字母（a-zA-Z）、数字（0-9）、-_.~ 4个特殊字符。对于未保留字符，不需要百分号编码。 保留字符是那些具有特殊含义的字符。RFC 3986 section 2.2 保留字符(18个)： 保留字符 含义 例子 :/?#[]@ 分隔Url的协议、主机、路径等组件。比如：冒号:保留为方案、用户/口令，以及主机/端口组件的定界符使用；/保留为路径组件中分隔路径段的定界符；? 保留作为查询字符串定界符使用；#保留为分段定界符使用 encodeURI(':/?#[]@') // \":/?#%5B%5D@\"其中[]被转义，因为它们是不安全字符 !$\u0026'()*+,;= 用于在每个组件中起到分隔作用的。比如：\u0026符号用于分隔查询多个键值对；=用于表示查询参数中的键值对。 encodeURI(\"!$\u0026'()*+,;=\") // \"!$\u0026'()*+,;=\" 受限字符或不安全字符，直接放在Url中的时候，可能会引起解析程序的歧义： 受限字符 为何受限 例子 % 作为编码字符的转义标志，因此本身需要编码 encodeURI('%') // \"%25\" 空格 Url在传输的过程，或者用户在排版的过程，或者文本处理程序在处理Url的过程，都有可能引入无关紧要的空格，或者将那些有意义的空格给去掉。 encodeURI(' ') // \"%20\" \u003c\u003e\" 尖括号和引号通常用于在普通文本中起到分隔Url的作用，所以应该对其进行编码 encodeURI('\u003c\u003e\"') // \"%3C%3E%22\" {}|\\^~[]' 某一些网关或者传输代理会篡改这些字符。你可能会感到奇怪，为什么使用一些不安全字符的时候并没有发生什么不好的事情，比如无需对~字符进行编码，前面也说了，对某些传输协议来说不是问题。 `encodeURI(\"{} 0x00-0x1F, 0x7F 受限，这些十六进制范围内的字符都在US-ASCII字符集的不可打印区间内 比如换行键是0x0A \u003e0x7F 受限，十六进制值在此范围内的字符都不在US-ASCII字符集的7比特范围内 encodeURI('京东') // \"%E4%BA%AC%E4%B8%9C\" 因此 信息 encodeURI的 不编码集（82个） = 66个未保留字符-_.~A-Za-z0-9 加上 18个保留字符:/?#[]@!$\u0026’()+,;=* 减去 2个不安全的保留字符[] ","date":"2020-09-17 18:18:42","objectID":"/url%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81%E5%8E%9F%E7%90%86/:3:0","tags":["Unicode编码","URL编码解码","encodeURI"],"title":"URL编码与解码原理","uri":"/url%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81%E5%8E%9F%E7%90%86/"},{"categories":["计算机基础"],"content":"4、encodeURI与encodeURIComponent 了解了encodeURI的不编码集合的由来，再来看看encodeURI与encodeURIComponent的区别。 假设你已经了解encodeURIComponent的编码： 不对 ASCII 字母和数字进行编码。 encodeURIComponent 不对!'()*-._~0-9a-zA-Z这9个ASCII 标点符号进行编码。 其他所有的字符都会被转义序列替换。 其实看一下名字，大概已经知道两者的区别了。 encodeURIComponent 假定参数是 URI 的一部分（比如协议、主机名、路径或查询字符串）。因此 encodeURIComponent() 函数将转义用于分隔 URI 各个部分的标点符号（;/?:@\u0026=+$,#），所以encodeURIComponent的不编码集只有71个，如下： encodeURIComponent('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789,/?:@\u0026=+$#') // \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%2C%2F%3F%3A%40%26%3D%2B%24%23\" 再看个对比例子： encodeURIComponent('https://aotu.io/') // \"https%3A%2F%2Faotu.io%2F\" encodeURI('https://aotu.io/') // \"https://aotu.io/\" ","date":"2020-09-17 18:18:42","objectID":"/url%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81%E5%8E%9F%E7%90%86/:4:0","tags":["Unicode编码","URL编码解码","encodeURI"],"title":"URL编码与解码原理","uri":"/url%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81%E5%8E%9F%E7%90%86/"},{"categories":["计算机基础"],"content":"5、字符编码 有没有人好奇 汉字有多少个字 ？ 具体数字小编也说不上。。谁能告诉我。。 不同编码收录的汉字数目也不一样。 GB 2312收录6763个汉字； GBK收录20912个汉字； GB 18030是中华人民共和国现时最新的内码字集，收录70244个汉字； Big5（繁体）收录13053个汉字； Unicode的中日韩统一表意文字基本字集则收录汉字20902个，另有四个扩展区，总数亦高达七万多字。 言归正传，ASCII，Unicode和UTF-8，它们究竟有没有关联呢？ ASCII码 一个字节（byte） = 8个二进制位（bit）， 因此1 byte可以表示256个字符，从00000000到11111111。 ASCII码的规定是最前面的1位二进制统一规定为0，所以只能表示128个字符编码了。 具体可查看维基百科-ASCII 。 Unicode Unicode，中文翻译成万国码、国际码、统一码、单一码。 Unicode只是一个符号集，只规定了符号的二进制代码。 从Unicode的中文翻译上可以看出Unicode与ASCII的区别：Unicode对世界上大部分的文字系统进行了整理、编码，而ASCII只是英文字符。 UTF-8 UTF-8是Unicode的实现方式之一。 UTF-8根据不同的符号而变化字节长度，编码规则如下： Unicode符号范围（十六进制） UTF-8编码（二进制） 解释 0000 0000~0000 007F 0xxxxxxx 字节的第一位设为0，代表是单字节字符。 0000 0080~0000 07FF 110xxxxx 10xxxxxx n=2个字节，第一个字节的前n位设为1，第n+1位设为0，其他字节的前2位为10。 0000 0800~0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx n=3个字节，第一个字节的前n位设为1，第n+1位设为0，其他字节的前2位为10。 0001 0000~0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx n=4个字节，第一个字节的前n位设为1，第n+1位设为0，其他字节的前2位为10。 例子，实现UTF-8编码： 凹的Unicode是\\u51f9， 十六进制 51f9 转成二进制 101000111111001， 根据编码规则，51f9 在 0000 0800~0000 FFFF的范围内，格式是1110xxxx 10xxxxxx 10xxxxxx。 从凹的右边的二进制位开始，从右到左的顺序依次放入格式中的x，不够则补0。 所以最后得到了11100101 10000111 10111001，转成十六进制就是e587b9，验证如下： encodeURI('凹') // \"%E5%87%B9\" 怎么解读凹的UTF-8编码二进制11100101 10000111 10111001 ？ 第一个字节的第一位不是0，确认第一个字节不是一个字符； 第一个字节的第一位是1，而且连续有3个1，就表示该字符占用了3个字节。 于是，计算机清晰地知道 11100101 10000111 10111001 三个字节表示一个符号，而不是分别表示三个符号，解读完毕。 附： 中文转Unicode在线工具：http://tool.chinaz.com/tools/unicode.aspx 二进制与十六进制在线转换工具：http://tool.oschina.net/hexconvert StringHelper编码辅助工具 ASCII，Unicode，UTF-16 和 UTF-8编码等字符编码 转自： URL编码的奥秘 ","date":"2020-09-17 18:18:42","objectID":"/url%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81%E5%8E%9F%E7%90%86/:5:0","tags":["Unicode编码","URL编码解码","encodeURI"],"title":"URL编码与解码原理","uri":"/url%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81%E5%8E%9F%E7%90%86/"},{"categories":["Unity Tool"],"content":" StringHelper编码辅助工具 (C#) Unicode编码介绍参考文章： ASCII，Unicode，UTF-16 和 UTF-8编码等字符编码 URL编码与解码原理 这里处理了Unicode编码相关操作，以及增加String类辅助方法。 String转Unicode编码（中文转Unicode编码） /// \u003csummary\u003e /// 字符串转Unicode编码 /// \u003c/summary\u003e /// \u003cparam name=\"str\"\u003e\u003c/param\u003e /// \u003creturns\u003eUTF-16 BE，大头方式\u003c/returns\u003e public static string ToUnicode(this string str) { StringBuilder builder = new StringBuilder(str.Length * 6); for (int i = 0; i \u003c str.Length; i++) { builder.AppendFormat(\"\\\\u{0:X4}\",(ushort)str[i]); } return builder.ToString(); } Unicode编码转String（Unicode编码转中文） /// \u003csummary\u003e /// Unicode编码转字符串 /// \u003c/summary\u003e /// \u003cparam name=\"unicodeStr\"\u003eUTF-16 BE，大头方式\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static string FromUnicode(this string unicodeStr) { if (unicodeStr.Length % 6 != 0) { throw new ArgumentException(String.Format(CultureInfo.InvariantCulture, \"The unicode string cannot have an odd number of digits: {0}\", unicodeStr)); } StringBuilder builder = new StringBuilder(unicodeStr.Length/6); for (int i = 0; i \u003c unicodeStr.Length; i+=6) { if(unicodeStr[i]=='\\\\'\u0026\u0026(unicodeStr[i+1]=='u'|| unicodeStr[i + 1] == 'U')) { byte high = (byte)((Parse(unicodeStr[i+2])\u003c\u003c4)| Parse(unicodeStr[i + 3])); byte low= (byte)((Parse(unicodeStr[i + 4]) \u003c\u003c 4) | Parse(unicodeStr[i + 5])); ushort value = (ushort)((high \u003c\u003c 8) | low); builder.Append((char)value); } } return builder.ToString(); } private static int Parse(char c) { if (c \u003e= 'a') return (c - 'a' + 10) \u0026 0x0f; if (c \u003e= 'A') return (c - 'A' + 10) \u0026 0x0f; return (c - '0') \u0026 0x0f; } 十六进制字符串转字节数组 public static byte[] HexToBytes(this string hexString) { if (hexString.Length % 2 != 0) { throw new ArgumentException(String.Format(CultureInfo.InvariantCulture, \"The binary key cannot have an odd number of digits: {0}\", hexString)); } var hexAsBytes = new byte[hexString.Length / 2]; for (int index = 0; index \u003c hexAsBytes.Length; index++) hexAsBytes[index] = (byte)((Parse(hexString[index*2]) \u003c\u003c 4) | Parse(hexString[index * 2+1])); return hexAsBytes; } 字节数组转十六进制字符串 public static string ToHex(this byte[] bytes) { StringBuilder stringBuilder = new StringBuilder(bytes.Length*2); for (int i = 0; i \u003c bytes.Length; i++) { stringBuilder.Append(bytes[i].ToString(\"X2\")); } return stringBuilder.ToString(); } public static string ToHex(this byte[] bytes,int index,int count) { StringBuilder stringBuilder = new StringBuilder(count * 2); for (int i = 0; i \u003c count; i++) { stringBuilder.Append(bytes[index+i].ToString(\"X2\")); } return stringBuilder.ToString(); } 字节数组转字符串（UTF-16 BE） if(bytes.Length%2!=0) { throw new ArgumentException(String.Format(CultureInfo.InvariantCulture, \"The binary key cannot have an odd number of digits: {0}\", bytes.ToHex())); } StringBuilder builder = new StringBuilder(bytes.Length / 2); for (int i = 0; i \u003c bytes.Length; i+=2) { ushort value = (ushort)((bytes[i + 1] \u003c\u003c 8) | bytes[i]); builder.Append((char)value); } return builder.ToString(); 字符串（UTF-16 BE）转字节数组 /// \u003csummary\u003e /// /// \u003c/summary\u003e /// \u003cparam name=\"str\"\u003e\u003c/param\u003e /// \u003creturns\u003eUTF-16 BE，大头方式\u003c/returns\u003e public static byte[] ToBytes(this string str) { byte[] bytes = new byte[str.Length * 2]; for (int i = 0; i \u003c str.Length; i++) { bytes[i * 2] = (byte)(((ushort)str[i]) \u0026 0xFF); bytes[i * 2+1] = (byte)(((ushort)str[i]\u003e\u003e8) \u0026 0xFF); } return bytes; } StringHelper.cs代码： using System; using System.Collections.Generic; using System.Globalization; using System.Text; namespace Codingriver { public static class StringHelper { /// \u003csummary\u003e /// /// \u003c/summary\u003e /// \u003cparam name=\"str\"\u003e\u003c/param\u003e /// \u003creturns\u003eUTF-16 BE，大头方式\u003c/returns\u003e public static byte[] ToBytes(this string str) { byte[] bytes = new byte[str.Length * 2]; for (int i = 0; i \u003c str.Length; i++) { bytes[i * 2] = (byte)(((ushort)str[i]) \u0026 0xFF); bytes[i * 2+1] = (byte)(((ushort)str[i]\u003e\u003e8) \u0026 0xFF); } return bytes; } //public static byte[] ToBytes(this string str) //{ // byte[] byteArray = Encoding.Default.GetBytes(str); // return byteArray; //} public static IEnumerable\u003cbyte\u003e ToBytesItor(this string str) { byte[] byteArray = Encoding.Default","date":"2020-09-16 21:38:31","objectID":"/stringhelper%E7%BC%96%E7%A0%81%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/:0:0","tags":["Unity Tool","Unicode编码"],"title":"StringHelper编码辅助工具","uri":"/stringhelper%E7%BC%96%E7%A0%81%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/"},{"categories":["Unity Tool"],"content":" Json序列化和反序列化工具 这里的Json工具使用的是Unity自带的JsonUtility，也可以使用LitJson或者MiniJson等工具 这里对比下JsonUtility和LitJson JsonHelper.cs代码： using System; using System.ComponentModel; using System.Runtime.Serialization; using UnityEngine; namespace Codingriver { public static class JsonHelper { public static string ToJson(object obj) { return JsonUtility.ToJson(obj); } public static T FromJson\u003cT\u003e(string str) { T t = JsonUtility.FromJson\u003cT\u003e(str); ISupportInitialize iSupportInitialize = t as ISupportInitialize; if (iSupportInitialize != null) { iSupportInitialize.EndInit(); } IDeserializationCallback deserializationCallback = t as IDeserializationCallback; if(deserializationCallback!=null) { deserializationCallback.OnDeserialization(t); } return t; } public static object FromJson(Type type, string str) { object t = JsonUtility.FromJson(str,type); ISupportInitialize iSupportInitialize = t as ISupportInitialize; if (iSupportInitialize != null) { iSupportInitialize.EndInit(); } IDeserializationCallback deserializationCallback = t as IDeserializationCallback; if (deserializationCallback != null) { deserializationCallback.OnDeserialization(t); } return t; } public static T Clone\u003cT\u003e(T t) { return FromJson\u003cT\u003e(ToJson(t)); } } } JsonUtility和LitJson对比测试代码： using System.Collections; using System.Collections.Generic; using UnityEngine; using Codingriver; using System.IO; using System; using LitJson; using System.Runtime.Serialization; public class JsonHelperTest : MonoBehaviour { [Serializable] public class InnerTest { public class InnerA { public string innerStr = \"严\"; int key = 99; } public int a = 1; public string b = \"hello\"; int[] arr = new int[] { 5, 76, 12 }; public InnerA innerA = new InnerA(); } public class TestData: IDeserializationCallback { public string[] Sitekeys = new string[] { \"river\", \"coding\" }; public string name = \"codingriver\"; public int a = 1000; public int d = 3; public string b = \"哈哈哈哈\"; [NonSerialized] public int c; protected string protect = \"11111\"; int m_Main = 1024; [NonSerialized] public InnerTest obj = new InnerTest(); public int Main { get { return m_Main; } set { m_Main = value; } } public void OnDeserialization(object sender) { c = a * d; } } // Start is called before the first frame update void Start() { TestData data = new TestData(); data.Main = 2048; data.name = \"你们好吗！\"; data.obj.a = 9; data.a = 7; data.d = 2; Debug.Log(\"origin:\"+Dumper.DumpAsString(data)); string json= JsonHelper.ToJson(data); Debug.Log(\"json:\"+json); File.WriteAllText(\"./test.json\", json); TestData data1 = JsonHelper.FromJson\u003cTestData\u003e(json); Debug.Log(\"data1:\"+ Dumper.DumpAsString(data1)); string litJson = JsonMapper.ToJson(data); Debug.Log($\"litJson:{litJson}\"); TestData data2 = JsonMapper.ToObject\u003cTestData\u003e(litJson); Debug.Log($\"data2:{Dumper.DumpAsString(data2)}\"); } // Update is called once per frame void Update() { } } 测试结果： JsonUtility和LitJson对比说明： JsonUtility和LitJson默认都是序列化公有变量；保护变量和私有变量不能序列化。 JsonUtility和LitJson都是支持序列化字段变量，不支持序列化属性变量（带set、get访问器的）。 LitJson序列化的字符串如果是中文则结果是进行十六进制编码，而JsonUtility序列化后的字符串是字符串本身 LitJson对于NonSerialized和Serializable特性配置是无效的。 JsonUtility是支持NonSerialized和Serializable特性的，定义的类如果要被序列化需要标记Serializable特性，字段不想被序列化则标记NonSerialized特性。 Serializable 仅对“类, 结构, 枚举, 委托”声明有效* ","date":"2020-09-16 17:31:14","objectID":"/jsonhelper%E5%B7%A5%E5%85%B7/:0:0","tags":["Unity Tool","Json","LitJson"],"title":"JsonHelper工具","uri":"/jsonhelper%E5%B7%A5%E5%85%B7/"},{"categories":["计算机基础"],"content":"编码历史与区别 一直对字符的各种编码方式懵懵懂懂，什么ANSI UNICODE UTF-8 GB2312 GBK DBCS UCS……是不是看的很晕，假如您细细的阅读本文你一定可以清晰的理解他们。Let`s go! 　很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，于是他们把这称为\"字节\"。 　再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为\"计算机\"。 　开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。 　他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作。遇上00x10, 终端就换行，遇上0x07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。他们看到这样很好，于是就把这些0x20以下的字节状态称为\"控制码\"。 　他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做 ANSI 的\"Ascii\"编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。 　后来，就像建造巴比伦塔一样，世界各地的都开始使用计算机，但是很多国家用的不是英文，他们的字母里有许多是ASCII里没有的，为了可以在计算机保存他们的文字，他们决定采用127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128到255这一页的字符集被称\"扩展字符集\"。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！ 　等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的\"全角\"字符，而原来在127号以下的那些就叫\"半角\"字符了。 　中国人民看到这样很不错，于是就把这种汉字方案叫做 “GB2312”。GB2312 是对 ASCII 的中文扩展。 　但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人。于是我们不得不继续把 GB2312 没有用到的码位找出来老实不客气地用上。 　后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。 　后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK 扩成了 GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。 　中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 “DBCS”（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。那时候凡是受过加持，会编程的计算机僧侣们都要每天念下面这个咒语数百遍： 　“一个汉字算两个英文字符！一个汉字算两个英文字符……” 　因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案——当时的中国人想让电脑显示汉字，就必须装上一个\"汉字系统\"，专门用来处理汉字的显示、输入的问题，但是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持 BIG5 编码的什么\"倚天汉字系统\"才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？ 　真是计算机的巴比伦塔命题啊！ 　正在这时，大天使加百列及时出现了——一个叫 ISO （国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它\"Universal Multiple-Octet Coded Character Set\"，简称 UCS, 俗称 “UNICODE”。 　UNICODE 开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ascii里的那些“半角”字符，UNICODE 包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于\"半角\"英文符号只需要用到低8位，所以其高8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。 　这时候，从旧社会里走过来的程序员开始发现一个奇怪的现象：他们的strlen函数靠不住了，一个汉字不再是相当于两个字符了，而是一个！是的，从 UNICODE 开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的\"一个字符\"！同时，也都是统一的\"两个字节\"，请注意\"字符\"和\"字节\"两个术语的不同，“字节”是一个8位的物理存贮单元，而“字符”则是一个文化相关的符号。在UNICODE 中，一个字符就是两个字节。一个汉字算两个英文字符的时代已经快过去了。 　从前多种字符集存在时，那些做多语言软件的公司遇上过很大麻烦，他们为了在不同的国家销售同一套软件，就不得不在区域化软件时也加持那个双字节字符集咒语，不仅要处处小心不要搞错，还要把软件中的文字在不同的字符集中转来转去。UNICODE 对于他们来说是一个很好的一揽子解决方案，于是从 Windows NT 开始，MS 趁机把它们的操作系统改了一遍，把所有的核心代码都改成了用 UNICODE 方式工作的版本，从这时开始，WINDOWS 系统终于无需要加装各种本土语言系统，就可以显示全世界上所有文化的字符了。 　但是，UNICODE 在制订时没有考虑与任何一种现有的编码方案保持兼容，这使得 GBK 与UNICODE 在汉字的内码编排上完全是不一样的，没有一种简单的算术方法可以把文本内容从UNICODE编码和另一种编码进行转换，这种转换必须通过查表来进行。 　如前所述，UNICODE 是用两个字节来表示为一个字符，他总共可以组合出65535不同的字符，这大概已经可以覆盖世界上所有文化的符号。如果还不够也没有关系，ISO已经准备了UCS-4方案，说简单了就是四个字节来表示一个字符，这样我们就可以组合出21亿个不同的字符出来（最高位有其他用途），这大概可以用到银河联邦成立那一天吧！ 　UNICODE 来到时，一起到来的还有计算机网络的兴起，UNICODE 如何在网络上传输也是一个必须考虑的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF8就是每次8个位传输数据，而UTF16就是每次16个位，只不过为了传输时的可靠性，从UNICODE到UTF时并不是直接的对应，而是要过一些算法和规则来转换。 　受到过网络编程加持的计算机僧侣们都知道，在网络里传递信息时有一个很重要的问题，就是对于数据高低位的解读方式，一些计算机是采用低位先发送的方法，例如我们PC机采用的 INTEL 架构，而另一些是采用高位先发送的方式，在网络中交换数据时，为了核对双方对于高低位的认识是否是一致的，采用了一种很简便的方法，就是在文本流的开始时向对方发送一个标志符——如果之后的文本是高位在位，那就发送\"FEFF\"，反之，则发送\"FFFE\"。不信你可以用二进制方式打开一个UTF-X格式的文件，看看开头两个字节是不是这两个字节？ 　讲到这里，我们再顺便说说一个很著名的奇怪现象：当你在 windows 的记事本里新建一个文件，输入\"联通\"两个字之后，保存，关闭，然后再次打开，你会发现这两个字已经消失了，代之的是几个乱码！呵呵，有人说这就是联通之所以拼不过移动的原因。 　其实这是因为GB2312编码与UTF8编码产生了编码冲撞的原因。 　从网上引来一段从UNICODE到UTF8的转换规则： Unicode UTF-8 0000 - 007F 0xxxxxxx 0080 - 07FF 110xxxxx 10","date":"2020-09-16 11:37:37","objectID":"/asciiunicode%E5%92%8Cutf-8/:0:0","tags":["Unicode编码"],"title":"ASCII，Unicode，UTF-16 和 UTF-8编码等字符编码","uri":"/asciiunicode%E5%92%8Cutf-8/"},{"categories":["计算机基础"],"content":"一、ASCII 码 我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。 上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。 ASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。 ","date":"2020-09-16 11:37:37","objectID":"/asciiunicode%E5%92%8Cutf-8/:1:0","tags":["Unicode编码"],"title":"ASCII，Unicode，UTF-16 和 UTF-8编码等字符编码","uri":"/asciiunicode%E5%92%8Cutf-8/"},{"categories":["计算机基础"],"content":"二、非 ASCII 编码 英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。 但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0–127表示的符号是一样的，不一样的只是128–255的这一段。 至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。 中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。 ","date":"2020-09-16 11:37:37","objectID":"/asciiunicode%E5%92%8Cutf-8/:2:0","tags":["Unicode编码"],"title":"ASCII，Unicode，UTF-16 和 UTF-8编码等字符编码","uri":"/asciiunicode%E5%92%8Cutf-8/"},{"categories":["计算机基础"],"content":"三. Unicode 正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。 可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。 Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。 ","date":"2020-09-16 11:37:37","objectID":"/asciiunicode%E5%92%8Cutf-8/:3:0","tags":["Unicode编码"],"title":"ASCII，Unicode，UTF-16 和 UTF-8编码等字符编码","uri":"/asciiunicode%E5%92%8Cutf-8/"},{"categories":["计算机基础"],"content":"四、Unicode 的问题 需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 比如，汉字严的 Unicode 是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。 这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。 它们造成的结果是：1）出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。2）Unicode 在很长一段时间内无法推广，直到互联网的出现。 ","date":"2020-09-16 11:37:37","objectID":"/asciiunicode%E5%92%8Cutf-8/:4:0","tags":["Unicode编码"],"title":"ASCII，Unicode，UTF-16 和 UTF-8编码等字符编码","uri":"/asciiunicode%E5%92%8Cutf-8/"},{"categories":["计算机基础"],"content":"五、UTF-8 互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。 UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 UTF-8 的编码规则很简单，只有二条： 1） 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 2） 对于n字节的符号（n \u003e 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 下表总结了编码规则，字母x表示可用编码的位。 Unicode符号范围（十六进制） UTF-8编码方式（二进制） 0000 0000-0000 007F 0xxxxxxx 0000 0080-0000 07FF 110xxxxx 10xxxxxx 0000 0800-0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。 下面，还是以汉字严为例，演示如何实现 UTF-8 编码。 严的 Unicode 是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此严的 UTF-8 编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，严的 UTF-8 编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。 ","date":"2020-09-16 11:37:37","objectID":"/asciiunicode%E5%92%8Cutf-8/:5:0","tags":["Unicode编码"],"title":"ASCII，Unicode，UTF-16 和 UTF-8编码等字符编码","uri":"/asciiunicode%E5%92%8Cutf-8/"},{"categories":["计算机基础"],"content":"六、Unicode 与 UTF-8 之间的转换 通过上一节的例子，可以看到严的 Unicode码 是4E25，UTF-8 编码是E4B8A5，两者是不一样的。它们之间的转换可以通过程序实现。 Windows平台，有一个最简单的转化方法，就是使用内置的记事本小程序notepad.exe。打开文件后，点击文件菜单中的另存为命令，会跳出一个对话框，在最底部有一个编码的下拉条。 里面有四个选项：ANSI，Unicode，Unicode big endian和UTF-8。 1）ANSI是默认的编码方式。对于英文文件是ASCII编码，对于简体中文文件是GB2312编码（只针对 Windows 简体中文版，如果是繁体中文版会采用 Big5 码）。 2）Unicode编码这里指的是notepad.exe使用的 UCS-2 编码方式，即直接用两个字节存入字符的 Unicode 码，这个选项用的 little endian 格式。 3）Unicode big endian编码与上一个选项相对应。我在下一节会解释 little endian 和 big endian 的涵义。 4）UTF-8编码，也就是上一节谈到的编码方法。 选择完\"编码方式\"后，点击\"保存\"按钮，文件的编码方式就立刻转换好了。 ","date":"2020-09-16 11:37:37","objectID":"/asciiunicode%E5%92%8Cutf-8/:6:0","tags":["Unicode编码"],"title":"ASCII，Unicode，UTF-16 和 UTF-8编码等字符编码","uri":"/asciiunicode%E5%92%8Cutf-8/"},{"categories":["计算机基础"],"content":"七、Little endian 和 Big endian（UTF-16LE 和 UTF-16BE） 上一节已经提到，UCS-2 格式可以存储 Unicode 码（码点不超过0xFFFF）。以汉字严为例，Unicode 码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，这就是 Big endian 方式；25在前，4E在后，这是 Little endian 方式。 这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-endian)敲开还是从小头(Little-endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。 第一个字节在前，就是\"大头方式\"（Big endian），第二个字节在前就是\"小头方式\"（Little endian）。 那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？ Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做\"零宽度非换行空格\"（zero width no-break space），用FEFF表示。这正好是两个字节，而且FF比FE大1。 如果一个文本文件的头两个字节是FE FF（UTF-16BE），就表示该文件采用大头方式；如果头两个字节是FF FE(UTF-16LE)，就表示该文件采用小头方式。 UTF-16, 要从代码里自动判断一个文件到底是UTF-16LE还是BE, 对于单纯的英文字符来说还比较好办, 但要有特殊字符, 图形符号, 汉字, 法文, 俄语, 火星语之类的话, 相信各位都很头痛吧, 所以, unicode组织引入了BOM的概念, 即byte order mark, 顾名思义, 就是表名这个文件到底是LE还是BE的。 UTF-16BE (big endian)：文件BOM是FE FF，文件采用大头方式。 UTF-16LE (little endian)：文件BOM是FF FE，文件采用小头方式。 UTF-8：文件BOM是EF BB BF，可有可无。 ","date":"2020-09-16 11:37:37","objectID":"/asciiunicode%E5%92%8Cutf-8/:7:0","tags":["Unicode编码"],"title":"ASCII，Unicode，UTF-16 和 UTF-8编码等字符编码","uri":"/asciiunicode%E5%92%8Cutf-8/"},{"categories":["计算机基础"],"content":"八、实例 下面，举一个实例。 打开\"记事本\"程序notepad.exe，新建一个文本文件，内容就是一个严字，依次采用ANSI，ANSI，Unicode，Unicode big endian和UTF-8编码方式保存。 然后，用文本编辑软件UltraEdit 中的\"十六进制功能\"，观察该文件的内部编码方式。 1）ANSI：文件的编码就是两个字节D1 CF，这正是严的 GB2312 编码，这也暗示 GB2312 是采用大头方式存储的。 2）Unicode：编码是四个字节FF FE 25 4E，其中FF FE表明是小头方式存储，真正的编码是4E25。 3）Unicode big endian（UTF-16BE）：编码是四个字节FE FF 4E 25，其中FE FF表明是大头方式存储。 4）UTF-8：编码是六个字节EF BB BF E4 B8 A5，前三个字节EF BB BF表示这是UTF-8编码，后三个E4B8A5就是严的具体编码，它的存储顺序与编码顺序是一致的。 附 StringHelper编码辅助工具 URL编码与解码原理 参考文章 字符编码笔记：ASCII，Unicode 和 UTF-8 UNICODE,GBK,UTF-8区别 ","date":"2020-09-16 11:37:37","objectID":"/asciiunicode%E5%92%8Cutf-8/:8:0","tags":["Unicode编码"],"title":"ASCII，Unicode，UTF-16 和 UTF-8编码等字符编码","uri":"/asciiunicode%E5%92%8Cutf-8/"},{"categories":["Unity Tool"],"content":" C# ByteHelper字节数组辅助工具 ,用来处理字节数组序列化及反序列化数据，比如处理网络通信数据，自定义的 ByteHelper.cs using System; using System.Text; using UnityEngine; namespace Codingriver { /// \u003csummary\u003e /// 字节辅助工具，System.BitConverter; /// 这里是大端模式读写的（BitConverter.IsLittleEndian检查大小端） /// 特别注意： C# char类型是双字节的！！！ /// \u003c/summary\u003e public static class ByteHelper { public static string ToHex(this byte b) { return b.ToString(\"X2\"); } public static string ToHex(this byte[] bytes) { StringBuilder stringBuilder = new StringBuilder(); foreach (byte b in bytes) { stringBuilder.Append(b.ToString(\"X2\")); } return stringBuilder.ToString(); } public static string ToHex(this byte[] bytes, string format) { StringBuilder stringBuilder = new StringBuilder(); foreach (byte b in bytes) { stringBuilder.Append(b.ToString(format)); } return stringBuilder.ToString(); } public static string ToHex(this byte[] bytes, int offset, int count) { StringBuilder stringBuilder = new StringBuilder(); for (int i = offset; i \u003c offset + count; ++i) { stringBuilder.Append(bytes[i].ToString(\"X2\")); } return stringBuilder.ToString(); } public static string ToStr(this byte[] bytes) { return Encoding.Default.GetString(bytes); } public static string ToStr(this byte[] bytes, int index, int count) { return Encoding.Default.GetString(bytes, index, count); } public static string Utf8ToStr(this byte[] bytes) { return Encoding.UTF8.GetString(bytes); } public static string Utf8ToStr(this byte[] bytes, int index, int count) { return Encoding.UTF8.GetString(bytes, index, count); } public static void WriteTo(this byte[] bytes, int offset, ulong num) { for (int i = 0; i \u003c sizeof(ulong); i++) bytes[offset + i] = (byte)(num \u003e\u003e (i * 8) \u0026 0xff); } public static void ReadTo(this byte[] bytes, int offset, out ulong num) { num = 0; for (int i = sizeof(ulong) - 1; i \u003e= 0; i--) num = (num \u003c\u003c 8) | bytes[offset + i]; } public static void WriteTo(this byte[] bytes, int offset, long num) { for (int i = 0; i \u003c sizeof(long); i++) bytes[offset + i] = (byte)(num \u003e\u003e (i * 8) \u0026 0xff); } public static void ReadTo(this byte[] bytes, int offset, out long num) { num = 0; for (int i = sizeof(long) - 1; i \u003e= 0; i--) num = (num \u003c\u003c 8) | bytes[offset + i]; } public static void WriteTo(this byte[] bytes, int offset, uint num) { bytes[offset] = (byte)(num \u0026 0xff); bytes[offset + 1] = (byte)((num \u0026 0xff00) \u003e\u003e 8); bytes[offset + 2] = (byte)((num \u0026 0xff0000) \u003e\u003e 16); bytes[offset + 3] = (byte)((num \u0026 0xff000000) \u003e\u003e 24); } public static void ReadTo(this byte[] bytes, int offset, out uint num) { num = 0; num = bytes[offset + 3]; num = (uint)((num \u003c\u003c 8) | bytes[offset + 2]); num = (uint)((num \u003c\u003c 8) | bytes[offset + 1]); num = (uint)((num \u003c\u003c 8) | bytes[offset]); } public static void WriteTo(this byte[] bytes, int offset, int num) { bytes[offset] = (byte)(num \u0026 0xff); bytes[offset + 1] = (byte)((num \u0026 0xff00) \u003e\u003e 8); bytes[offset + 2] = (byte)((num \u0026 0xff0000) \u003e\u003e 16); bytes[offset + 3] = (byte)((num \u0026 0xff000000) \u003e\u003e 24); } public static void ReadTo(this byte[] bytes, int offset, out int num) { num = 0; num = bytes[offset + 3]; num = (int)((num \u003c\u003c 8) | bytes[offset + 2]); num = (int)((num \u003c\u003c 8) | bytes[offset + 1]); num = (int)((num \u003c\u003c 8) | bytes[offset]); } public static void WriteTo(this byte[] bytes, int offset, byte num) { bytes[offset] = num; } public static void WriteTo(this byte[] bytes, int offset, short num) { bytes[offset] = (byte)(num \u0026 0xff); bytes[offset + 1] = (byte)((num \u0026 0xff00) \u003e\u003e 8); } public static void ReadTo(this byte[] bytes, int offset, out short num) { num = 0; num = bytes[offset + 1]; num = (short)((num \u003c\u003c 8) | bytes[offset]); } public static void WriteTo(this byte[] bytes, int offset, ushort num) { bytes[offset] = (byte)(num \u0026 0xff); bytes[offset + 1] = (byte)((num \u0026 0xff00) \u003e\u003e 8); } public static void ReadTo(this byte[] bytes, int offset, out ushort num) { num = 0; num = bytes[offset + 1]; num = (ushort)((num \u003c\u003c 8) | bytes[offset]); } public unsafe static void WriteTo(this byte[] bytes, int offset, float num) { byte* ptr = (byte*)\u0026num; fo","date":"2020-09-15 18:21:07","objectID":"/bytehelper%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/:0:0","tags":["Unity Tool"],"title":"【Unity Tool】 ByteHelper字节数组辅助工具","uri":"/bytehelper%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/"},{"categories":["Unity Tool"],"content":" C# Dumper遍历打印对象的所有变量和属性及变量和属性的值。将C#中字段和属性（包含set和get访问器的）都遍历出来及对应结构序列化成字符串 在对象调试的时候想查看一个对象的所有变量值包括公有变量和私有变量，都想打印出来，这里就提供将对象所有变量和值都序列化成字符串；使用C#的反射功能打印所有变量，建议在调试时可以使用，发布时屏蔽调用，增加效率。 例如protobuf和json对象等数据对象为了验证及查看数据，这样是很方便的 using System; using System.Collections; using System.Reflection; using System.Text; using UnityEngine; namespace Codingriver { public static class Dumper { private static readonly StringBuilder _text = new StringBuilder(\"\", 1024); private static void AppendIndent(int num) { _text.Append(' ', num); } /// \u003csummary\u003e /// /// \u003c/summary\u003e /// \u003cparam name=\"obj\"\u003e\u003c/param\u003e /// \u003cparam name=\"depth\"\u003e防止 stack overflow\u003c/param\u003e /// \u003cparam name=\"showField\"\u003e是否遍历字段\u003c/param\u003e private static void DoDump(object obj, int depth=100, bool showField = true) { if (obj == null) { _text.Append(\"null\"); _text.Append(\",\"); return; } if(depth ==0) { _text.Append(\"DEPTH_NULL,\"); return; } Type t = obj.GetType(); //repeat field if (obj is IList) { /* _text.Append(t.FullName); _text.Append(\",\"); AppendIndent(1); */ _text.Append(\"[\"); IList list = obj as IList; foreach (object v in list) { DoDump(v,depth, showField); } _text.Append(\"]\"); } else if (t.IsValueType) { _text.Append(obj); _text.Append(\",\"); AppendIndent(1); } else if (obj is string) { _text.Append(\"\\\"\"); _text.Append(obj); _text.Append(\"\\\"\"); _text.Append(\",\"); AppendIndent(1); } else if (obj is byte[]) { _text.Append(\"\\\"\"); _text.Append(Encoding.UTF8.GetString((byte[])obj)); _text.Append(\"\\\"\"); _text.Append(\",\"); AppendIndent(1); } else if (t.IsArray) { Array a = (Array)obj; _text.Append(\"[\"); for (int i = 0; i \u003c a.Length; i++) { _text.Append(i); _text.Append(\":\"); DoDump(a.GetValue(i), depth, showField); } _text.Append(\"]\"); } else if (t.IsClass) { _text.Append($\"\u003c{t.Name}\u003e\"); _text.Append(\"{\"); var props = t.GetProperties(BindingFlags.Public | BindingFlags.NonPublic |BindingFlags.Instance); if (props.Length \u003e 0) { foreach (PropertyInfo info in props) { _text.Append(info.Name); _text.Append(\":\"); object value = info.GetGetMethod().Invoke(obj, null); DoDump(value, depth-1, showField); } } var fields = t.GetFields(BindingFlags.Public |BindingFlags.NonPublic | BindingFlags.Instance); if (showField\u0026\u0026fields.Length \u003e 0) { foreach (FieldInfo info in fields) { _text.Append(info.Name); _text.Append(\":\"); object value = info.GetValue(obj); DoDump(value, depth-1, showField); } } _text.Append(\"}\"); } else { Debug.LogWarning(\"unsupport type: \" + t.FullName); _text.Append(obj); _text.Append(\",\"); AppendIndent(1); } } public static string DumpAsString(object obj, int depth = 100, bool showField = true, string hint = \"\") { _text.Clear(); _text.Append(hint); DoDump(obj,depth, showField); return _text.ToString(); } } } 测试案例： using System.Collections; using System.Collections.Generic; using UnityEngine; using Codingriver; public class DumperTest : MonoBehaviour { public class InnerTest { public class InnerA { string innerStr = \"my name is codingriver\"; int key = 99; } int a = 1; string b = \"hello\"; int[] arr = new int[] { 5, 76, 12 }; InnerA innerA = new InnerA(); } public class TestData { public string[] Sitekeys = new string[] { \"https://codingriver.github.io\", \"codingriver\" }; string name = \"codingriver\"; int m_Main = 1024; protected InnerTest obj = new InnerTest(); public int Main { get { return m_Main; } set { m_Main = value; } } } // Start is called before the first frame update void Start() { TestData data = new TestData(); Debug.Log(Dumper.DumpAsString(data)); } } 测试结果： \u003cTestData\u003e{Main:1024, Sitekeys:[\"https://codingriver.github.io\", \"codingriver\", ]name:\"codingriver\", m_Main:1024, obj:\u003cInnerTest\u003e{a:1, b:\"hello\", arr:[5, 76, 12, ]innerA:\u003cInnerA\u003e{innerStr:\"my name is codingriver\", key:99, }}} UnityEngine.Debug:Log(Object) DumperTest:Start() (at Assets/DumperTest.cs:48) ","date":"2020-09-14 21:19:48","objectID":"/%E9%81%8D%E5%8E%86%E6%89%93%E5%8D%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%9E%E6%80%A7/:0:0","tags":["Unity Tool"],"title":"【Unity Tool】 Dumper遍历打印对象的所有变量和属性","uri":"/%E9%81%8D%E5%8E%86%E6%89%93%E5%8D%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%9E%E6%80%A7/"},{"categories":["Unity编辑器"],"content":" MeshRenderer和SkinnedMeshRenderer在Inspector增加sortingLayerName和sortingOrder选项。 Unity的SortingLayer在MeshRenderer和SkinnedMeshRendererEditor中的Inspector面板不可以配置，而想要调整SortingLayer或者sortingOrder则需要在脚本中设置比如脚本的Awake或者Start，这样非常不灵活。 通过Hooker钩子修改Inspector的MeshRendererEditor和SkinnedMeshRendererEditor而达到SortingLayer参数暴露在编辑器中，这样可以直接修改了在物体的MeshRenderer和SkinnedMeshRenderer组件上，修改后的值自动存储在序列化数据里。 这里使用了一个Githubh的插件 MonoHook，请自行下载，然后导入到工程中。 首先需要下载MonoHook插件，导入到工程中，这里的代码需要依赖这个插件。 然后将文件RendererLayerEditor.cs和InitializeOnLoadTool.cs放入Editor目录下，这个是编辑器代码文件。 RendererLayerEditor.cs文件： using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEditor; using System; using System.Reflection; using UnityEditorInternal; public class RendererLayerEditor { public static void Register() { // MeshRendererEditor Type type = typeof(AssetDatabase).Assembly.GetType(\"UnityEditor.MeshRendererEditor\"); MethodInfo method = type.GetMethod(\"OnInspectorGUI\", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic); type = typeof(RendererLayerEditor); MethodInfo methodReplacement = type.GetMethod(\"SubRendererOnInspectorGUI\", BindingFlags.Static | BindingFlags.NonPublic); MethodInfo methodProxy = type.GetMethod(\"SubRendererOnInspectorGUIProxy\", BindingFlags.Static | BindingFlags.NonPublic); MethodHook hooker = new MethodHook(method, methodReplacement, methodProxy); hooker.Install(); // SkinnedMeshRendererEditor type = typeof(AssetDatabase).Assembly.GetType(\"UnityEditor.SkinnedMeshRendererEditor\"); method = type.GetMethod(\"OnInspectorGUI\", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic); type = typeof(RendererLayerEditor); methodReplacement = type.GetMethod(\"SubRendererOnInspectorGUI\", BindingFlags.Static | BindingFlags.NonPublic); methodProxy = type.GetMethod(\"SubRendererOnInspectorGUIProxyE\", BindingFlags.Static | BindingFlags.NonPublic); hooker = new MethodHook(method, methodReplacement, methodProxy); hooker.Install(); } static void SubRendererOnInspectorGUI(Editor editor) { //Debug.Log(editor.target); if (editor.target != null) { var renderer = editor.target as Renderer; var options = GetSortingLayerNames(); var picks = new int[options.Length]; //Debug.Log($\"renderer.sortingLayerName:{renderer.sortingLayerName},options.len:{options.Length}\"); var name = renderer.sortingLayerName; var choice = -1; for (int i = 0; i \u003c options.Length; i++) { picks[i] = i; if (name == options[i]) choice = i; } choice = EditorGUILayout.IntPopup(\"Sorting Layer\", choice, options, picks); string oldLayerName = renderer.sortingLayerName; renderer.sortingLayerName = options[choice]; int order = renderer.sortingOrder; renderer.sortingOrder = EditorGUILayout.IntField(\"Sorting Order\", renderer.sortingOrder); if(renderer.sortingOrder!=order||renderer.sortingLayerName!= oldLayerName) { EditorUtility.SetDirty(renderer); } if(editor.target is MeshRenderer) { SubRendererOnInspectorGUIProxy(editor); } else { SubRendererOnInspectorGUIProxyE(editor); } } } static void SubRendererOnInspectorGUIProxy(Editor editor) { } static void SubRendererOnInspectorGUIProxyE(Editor editor) { } public static string[] GetSortingLayerNames() { //SortingLayer.layers Type internalEditorUtilityType = typeof(InternalEditorUtility); PropertyInfo sortingLayersProperty = internalEditorUtilityType.GetProperty(\"sortingLayerNames\", BindingFlags.Static | BindingFlags.NonPublic); return (string[])sortingLayersProperty.GetValue(null, new object[0]); } } MonoHook插件需要打开unsafe宏定义，Build Setting–\u003ePlayer Setting–\u003e 勾选 Allow unsafe Code 如图： InitializeOnLoadTool.cs文件： using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEditor; using System; using System.Reflection; using UnityEditorInternal; [InitializeOnLoad] // 最好Editor启动及重新编译完毕就执行 public class InitializeOnLoadTool { static bool register = false; static InitializeOnLoadTool() { if (!register) { RendererLayerEditor.Register(); register =true; } } } 效果： MeshRenderer SkinnedMeshRenderer Githuh工程 ","date":"2020-09-14 20:55:09","objectID":"/meshrenderer%E5%9C%A8inspector%E8%AE%BE%E7%BD%AEsorttinglayername%E5%92%8Csorttingorder/:0:0","tags":["Unity编辑器"],"title":"【Unity编辑器】MeshRenderer和SkinnedMeshRenderer在Inspector增加sortingLayer选项","uri":"/meshrenderer%E5%9C%A8inspector%E8%AE%BE%E7%BD%AEsorttinglayername%E5%92%8Csorttingorder/"},{"categories":["Unity编辑器"],"content":" unity editor当使用SerializedObject.FindProperty(\"属性名\")获取SerializedProperty时，特别是获取私有变量时，我们不知道变量名字，基本靠公有变量转私有变量猜测变量名字来读取，这样可能有错误的情况，所以这里给出遍历打印所有属性的方法，用以排解这种问题！ 另一种说法： SerializedProperty遍历SerializedObject的target的所有属性。 SerializedObject.FindProperty(\"属性名\")的强大之处是可以获取私有变量。 ","date":"2020-09-14 20:20:28","objectID":"/serializedobject%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7/:0:0","tags":["Unity编辑器"],"title":"【Unity编辑器】 SerializedObject获取所有属性（SerializedProperty）","uri":"/serializedobject%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7/"},{"categories":["Unity编辑器"],"content":"使用SerializedProperty迭代器遍历对象所有属性 using UnityEngine; using UnityEditor; using System.Reflection; public class TraversePropertyEditor { // Start is called before the first frame update /// \u003csummary\u003e /// https://forum.unity.com/threads/access-lighting-window-properties-in-script.328342/ /// \u003c/summary\u003e /// \u003creturns\u003e\u003c/returns\u003e public static SerializedObject GetLighmapSettings() { var getLightmapSettingsMethod = typeof(LightmapEditorSettings).GetMethod(\"GetLightmapSettings\", BindingFlags.Static | BindingFlags.NonPublic); LightmapSettings lightmapSettings = getLightmapSettingsMethod.Invoke(null, null) as LightmapSettings; return new SerializedObject(lightmapSettings); } [MenuItem(\"Tools/TraverseProperty\")] /// \u003csummary\u003e /// SerializedProperty遍历SerializedObject对象的所有属性 /// \u003c/summary\u003e public static void TraversePropertyNames() { SerializedObject so = GetLighmapSettings(); SerializedProperty prop = so.GetIterator(); //获取SerializedProperty迭代器 Debug.Log(\"-----\u003e\u003e\" + prop.serializedObject.targetObject.GetType().FullName);//获取target的类名（class名字） while (prop.Next(true)) { Debug.Log(prop.name); } //SerializedProperty sp = so.FindProperty(\"m_LightmapEditorSettings\"); //根据获取的name通过FindProperty获取该变量， } } 输出: ","date":"2020-09-14 20:20:28","objectID":"/serializedobject%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7/:1:0","tags":["Unity编辑器"],"title":"【Unity编辑器】 SerializedObject获取所有属性（SerializedProperty）","uri":"/serializedobject%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7/"},{"categories":["Unity编辑器"],"content":"使用SerializedProperty迭代器遍历对象及属性对象的子属性 [MenuItem(\"Tools/TraverseProperty\")] /// \u003csummary\u003e /// SerializedProperty遍历SerializedObject对象的所有属性及子属性 /// \u003c/summary\u003e public static void TraversePropertyNames() { SerializedObject so = GetLighmapSettings(); SerializedProperty sp = so.FindProperty(\"m_LightmapEditorSettings\"); var prop = so.GetIterator(); while (prop.Next(true)) { Debug.Log(prop.name + \" depth=\" + prop.depth + \" hasChildren=\" + prop.hasChildren); } } 比如我们想得到：m_AtlasSize这个属性： public static void TraversePropertyNames() { SerializedObject so = GetLighmapSettings(); SerializedProperty sp = so.FindProperty(\"m_LightmapEditorSettings\"); var prop = so.GetIterator(); while (prop.Next(true)) { //Debug.Log(prop.name + \" depth=\" + prop.depth + \" hasChildren=\" + prop.hasChildren); } sp = so.FindProperty(\"m_LightmapEditorSettings.m_AtlasSize\"); Debug.LogError(sp.name); } 参考文章： SerializedProperty的属性名获取 ","date":"2020-09-14 20:20:28","objectID":"/serializedobject%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7/:2:0","tags":["Unity编辑器"],"title":"【Unity编辑器】 SerializedObject获取所有属性（SerializedProperty）","uri":"/serializedobject%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7/"},{"categories":["个人记录"],"content":"如何开始用 C++ 写一个光栅化渲染器？ bilibili的 GAMES101-现代计算机图形学入门-闫令琪 庄懂-BoyanTata 第二节没有完成 （屏幕空间使用，及素描风格） 庄懂公开课资源 ","date":"2020-09-14 14:10:25","objectID":"/shader%E8%AE%B0%E5%BD%95/:0:0","tags":[],"title":"Shader记录","uri":"/shader%E8%AE%B0%E5%BD%95/"},{"categories":["个人记录"],"content":"学习课程中的问题 z缓冲消隐算法 (投影矩阵提到) Mapcap昆虫最后的颜色为啥是相乘和相加？（第一章第四节） 视差贴图，视差映射 ，视差偏移没有仔细学习（第二章第二节）。 绕y轴旋转的旋转矩阵怎么写是对的，需要和unity Transform旋转一致（第三章第一节 Cubemap旋转） https://wgqing.com/unity%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%BB%8E%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E5%88%B0%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/ 次表面散射，Skin_LUT （第四章第二节），皮肤阴影区域的SSS效果调整不理想 屏幕后处理，添加玻璃破碎效果，屏幕适配失败，不同分辨率时破碎效果不能保持居中（第五章第一节第二课题，BrokenGlass） 火焰形状扰动后输出异常 （第六章第一节） 动画纹理（VAT）,（第六章第三节），(需要Hodini) FlowMap的意义，案例中使用FlowMap没有看出效果在哪,（第六章第三节） 宝石自发光，光晕效果（第八章） ","date":"2020-09-14 14:10:25","objectID":"/shader%E8%AE%B0%E5%BD%95/:0:1","tags":[],"title":"Shader记录","uri":"/shader%E8%AE%B0%E5%BD%95/"},{"categories":["个人记录"],"content":"水体渲染 水体颜色 根据水底的深度计算（获取深度图）区分浅水区和深水区得到颜色 反射 根据PlanarReflection获取 _ReflectionTex纹理，然后使用屏幕空间作为UV进行采样（使用水的法线贴图进行扰动uv），得到反射颜色；增加菲涅尔效果 折射/水底 使用grabPass获取屏幕颜色，然后使用屏幕空间作为UV进行采样（使用水的法线贴图进行扰动UV），得到折射的颜色 焦散 使用深度还原的世界坐标作为UV采样焦散纹理，采样两次取两次的最小值 （应该可以使用默认UV进行采样） 岸边泡沫 使用根据time使用sin波向岸边推送波浪模拟的泡沫，使用一个noise进行扰动，需要处理遮罩 保证只在岸边有泡沫 波浪（Wave）（顶点动画） 正弦/余弦 格斯特纳波（Gerstner） ","date":"2020-09-14 14:10:25","objectID":"/shader%E8%AE%B0%E5%BD%95/:0:2","tags":[],"title":"Shader记录","uri":"/shader%E8%AE%B0%E5%BD%95/"},{"categories":["shader"],"content":"一、CG和GLSL常用函数 ","date":"2020-09-14 13:15:46","objectID":"/unityshader%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:0","tags":["shader"],"title":"【Shader】 常用函数（UnityShader内置函数、CG和GLSL内置函数等）和内置变量","uri":"/unityshader%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["shader"],"content":"CG语言中的变量修饰符 修饰符 解析 const 变量被定义成常量的话，在程序中，就不能再对该变量赋值，除非const和uniform，varying一起使用。const修饰的变量，需要在声明时给予一个初始值 extern extern表明声明仅仅是声明，而非定义。在程序中一定有一个地方存在一个非extern的对应的声明 in 只在声明参数，或是使用varying修饰符时使用。将参数，或是varying作为函数或是程序的输入值。函数参数如果没有in，out，或者inout的话，隐式的默认为in inline 只在函数定义时有用，告诉编译器始终对该函数采取内联调用 inout 只在声明为参数和varying时使用，将参数或是varying声明为函数或是程序的输入输出值 static 只在声明全局变量时使用，static将使变量对程序而言成为私有的，外部不可见，不能和uniform，varying一起使用 out 只在声明参数和varying时使用，将变量或varying定义为函数或是程序的输出值 uniform 用于全局变量和程序的入口函数的参数，用来定义constant buffers(常量缓存)。如果用于一个非入口函数的参数，它将被忽略。这样做的目的是为了使一个函数既能作为入口函数，又能作为非入口函数。uniform的变量可以像非uniform的变量那样读写。uniform修饰符通过向外部语言提供一个机制，来提供变量的初始值是如何指定和保存的信息。 ","date":"2020-09-14 13:15:46","objectID":"/unityshader%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:1","tags":["shader"],"title":"【Shader】 常用函数（UnityShader内置函数、CG和GLSL内置函数等）和内置变量","uri":"/unityshader%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["shader"],"content":"1、数学函数 CG语言 GLSL语言 功能描述 ceil(x) ceil(x) 对输入参数向上取整。例如： ceil(float(1.3)) ，其返回值为2.0 floor(x) floor(x) 对输入参数向下取整。例如floor(float(1.3))返回的值为1.0；但是floor(float(-1.3))返回的值为-2.0。该函数与ceil(x)函数相对应。 fmod(x,y) mod(x, y) 返回x/y的余数。如果y为0，结果不可预料。 frac(x) fract(x) 返回标量或矢量的小数 frexp(x, out i) 将浮点数 x 分解为尾数和指数，即 x = m* 2^exp，返回 m，并将指数存入 exp 中；如果 x 为 0，则尾数和指数都返回 0 modf(x, out ip) 把x分解成整数和分数两部分，每部分都和x有着相同的符号，整数部分被保存在ip中，分数部分由函数返回 round(x) 返回四舍五入值。 exp(x) exp(x) 计算e x 的值，e=2.71828182845904523536 exp2(x) exp2(x) 计 算 2 x 的 值 log(x) log(x) 计 算 ln ⁡ ( x ) 的 值 ， x 必 须 大 于 0 log2(x) log2(x) 计 算 log ⁡ 2 ( x ) 的 值 ， x 必 须 大 于 0 log10(x) 计 算 lg ⁡ ( x ) 的 值 ， x 必 须 大 于 0 max(a, b) max(a, b) 比较两个标量或等长向量元素，返回最大值。 min(a,b) min(a,b) 比较两个标量或等长向量元素，返回最小值。 pow(x, y) pow(x, y) 计 算 x y 的 值 sqrt(x) sqrt(x) 求x的平方根，，x必须大于0 rsqrt(x) inversesqrt(x) x的平方根的倒数，x必须大于0 abs(x) abs(x) 返回输入参数的绝对值 ldexp(x, n) 计 算 x ∗ 2 n 的 值 mul(M, N) M*N 矩阵M和矩阵N的积 mul(M, v) M*v 矩阵M和列向量v的积 mul(v, M) v* M 行向量v和矩阵M的积 determinant(m) 计算矩阵的行列式因子。 transpose(M) 矩阵M的转置矩阵 如果M是一个AxB矩阵，M的转置是一个BxA矩阵，它第一列是M的第一行，第二列是M的第二行，第三列是M的第三行，等等 asin(x) asin(x) 反正弦函数,输入参数取值区间为，返回角度值范围为[−π/2,π/2] acos(x) acos(x) 反余切函数，输入参数范围为[-1,1]， 返回[0,π]区间的角度值 atan(x) atan(x) 反正切函数，返回角度值范围为[−π/2,π/2] atan2(y,x) atan2(y,x) 计算y/x的反正切值。实际上和atan(x)函数功能完全一样，至少输入参数不同。atan(x) = atan2(x, float(1))。 sin(x) sin(x) 输入参数为弧度，计算正弦值，返回值范围 为[-1,1] cos(x) cos(x) 返回弧度x的余弦值。返回值范围为 tan(x) tan(x) 计算x正切值 sincos(float x, out s, out c) 该函数是同时计算x的sin值和cos值，其中s=sin(x)，c=cos(x)。该函数用于“同时需要计算sin值和cos值的情况”，比分别运算要快很多! sinh(x) 计算x的双曲正弦 cosh(x) 双曲余弦（hyperbolic cosine）函数，计算x的双曲余弦值。 tanh(x) 计算x的双曲线切线 radians(x) radians(x) 函数将角度值转换为弧度值 degrees(x) degrees(x) 输入参数为弧度值(radians)，函数将其转换为角度值(degrees) cross(A,B) cross(A,B) 返回两个三元向量的叉积(cross product)。注意，输入参数必须是三元向量！ lit(NdotL, NdotH, m) 函数计算环境光、散射光、镜面光的贡献，返回的4元向量。 N表示法向量； L表示入射光向量； H表示半角向量； m表示高光系数。 X位表示环境光的贡献，总是1.0; Y位代表散射光的贡献，如果 N∙L\u003c0，则为0；否则为N∙L Z位代表镜面光的贡献，如果N∙L\u003c0 或者N∙H \u003c 0，则位0；否则为(N∙L)m; W位始终位1.0 all(x) all(x) 如果输入参数均不为0，则返回ture； 否则返回flase。\u0026\u0026运算 any(x) any(x) 输入参数只要有其中一个不为0，则返回true。 isfinite(x) 判断标量或者向量中的每个数据是否是有限数，如果是返回true；否则返回false; isinf(x) 判断标量或者向量中的每个数据是否是无限，如果是返回true；否则返回false; isnan(x) 判断标量或者向量中的每个数据是否是非数据(not-a-number NaN)，如果是返回true；否则返回false; step(a, x) step(a, x) 如果x\u003ca, 返回0；否则返回1 sign(x) sign(x) 如果x\u003e0则返回1；如果x=0返回0；如果x\u003c0则返回-1 dot(A,B) dot(A,B) 返回A和B的点积(dot product)。参数A和B可以是标量，也可以是向量（输入参数方面，点积和叉积函数有很大不同）。 noise(x) 根据它的参数类型，这个函数可以是一元、二元或三元噪音函数。返回的值在0和1之间，并且通常与给定的输入值一样 clamp(x,a,b) clamp(x,a,b) 如果x值小于a，则返回a； 如果x值大于b，返回b； 否则，返回x。 lerp(a, b, f) mix(a, b, f) 计算或者的值。即在下限a和上限b之间进行插值，f表示权值。注意，如果a和b是向量，则权值f必须是标量或者等长的向量。 saturate(x) 把x限制到[0,1]之间 smoothstep(min, max, x) smoothstep(min, max, x) 值x位于min、max区间中。 如果x=min，返回0；如果x=max，返回1； 如果x在两者之间，按照下列公式返回数据： – 2 ∗ ( ( x – m i n ) / ( m a x – m i n ) ) 3 + 3 ∗ ( ( x – m i n ) / ( m a x – m i n ) ) 2 smoothstep(min, max, x)对于参数全是float的重载 float smoothstep(float a, float b, float x) { float t = saturate((x - a)/(b - a)); return t*t*(3.0 - (2.0*t)); } ","date":"2020-09-14 13:15:46","objectID":"/unityshader%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:2","tags":["shader"],"title":"【Shader】 常用函数（UnityShader内置函数、CG和GLSL内置函数等）和内置变量","uri":"/unityshader%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["shader"],"content":"2、几何函数 CG语言 GLSL语言 功能描述 distance(pt1, pt2) distance(pt1, pt2) 两点之间的欧几里德距离（Euclidean distance） faceforward(N,I,Ng) faceforward(N,I,Ng) 根据 矢量 N 与Nref 调整法向量,如果Ng•I \u003c 0 ，返回 N；否则返回-N。 length(v) length(v) 返回一个向量的模，即sqrt(dot(v,v)) normalize(v) normalize(v) 返回v向量的单位向量 reflect(I, N) reflect(I, N) 根据入射光方向向量 I，和顶点法向量 N，计算反射光方向向量。 其中 I 和 N 必须被归一化，需要非常注意的是，这个 I 是指向顶点的； 函数只对三元向量有效 refract(I,N,eta) refract(I,N,eta) 计算折射向量，I 为入射光线，N 为法向量，eta 为折射系数； 其中 I 和 N 必须被归一化，如果 I 和 N 之间的夹角太大，则返回（0，0，0），也就是没有折射光线；I 是指向顶点的；函数只对三元向量有效 ","date":"2020-09-14 13:15:46","objectID":"/unityshader%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:3","tags":["shader"],"title":"【Shader】 常用函数（UnityShader内置函数、CG和GLSL内置函数等）和内置变量","uri":"/unityshader%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["shader"],"content":"3、纹理映射函数 CG语言 功能描述 tex1D(sampler1D tex, float s) 一维纹理查询 tex1D(sampler1D tex, float s, float dsdx, float dsdy) 使用导数值（derivatives）查询一维纹理 Tex1D(sampler1D tex, float2 sz) 一维纹理查询，并进行深度值比较 Tex1D(sampler1D tex, float2 sz, float dsdx,float dsdy) 使用导数值（derivatives）查询一维纹理， 并进行深度值比较 Tex1Dproj(sampler1D tex, float2 sq) 一维投影纹理查询 Tex1Dproj(sampler1D tex, float3 szq) 一维投影纹理查询，并比较深度值 Tex2D(sampler2D tex, float2 s) 二维纹理查询 Tex2D(sampler2D tex, float2 s, float2 dsdx, float2 dsdy) 使用导数值（derivatives）查询二维纹理 Tex2D(sampler2D tex, float3 sz) 二维纹理查询，并进行深度值比较 Tex2D(sampler2D tex, float3 sz, float2 dsdx,float2 dsdy) 使用导数值（derivatives）查询二维纹理，并进行深度值比较 Tex2Dproj(sampler2D tex, float3 sq) 二维投影纹理查询 Tex2Dproj(sampler2D tex, float4 szq) 二维投影纹理查询，并进行深度值比较 texRECT(samplerRECT tex, float2 s) 二维非投影矩形纹理查询（OpenGL独有） texRECT (samplerRECT tex, float3 sz, float2 dsdx,float2 dsdy) 二维非投影使用导数的矩形纹理查询（OpenGL独有） texRECT (samplerRECT tex, float3 sz) 二维非投影深度比较矩形纹理查询（OpenGL独有） texRECT (samplerRECT tex, float3 sz, float2 dsdx,float2 dsdy) 二维非投影深度比较并使用导数的矩形纹理查询（OpenGL独有） texRECT proj(samplerRECT tex, float3 sq) 二维投影矩形纹理查询（OpenGL独有） texRECT proj(samplerRECT tex, float3 szq) 二维投影矩形纹理深度比较查询（OpenGL独有） Tex3D(sampler3D tex, float s) 三维纹理查询 Tex3D(sampler3D tex, float3 s, float3 dsdx, float3 dsdy) 结合导数值（derivatives）查询三维纹理 Tex3Dproj(sampler3D tex, float4 szq) 查询三维投影纹理，并进行深度值比较 texCUBE(samplerCUBE tex, float3 s) 查询立方体纹理 texCUBE (samplerCUBE tex, float3 s, float3 dsdx, float3 dsdy) 结合导数值（derivatives）查询立方体纹理 texCUBEproj (samplerCUBE tex, float4 sq) 查询投影立方体纹理 ","date":"2020-09-14 13:15:46","objectID":"/unityshader%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:4","tags":["shader"],"title":"【Shader】 常用函数（UnityShader内置函数、CG和GLSL内置函数等）和内置变量","uri":"/unityshader%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["shader"],"content":"4、偏导函数 函数 功能描述 ddx(a) 近似a关于屏幕空间x轴的偏导数 ddy(a) 近似a关于屏幕空间y轴的偏导数 ","date":"2020-09-14 13:15:46","objectID":"/unityshader%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:5","tags":["shader"],"title":"【Shader】 常用函数（UnityShader内置函数、CG和GLSL内置函数等）和内置变量","uri":"/unityshader%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["shader"],"content":"二、Unity常用的内置函数，变量 ","date":"2020-09-14 13:15:46","objectID":"/unityshader%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:2:0","tags":["shader"],"title":"【Shader】 常用函数（UnityShader内置函数、CG和GLSL内置函数等）和内置变量","uri":"/unityshader%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["shader"],"content":"1、Unity常用的结构体 1.1、顶点着色器输入 名称 描述 包含的变量 appdata_base 用于顶点着色器输入 顶点位置、顶点法线、第一组纹理坐标 appdata_tan 用于顶点着色器输入 顶点位置、顶点切线、顶点法线、第一组纹理坐标 appdata_full 用于顶点着色器输入 顶点位置、顶点切线、顶点法线、四组（或更多）纹理坐标 appdata_img 用于顶点着色器输入 顶点位置、第一组纹理坐标 struct appdata_base { float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; UNITY_VERTEX_INPUT_INSTANCE_ID }; struct appdata_tan { float4 vertex : POSITION; float4 tangent : TANGENT; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; UNITY_VERTEX_INPUT_INSTANCE_ID }; struct appdata_full { float4 vertex : POSITION; float4 tangent : TANGENT; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; float4 texcoord1 : TEXCOORD1; float4 texcoord2 : TEXCOORD2; float4 texcoord3 : TEXCOORD3; fixed4 color : COLOR; UNITY_VERTEX_INPUT_INSTANCE_ID }; struct appdata_img { float4 vertex : POSITION; half2 texcoord : TEXCOORD0; UNITY_VERTEX_INPUT_INSTANCE_ID }; 1.2、顶点着色器输出 名称 描述 包含的变量 v2f_img 用于顶点着色器输出 裁剪空间中的位置、纹理坐标 struct v2f_img { float4 pos : SV_POSITION; half2 uv : TEXCOORD0; UNITY_VERTEX_INPUT_INSTANCE_ID UNITY_VERTEX_OUTPUT_STEREO }; ","date":"2020-09-14 13:15:46","objectID":"/unityshader%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:2:1","tags":["shader"],"title":"【Shader】 常用函数（UnityShader内置函数、CG和GLSL内置函数等）和内置变量","uri":"/unityshader%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["shader"],"content":"2、空间变换函数及内置变量 A、空间变换函数 函数名 描述 float4 UnityWorldToClipPos(float3 pos ) 把世界坐标空间中某一点pos变换到齐次裁剪空间 float4 UnityViewToClipPos(float3 pos ) 把观察坐标空间中某一点pos变换到齐次裁剪空间 float3 UnityObjectToViewPos(float3 pos或float4 pos) 模型局部空间坐标系中某一个点pos变换到观察空间坐标系 float3 UnityWorldToViewPos(float3 pos ) 把世界坐标系下的一个点pos变换到观察空间坐标系 float3 UnityObjectToWorldDir(float3 dir ) 把方向矢量从模型空间转换到世界空间（方向已单位化） float3 UnityWorldToObjectDir(float3 dir ) 把方向矢量从世界空间转换到模型空间（方向已单位化） float3 UnityObjectToWorldNormal(float3 norm ) 将法线从模型空间转换到世界空间（方向已单位化） float3 UnityWorldSpaceLightDir(float3 worldPos ) 输入参数worldPos是一个世界坐标系下的坐标，得到世界空间中从该点到光源（_WorldSpaceLightPos0）的光照方向。（方向没单位化） float3 WorldSpaceLightDir(float4 localPos ) 输入一个模型顶点坐标，得到世界空间中从该点到光源（_WorldSpaceLightPos0）的光照方向。（方向没单位化） float3 ObjSpaceLightDir(float4 v ) 输入一个模型顶点坐标，得到模型空间中从该点到光源（_WorldSpaceLightPos0）的光照方向。（方向没单位化） float3 UnityWorldSpaceViewDir(float3 worldPos ) 输入参数worldPos是一个世界坐标系下的坐标，得到世界空间中从该点到摄像机的观察方向。（方向没单位化） float3 WorldSpaceViewDir(float4 localPos ) 输入一个模型顶点坐标，得到世界空间中从该点到摄像机的观察方向。（方向没单位化） float3 ObjSpaceViewDir(float4 v ) 输入一个模型顶点坐标，得到模型空间中从该点到摄像机的观察方向。（方向没单位化） B、屏幕空间相关函数 以下函数可计算用于采样屏幕空间纹理的坐标。它们返回 float4，其中用于纹理采样的最终坐标可以通过透视除法（例如 xy/w）计算得出。 函数名 描述 float4 ComputeScreenPos (float4 clipPos) 计算用于执行屏幕空间贴图纹理采样的纹理坐标。输入是裁剪空间位置。 float4 ComputeGrabScreenPos (float4 clipPos) 计算用于 GrabPass 纹理采样的纹理坐标。输入是裁剪空间位置。 C、内置变量矩阵 变量名 描述 UNITY_MATRIX_MVP 当前的模型观察投影矩阵，用于将顶点/方向矢量从模型空间转换到裁剪空间 UNITY_MATRIX_MV 当前的模型*观察矩阵，用于将顶点/方向矢量从模型空间转换到观察空间 UNITY_MATRIX_V 当前的观察矩阵，用于将顶点/方向矢量从世界空间转换到观察空间 UNITY_MATRIX_I_V 当前的观察矩阵的逆矩阵，用于从观察空间转换到世界空间 UNITY_MATRIX_P 当前的投影矩阵，用于将顶点/方向矢量从观察空间转换到裁剪空间 UNITY_MATRIX_VP 当前的观察*投影矩阵，用于将顶点/方向矢量从世界空间转换到裁剪空间 UNITY_MATRIX_T_MV UNITY_MATRIX_MV的转置矩阵 UNITY_MATRIX_IT_MV UNITY_MATRIX_MV的逆转置矩阵，用于将发现从模型空间转换到观察空间，也可以用于得到UNITY_MATRIX_MV的逆矩阵 unity_MatrixInvV UNITY_MATRIX_V的逆矩阵 D、摄像机和屏幕参数 参数名 描述 float3 _WorldSpaceCameraPos 该摄像机在世界空间中的位置 float4 _ProjectionParams x=1.0(或-1.0，如果正在使用一个翻转的投影矩阵进行渲染)，y=Near,z=Far,w=1.0+1.0/Far,其中Near和Far分别是近裁剪平面和远裁剪平面到摄像机的距离 float4 _ScreenParams x=width,y=height,z=1.0+1.0/width,w=1.0+1.0/height,其中width和height分别是该摄像机的渲染目标（render target）的像素宽度和高度 float4 _ZBufferParams x=1-Far/Near,y=Far/Near,z=x/Far,w=y/Far,该变量用于线性化Z缓存中的深度值 float4 unity_OrthoParams x=width,y=height,z没有定义,w=1.0(该摄像机是正交摄像机)或w=0.0（该摄像机是透视摄像机），其中width和height是正交投影摄像机的宽度和高度 float4x4 unity_CameraProjection 该摄像机的投影矩阵 float4x4 unity_CameraInvProjection 该摄像机的投影矩阵的逆矩阵 float4 unity_CameraWorldClipPlanes[6] 该摄像机的6个裁剪平面在世界空间下的等式，按左、右、下、上、近、远裁剪平面 E、时间变量 名称 类型 值 _Time float4 自关卡加载以来的时间 (t/20, t, t2, t3)，用于将着色器中的内容动画化。 _SinTime float4 时间正弦：(t/8, t/4, t/2, t)。 _CosTime float4 时间余弦：(t/8, t/4, t/2, t)。 unity_DeltaTime float4 增量时间：(dt, 1/dt, smoothDt, 1/smoothDt)。 F、光照变量 参考unity官方文档：内置着色器变量 G、雾效和环境光 名称 类型 值 unity_AmbientSky fixed4 梯度环境光照情况下的天空环境光照颜色。 unity_AmbientEquator fixed4 梯度环境光照情况下的赤道环境光照颜色。 unity_AmbientGround fixed4 梯度环境光照情况下的地面环境光照颜色。 UNITY_LIGHTMODEL_AMBIENT fixed4 环境光照颜色（梯度环境情况下的天空颜色）。旧版变量。 unity_FogColor fixed4 雾效颜色。 unity_FogParams float4 用于雾效计算的参数：(density / sqrt(ln(2))、density / ln(2)、–1/(end-start) 和 end/(end-start))。x 对于 Exp2 雾模式很有用；y 对于 Exp 模式很有用，z 和 w 对于 Linear 模式很有用。 H、其他 名称 类型 值 unity_LODFade float4 使用 LODGroup 时的细节级别淡入淡出。x 为淡入淡出（0 到 1），y 为量化为 16 级的淡入淡出，z 和 w 未使用。 _TextureSampleAdd float4 根据所使用的纹理是 Alpha8 格式（值设置为 (1,1,1,0)）还是不是该格式（值设置为 (0,0,0,0)）由 Unity 仅针对 UI 自动设置。 ","date":"2020-09-14 13:15:46","objectID":"/unityshader%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:2:2","tags":["shader"],"title":"【Shader】 常用函数（UnityShader内置函数、CG和GLSL内置函数等）和内置变量","uri":"/unityshader%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["shader"],"content":"3、数学常数 #ifndef UNITY_CG_INCLUDED #define UNITY_CG_INCLUDED #define UNITY_PI 3.14159265359f //圆周率 #define UNITY_TWO_PI 6.28318530718f //2倍圆周率 #define UNITY_FOUR_PI 12.56637061436f //4倍圆周率 #define UNITY_INV_PI 0.31830988618f //圆周率的倒数 #define UNITY_INV_TWO_PI 0.15915494309f //2倍圆周率的倒数 #define UNITY_INV_FOUR_PI 0.07957747155f //4倍圆周率的倒数 #define UNITY_HALF_PI 1.57079632679f //半圆周率 #define UNITY_INV_HALF_PI 0.636619772367f //半圆周率的倒数 ","date":"2020-09-14 13:15:46","objectID":"/unityshader%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:2:3","tags":["shader"],"title":"【Shader】 常用函数（UnityShader内置函数、CG和GLSL内置函数等）和内置变量","uri":"/unityshader%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["shader"],"content":"4、与颜色空间相关 函数名 描述 bool IsGammaSpace() 根据宏UNITY_COLORSPACE_GAMMA是否被启用了，判断当前是否启用了伽马颜色空间。 float GammaToLinearSpaceExact (float value) 把一个颜色值精确地从伽马颜色空间(sRGB颜色空间)变化到线性空间(CIE-XYZ颜色空间)。 half3 GammaToLinearSpace (half3 sRGB) 用一个近似模拟的函数把颜色值近似地从伽马空间变换到线性空间。 float LinearToGammaSpaceExact (float value) 把一个颜色值精确地从线性空间变换到伽马颜色空间。 half3 LinearToGammaSpace (half3 linRGB) 用一个近似模拟的函数把颜色值近似地从线性空间变换到伽马颜色空间。 引用：UnityShader常用函数（UnityShader内置函数、CG和GLSL内置函数等） unity官方文档：内置着色器变量 ","date":"2020-09-14 13:15:46","objectID":"/unityshader%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:2:4","tags":["shader"],"title":"【Shader】 常用函数（UnityShader内置函数、CG和GLSL内置函数等）和内置变量","uri":"/unityshader%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["数据结构"],"content":" 可视化工具及动画展示：旧金山大学 (usfca)|数据结构可视化工具 排序算法概念及描述：1.0 十大经典排序算法（文章部分内容引用自改文章） 参考：邓俊辉 的数据结构 本文未对排序算法概念进行详细说明，只是提供已经验证过的代码及对算法核心进行简要说明 常用八种排序算法： 插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序 · 全部代码（github） C#版本 ","date":"2020-09-03 21:57:56","objectID":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/:0:0","tags":["数据结构","排序算法"],"title":"【数据结构】 十大经典排序算法及比较与分析 ( 动画演示 ) ( 可视化工具 )","uri":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["数据结构"],"content":"0X00 前言 排序算法是《数据结构与算法》中最基本的算法之一。 排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括： 关于时间复杂度 平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。 线性对数阶 (O(nlog2n)) （ log2n 是以2为底数的n的对数）排序： 快速排序、堆排序和归并排序； O(n1+§)) 排序 ( § 是介于 0 和 1 之间的常数 )： 希尔排序 线性阶 (O(n)) 排序： 基数排序，此外还有桶、箱排序。 关于稳定性 稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。 不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。 名词解释： n：数据规模 k：“桶\"的个数 In-place：占用常数内存，不占用额外内存 Out-place：占用额外内存 稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同 ","date":"2020-09-03 21:57:56","objectID":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/:0:1","tags":["数据结构","排序算法"],"title":"【数据结构】 十大经典排序算法及比较与分析 ( 动画演示 ) ( 可视化工具 )","uri":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["数据结构"],"content":"0X01 冒泡排序(起泡排序) 可视化工具及动画演示 /// \u003csummary\u003e /// 冒泡排序（A版本） /// 从后往前扫描待排序序列，如果前一个元素比后一个元素大，就交换它们两个，对每一对相邻元素作同样的工作；这样，第一次扫描待排序的序列会找到一个最小值并将其放置在第一位，第二次扫描待排序的序列会找到一个第二小的值并将其放置在第二位，第三次扫描待排序的序列会找到一个第三小的值并将其放置在第三位，以此类推，直到将所有元素排序完毕；排序的过程就像泡泡不断的往上冒，总是小的泡泡在最上面，大的泡泡在最下面。 /// 时间复杂度： /// 双层循环次数：内循环次数 i=0(n-1),i=1(n-2),i=2(n-3),...,i=n-3(2),i=n-2(1)为等差数列，总次数=n*(0+n-1)/2=n*(n-1)/2 /// 假设每次比较都需要交换，执行内循环一次时复杂度为2（比较一次+交换一次），所以复杂度=2*n(n-1)/2=n(n-1) /// 当n非常大时，多项式以幂次方最大的为标准所以复杂度O=n(n-1)=O(n*n) /// \u003c/summary\u003e /// \u003cparam name=\"A\"\u003e\u003c/param\u003e void BubbleSort(int[] A) { int n = A.Length; for (int i = 0; i \u003c n - 1; i++) { for (int j = 0; j \u003c n - 1 - i; j++) { if (A[j] \u003e A[j + 1]) { Swap(ref A[j + 1], ref A[j]); } } } } /// \u003csummary\u003e /// 冒泡排序（E版本）(最优版本) /// 时间复杂度: /// 最优的时间复杂度：当数据本身是有序的时候，只会比较但是不会交换，内循环执行一圈就结束了，复杂度O=n-1=O(n) /// 最坏的时间复杂度：O=n(n-1)=O(n*n) /// \u003c/summary\u003e /// \u003cparam name=\"A\"\u003e\u003c/param\u003e void BubbleSort_E(int[] A) { int n = A.Length; bool sorted = false; //整体排序标志，首先假定尚未排序 while (!sorted) { sorted = true;//假定有序 for (int i = 0; i \u003c n - 1; i++) { if (A[i] \u003e A[i + 1]) { Swap(ref A[i + 1], ref A[i]); sorted = false; } } n--;//因整体排序不能保证，需要清除排序标志 } } ","date":"2020-09-03 21:57:56","objectID":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/:0:2","tags":["数据结构","排序算法"],"title":"【数据结构】 十大经典排序算法及比较与分析 ( 动画演示 ) ( 可视化工具 )","uri":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["数据结构"],"content":"0X02 选择排序(直接选择排序) 可视化工具及动画演示 /// \u003csummary\u003e /// 选择排序(直接选择排序) /// 一次从待排序的序列中选出最小（或最大）的一个元素，存放在已排好序的序列的后一个位置，直到全部待排序的数据元素排完； /// 时间复杂度: /// 双层循环次数：内循环次数 i=0(n),i=1(n-1),i=2(n-2),...,i=n-2(2),i=n-1(1)为等差数列，总次数=(n-1)*(0+n)/2=n*(n-1)/2 /// 最坏情况每次比较都需要交换，执行内循环一次时复杂度为2（比较一次+交换一次），所以复杂度=2*n(n-1)/2=n(n-1),O=n(n-1)=O(n*n) /// 最优情况每次比较都不需要交换,执行内循环一次时复杂度为1（比较一次），，所以复杂度=n(n-1)/2,O=n(n-1)/2=O(n*n) /// \u003c/summary\u003e /// \u003cparam name=\"A\"\u003e\u003c/param\u003e void SelectionSort(int[] A) { int n = A.Length; int min; for (int i = 0; i \u003c n - 1; i++) { min = i; for (int j = i; j \u003c n; j++) { if (A[min] \u003e A[j]) { min = j; } } Swap(ref A[min], ref A[i]); //Console.Write($\"{i},{min}\"); PrintArray(A, i, min+1); } } ","date":"2020-09-03 21:57:56","objectID":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/:0:3","tags":["数据结构","排序算法"],"title":"【数据结构】 十大经典排序算法及比较与分析 ( 动画演示 ) ( 可视化工具 )","uri":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["数据结构"],"content":"0X03 插入排序(直接插入排序) 适合少量元素排序 可视化工具及动画演示 /// \u003csummary\u003e /// 插入排序(直接插入排序) /// 把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列。 /// 时间复杂度: /// 最坏情况双层循环次数：内循环次数 i=1(1),i=2(2),...,i=n-2(n-2)为等差数列，总次数=(n-2)*(1+n-2)/2=(n-2)*(n-1)/2 /// 最坏情况每次比较都需要交换，执行内循环一次时复杂度为2（比较一次+交换一次），所以复杂度=2*(n-2)*(n-1)/2,O=(n-1)(n-2)=O(n*n) /// \u003c/summary\u003e /// \u003cparam name=\"A\"\u003e\u003c/param\u003e void InsertionSort(int[] A) { int n = A.Length; for (int i = 1; i \u003c n - 1; i++) //第一个当做有序序列 { for (int j = i; j \u003e 0 \u0026\u0026 A[j - 1] \u003e A[j]; j--) //内循环使用冒泡方式对前面有序序列进行插入 { Swap(ref A[j - 1], ref A[j]); } } } /// \u003csummary\u003e /// 插入排序(E版本)(优化版本) /// 时间复杂度: /// 最优情况双层循环次数：内循环次数 i=1(1),i=2(1),...,i=n-2(1)，总次数=(n-2) /// 最优情况每次比较都不需要交换，执行内循环一次时复杂度为1（比较一次），所以复杂度=2*(n-2),O=2(n-2)=O(n) /// \u003c/summary\u003e /// \u003cparam name=\"A\"\u003e\u003c/param\u003e void InsertionSort_E(int[] A) { int n = A.Length; int j, tmp; for (int i = 1; i \u003c n - 1; i++) //第一个当做有序序列 { tmp = A[i]; for (j = i; j \u003e 0 \u0026\u0026 A[j - 1] \u003e tmp; j--) //内循环使用冒泡方式对前面有序序列进行插入 { A[j] = A[j - 1]; } A[j] = tmp; } } ","date":"2020-09-03 21:57:56","objectID":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/:0:4","tags":["数据结构","排序算法"],"title":"【数据结构】 十大经典排序算法及比较与分析 ( 动画演示 ) ( 可视化工具 )","uri":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["数据结构"],"content":"0X04 希尔排序 基于插入排序 参考学习： https://baijiahao.baidu.com/s?id=1644158198885715432\u0026wfr=spider\u0026for=pc 可视化工具及动画演示 /// \u003csummary\u003e /// 希尔排序 /// 先取一个小于n的整数d1作为第一个增量，把数组元素分组，所有距离为d1的倍数的记录放在同一个组中，先在各组内进行直接插入排序；然后，取第二个增量d2\u003cd1重复上述的分组和排序，直至所取的增量 =1( \u003c …\u003cd2\u003cd1)，即所有记录放在同一组中进行直接插入排序为止。\u003e /// 时间复杂度:(推算不出来，如果有小伙伴推算出来欢迎解说指点) /// 参考其他资料,复杂度和递增序列h有关（increment sequence） /// By combining the arguments of these two theorems h-sequences with O(log(n)) elements can be derived that lead to a very good performance in practice, as for instance the h-sequence of the program (Sedgewick [Sed 96]). But unfortunately, there seems to be no h-sequence that gives Shellsort a worst case performance of O(n·log(n)) (see [Sed 96]). It is an open question whether possibly the average complexity is in O(n·log(n)) /// \u003c/summary\u003e /// \u003cparam name=\"A\"\u003e\u003c/param\u003e void ShellSort(int[] A) { int n = A.Length; int h = 1; while (h \u003c 3) { h = h * 3 + 1; } while (h \u003e= 1) { for (int i = h; i \u003c n; i++) { for (int j = i; j \u003e= h \u0026\u0026 A[j] \u003c A[j - h]; j -= h) { if (A[j - h] \u003e A[j]) { Swap(ref A[j - h], ref A[j]); } } } h = h / 3; } } ","date":"2020-09-03 21:57:56","objectID":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/:0:5","tags":["数据结构","排序算法"],"title":"【数据结构】 十大经典排序算法及比较与分析 ( 动画演示 ) ( 可视化工具 )","uri":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["数据结构"],"content":"0X05 归并排序 可视化工具及动画演示 /// \u003csummary\u003e /// 归并排序 /// 首先两个子序列分别是有序的（递归后最小数组长度为1，认为数组长度为1时数组本身是有序的），这里对两个子序列合并，挑选两个子序列中最小的放入reg临时序列中，直到两个子序列中一个子序列被完全放入后结束，然后将另一个子序列复制到reg临时序列中，最后临时序列是合并后的有序序列了，将reg复制到A中 /// 时间复杂度：假设递归一次的时间复杂度为T() /// 执行1次递归的时间复杂度为T（n）=2*T(n/2)+n(两个子序列合并，一共长度为n) /// 执行2次递归的时间复杂度为T（n）=4*T(n/2)+2n /// 执行3次递归的时间复杂度为T（n）=8*T(n/8)+3n /// 类似二叉树的层数，层级=log2(n)+1 /// 代入得T(n)=nT(1)+log2(n)*n /// 时间复杂度O=T(n)=nT(1)+log2(n)*n=O(nlog2(n))=(nlogn) /// /// \u003c/summary\u003e /// \u003cparam name=\"A\"\u003e\u003c/param\u003e public void MergeSort(int[] A) { int n = A.Length; int[] reg = new int[n]; MergeSort(A, reg, 0, n - 1); } void MergeSort(int[] A, int[] reg, int start, int end) { if (start \u003e= end) { return; } int mid = (start + end) \u003e\u003e 1; int start1 = start; int end1 = mid; int start2 = mid + 1; int end2 = end; MergeSort(A, reg, start1, end1); MergeSort(A, reg, start2, end2); int k = start; //首先两个子序列分别是有序的，这里对两个子序列合并，挑选两个子序列中最小的放入reg临时序列中，直到两个子序列中一个子序列被完全放入后结束，然后将另一个子序列复制到reg临时序列中，最后临时序列是合并后的有序序列了，复制会A中 while (start1 \u003c= end1 \u0026\u0026 start2 \u003c= end2) { reg[k++] = A[start1] \u003c A[start2] ? A[start1++] : A[start2++]; // } while (start1 \u003c= end1) { reg[k++] = A[start1++]; } while (start2 \u003c= end2) { reg[k++] = A[start2++]; } Array.Copy(reg, start, A, start, end - start + 1); } /// \u003csummary\u003e /// 归并排序(非递归版) /// \u003c/summary\u003e /// \u003cparam name=\"A\"\u003e\u003c/param\u003e public void MergeSort_E(int[] A) { int n = A.Length; int[] a = A; int[] b = new int[n]; int seg, start; for (seg = 1; seg \u003c n; seg += seg) { for (start = 0; start \u003c n; start += seg + seg) { int low = start, mid = Math.Min(start + seg, n), high = Math.Min(start + seg + seg, n); int k = low; int start1 = low, end1 = mid; int start2 = mid, end2 = high; while (start1 \u003c end1 \u0026\u0026 start2 \u003c end2) b[k++] = a[start1] \u003c a[start2] ? a[start1++] : a[start2++]; while (start1 \u003c end1) b[k++] = a[start1++]; while (start2 \u003c end2) b[k++] = a[start2++]; } Array.Copy(b, a, n); } } ","date":"2020-09-03 21:57:56","objectID":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/:0:6","tags":["数据结构","排序算法"],"title":"【数据结构】 十大经典排序算法及比较与分析 ( 动画演示 ) ( 可视化工具 )","uri":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["数据结构"],"content":"0X06 快速排序 可视化工具及动画演示 /// \u003csummary\u003e /// 快速排序 /// 简单说是给基准数找正确索引位置的过程. /// 快速排序是对冒泡排序的一种改进。 /// 首先选取一个初始值（一般选取待排序序列的第一个值），通过一趟排序将待排序序列分成两个子序列，使左子序列的所有数据都小于这个初始值，右子序列的所有数据都大于这个初始值，然后再按此方法分别对这两个子序列进行排序，递归的进行上面的步骤，直至每一个数据项都有如下性质：该数据项左边的数据都小于它，右边的数据都大于它，这样，整个序列就有序了。 /// 时间复杂度：O=O(nlogn)和归并排序推理类似，不再展开推理了 /// /// \u003c/summary\u003e /// \u003cparam name=\"A\"\u003e\u003c/param\u003e public void QuickSort(int[] A) { int n = A.Length; QuickSort(A, 0, n - 1); } void QuickSort(int[] A, int low, int high) { if (low \u003e= high) return; int pivot = Partition(A, low, high); QuickSort(A, low, pivot - 1); QuickSort(A, pivot + 1, high); } int Partition(int[] A, int low, int high) { int pivot = A[low]; //基准数选取数组第一个元素（哨兵元素） while (low \u003c high) { while (low \u003c high \u0026\u0026 A[high] \u003e= pivot) --high; A[low] = A[high]; while (low \u003c high \u0026\u0026 A[low] \u003c= pivot) ++low; A[high] = A[low]; } A[low] = pivot; return low; } public void QuickSort_V(int[] A) { Stack\u003cint\u003e stack = new Stack\u003cint\u003e(); int pivot; int low = 0; int high = A.Length - 1; int start, end; stack.Push(high); stack.Push(low); while (stack.Count \u003e 0) { start = low = stack.Pop(); end = high = stack.Pop(); if (low \u003e= high) continue; pivot = A[low]; while (low \u003c high) { while (low \u003c high \u0026\u0026 A[high] \u003e= pivot) high--; A[low] = A[high]; while (low \u003c high \u0026\u0026 A[low] \u003c= pivot) low++; A[high] = A[low]; } A[low] = pivot; stack.Push(low - 1); stack.Push(start); stack.Push(end); stack.Push(low + 1); } } ","date":"2020-09-03 21:57:56","objectID":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/:0:7","tags":["数据结构","排序算法"],"title":"【数据结构】 十大经典排序算法及比较与分析 ( 动画演示 ) ( 可视化工具 )","uri":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["数据结构"],"content":"0X07 堆排序 可视化工具及动画演示 时间复杂度参考：堆排序的时间复杂度分析 /// \u003csummary\u003e /// 堆排序 /// 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。 /// 堆排序可以说是一种利用堆的概念来排序的选择排序。 /// 堆的性质： /// 堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 /// --\u003e大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列； /// --\u003e小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列； /// 堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了 /// 时间复杂度：(参考：https://blog.csdn.net/qq_34228570/article/details/80024306/) /// 构建初始堆复杂度：O(n) /// 交换并重建堆复杂度O(nlogn) /// 真个过程的复杂度O=O(n)+O(nlogn)=O(nlogn) /// /// /// \u003c/summary\u003e /// \u003cparam name=\"A\"\u003e\u003c/param\u003e public void HeapSort(int[] A) { int n = A.Length; int i; // 初始化构建堆结构，i從最後一個父節點開始調整(n/2-1为二叉树倒数第二层最后一个父节点) //构建后的二叉树根节点为整个二叉树中最大的节点 for (i = n / 2 - 1; i \u003e= 0; i--) //构建堆结构（完全二叉树，大顶堆） MaxHeapify(A, i, n - 1); for (i = n - 1; i \u003e 0; i--) { Swap(ref A[0], ref A[i]); MaxHeapify(A, 0, i - 1); } } void MaxHeapify(int[] A, int start, int end) { // 建立父節點指標和子節點指標 int dad = start; int son = dad * 2 + 1; while (son \u003c= end)// 若子節點指標在範圍內才做比較 { if (son + 1 \u003c end \u0026\u0026 A[son] \u003c A[son + 1]) son++; // 先比較兩個子節點大小，選擇最大的 if (A[dad] \u003e A[son]) return;//如果父節點大於子節點代表調整完畢，直接跳出函數 else { // 否則交換父子內容再繼續子節點和孫節點比較 Swap(ref A[dad], ref A[son]); dad = son; son = dad * 2 + 1; } } } ","date":"2020-09-03 21:57:56","objectID":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/:0:8","tags":["数据结构","排序算法"],"title":"【数据结构】 十大经典排序算法及比较与分析 ( 动画演示 ) ( 可视化工具 )","uri":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["数据结构"],"content":"0X08 计数排序 可视化工具及动画演示 /// \u003csummary\u003e /// 计数排序 /// 计数排序不是一个比较排序算法 /// 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 /// 计数排序类似与桶排序，也是用空间换取了时间，计数排序要求数组必须在一个确定的区间内。 /// 过程1：1. 首先找出数组的最大值和最小值；2. 遍历数组，以数字作为键，该数字出现的次数作为值插入哈希表中；3. 在最小值到最大值这个区间内遍历哈希表，将数字反向插入数组中。 /// 过程2： /// 根据待排序集合中最大元素和最小元素的差值范围，申请额外空间； /// 遍历待排序集合，将每一个元素出现的次数记录到元素值对应的额外空间内； /// 对额外空间内数据进行计算，得出每一个元素的正确索引位置； /// 将待排序集合每一个元素移动到计算得出的正确索引位置上。 /// 时间复杂度： /// 如果原始数列的规模是n，最大最小整数的差值是m，由于代码中第1、2、4步都涉及到遍历原始数列，运算量都是n，第3步遍历统计数列，运算量是m，所以总体运算量是3n+m，去掉系数，时间复杂度是O(n+m)。 /// /// 空间复杂度： /// 如果不考虑结果数组，只考虑统计数组的话，空间复杂度是O(m) /// 计数排序的局限性： /// 当数组最大和最小差值过大时，并不适合计数排序 /// 当数组元素不是整数(不能转化成整数计算的，浮点(用指数和浮点分部转化)、字符等等)时，也不适合用计数排序 /// \u003c/summary\u003e /// \u003cparam name=\"A\"\u003e\u003c/param\u003e public void CountingSort(int[] A) { int n = A.Length; int[] sorting = new int[n]; //1.找出数组中最大值、最小值 int max = int.MinValue; int min = int.MaxValue; for (int i = 0; i \u003c n; i++) { max = Math.Max(max, A[i]); min = Math.Min(min, A[i]); } //初始化计数数组count，设长度为m int[] counting = new int[max - min + 1]; //2. 对计数数组各元素赋值，设长度为m for (int i = 0; i \u003c n; i++) counting[A[i] - min]++; //3. 计数数组变形，新元素的值是前面元素累加之和的值 for (int i = 1; i \u003c counting.Length; i++) counting[i] += counting[i - 1]; //4. 遍历A中的元素，填充到结果数组中去，从后往前遍历 for (int i = n - 1; i \u003e= 0; i--) sorting[--counting[A[i] - min]] = A[i]; //5. 将结果复制到原始数组中 Array.Copy(sorting, A, n); } ","date":"2020-09-03 21:57:56","objectID":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/:0:9","tags":["数据结构","排序算法"],"title":"【数据结构】 十大经典排序算法及比较与分析 ( 动画演示 ) ( 可视化工具 )","uri":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["数据结构"],"content":"0X09 桶排序 可视化工具及动画演示 /// \u003csummary\u003e /// 桶排序（Bucket Sort）(箱排序) /// 桶排序是计数排序的扩展版本，计数排序可以看成每个桶只存储相同元素，而桶排序每个桶存储一定范围的元素，通过映射函数，将待排序数组中的元素映射到各个对应的桶中，对每个桶中的元素进行排序，最后将非空桶中的元素逐个放入原序列中。 /// 算法过程： /// 根据待排序集合中最大元素和最小元素的差值范围和映射规则，确定申请的桶个数； /// 遍历待排序集合，将每一个元素移动到对应的桶中； /// 对每一个桶中元素进行排序，并移动到已排序集合中。 /// 时间复杂度：设桶内比较排序为快速排序(复杂度nlogn) /// 第一个循环为O(N),设桶的数量为M，平均每个桶的元素数量为N/M,桶内以快速排序为例为NlogN，复杂度为O(M*N/M*log2(N/M)+N)=O(N+N(log2(N)-log2(M))) /// 第二个循环为O(2N) /// 总复杂度为O(3N+N(log2(N)-log2(M)))=O(N+N(logN-LogM)) /// 当M=N时 复杂度为O(N) /// 当M=1时 复杂度为O(N+Nlog(N)) ///这里桶内排序使用的是链表指针方式，桶内复杂度为O(1)，可以忽略，总复杂度为O(N) /// \u003c/summary\u003e /// \u003cparam name=\"A\"\u003e\u003c/param\u003e /// \u003cparam name=\"bucketSize\"\u003e每个桶内数据的预期数量\u003c/param\u003e public void BucketSort(int[] A, int bucketSize = 1000) { int n = A.Length; int index; //1.找出数组中最大值、最小值 int max = int.MinValue; int min = int.MaxValue; for (int i = 0; i \u003c n; i++) { max = Math.Max(max, A[i]); min = Math.Min(min, A[i]); } int bucketCount = (max - min) / bucketSize + 1; LinkedList\u003cint\u003e[] bucket = new LinkedList\u003cint\u003e[bucketCount]; for (int i = 0; i \u003c n; i++) { index = (A[i]-min) / bucketSize; if (bucket[index] == null) bucket[index] = new LinkedList\u003cint\u003e(); BucketInsertSort(bucket[index], A[i]); } index = 0; for (int i = 0; i \u003c bucket.Length; i++) { LinkedList\u003cint\u003e linkedList = bucket[i]; if (linkedList == null) continue; var current = linkedList.First; while (current != null) { A[index++] = current.Value; current = current.Next; } } } /// \u003csummary\u003e /// 桶排序的桶内排序，这里用的是指针选择排序，还可使用快速排序 /// \u003c/summary\u003e /// \u003cparam name=\"list\"\u003e\u003c/param\u003e /// \u003cparam name=\"a\"\u003e\u003c/param\u003e void BucketInsertSort(LinkedList\u003cint\u003e list, int a) { var current = list.First; if (current == null || current.Value \u003e a) { list.AddFirst(a); return; } while (current != null) { if (current.Next == null || current.Next.Value \u003e a) { list.AddAfter(current, a); return; } current = current.Next; } } ","date":"2020-09-03 21:57:56","objectID":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/:0:10","tags":["数据结构","排序算法"],"title":"【数据结构】 十大经典排序算法及比较与分析 ( 动画演示 ) ( 可视化工具 )","uri":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["数据结构"],"content":"0X10 基数排序 可视化工具及动画演示 /// \u003csummary\u003e /// 基数排序 /// 概念1：基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 /// 概念2：将所有待排序的数统一为相同的数位长度，数位较短的数前面补零，然后从低位到高位按位比较，位数字小的排在前面，大的排在后面，这样当比较第N位时前N-1位都是有序的，如此循环的比较，直到最高位比较完成，整个序列就是有序的了。 /// 时间复杂度： /// 设待排序列为n个记录，序列中最大值的位数为d，数字的基数为 r，则进行链式基数排序的时间复杂度为O(d(n+r))。当分配数字时要对每一个数字进行按位比较， 而收集数字时要进行r次收集（如十进制数字就要进行从0到9共10次收集操作）， 故一趟分配时间复杂度为O(n)，一趟收集时间复杂度为O(r)，共进行d趟分配和收集。 /// /// 基数排序 vs 计数排序 vs 桶排序 /// 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： /// 基数排序：根据键值的每位数字来分配桶； /// 计数排序：每个桶只存储单一键值； /// 桶排序：每个桶存储一定范围的数值； /// \u003c/summary\u003e /// \u003cparam name=\"A\"\u003e\u003c/param\u003e public void RadixSort(int[] A) { int n = A.Length; const int BASE = 10; int exp = 1; int max = int.MinValue; int[] tmp = new int[n]; for (int i = 0; i \u003c n; i++) if (A[i] \u003e max) max = A[i]; while (max / exp \u003e 0) { int[] bucket = new int[n]; for (int i = 0; i \u003c n; i++) { bucket[A[i] / exp % BASE]++; } for (int i = 1; i \u003c n; i++) { bucket[i] += bucket[i - 1]; } for (int i = n - 1; i \u003e= 0; i--) { tmp[--bucket[A[i] / exp % BASE]] = A[i]; } Array.Copy(tmp, A, n); exp *= BASE; } } ","date":"2020-09-03 21:57:56","objectID":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/:0:11","tags":["数据结构","排序算法"],"title":"【数据结构】 十大经典排序算法及比较与分析 ( 动画演示 ) ( 可视化工具 )","uri":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["数据结构"],"content":"0X11 全部代码（C#） ==全部代码（github）== ","date":"2020-09-03 21:57:56","objectID":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/:0:12","tags":["数据结构","排序算法"],"title":"【数据结构】 十大经典排序算法及比较与分析 ( 动画演示 ) ( 可视化工具 )","uri":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["数据结构"],"content":"0X12 排序算法耗时测试 ==全部代码（github）== 测试环境：（.Net4.6.1,win10） 数组长度50，数组元素(0–1000). BubbleSort总共花费0.3393ms. BubbleSort_E总共花费0.1743ms. SelectionSort总共花费0.1832ms. InsertionSort总共花费0.1752ms. InsertionSort_E总共花费0.1461ms. ShellSort总共花费0.2367ms. MergeSort总共花费0.4245ms. MergeSort_E总共花费0.4201ms. QuickSort总共花费0.3644ms. QuickSort_V总共花费0.4239ms. HeapSort总共花费0.2615ms. CountingSort总共花费0.2181ms. BucketSort总共花费3.492ms. RadixSort总共花费0.3766ms. 数组长度500，数组元素(0–1000). BubbleSort总共花费1.4969ms. BubbleSort_E总共花费1.7962ms. SelectionSort总共花费0.4618ms. InsertionSort总共花费1.2992ms. InsertionSort_E总共花费0.2969ms. ShellSort总共花费0.4273ms. MergeSort总共花费0.4269ms. MergeSort_E总共花费0.2781ms. QuickSort总共花费0.2806ms. QuickSort_V总共花费0.3587ms. HeapSort总共花费0.3837ms. CountingSort总共花费0.2465ms. BucketSort总共花费1.3181ms. RadixSort总共花费0.2294ms. 数组长度1000，数组元素(0–1000). BubbleSort总共花费4.9505ms. BubbleSort_E总共花费4.669ms. SelectionSort总共花费1.2467ms. InsertionSort总共花费3.395ms. InsertionSort_E总共花费1.3513ms. ShellSort总共花费1.3414ms. MergeSort总共花费0.5231ms. MergeSort_E总共花费0.4844ms. QuickSort总共花费0.3366ms. QuickSort_V总共花费0.3937ms. HeapSort总共花费0.4446ms. CountingSort总共花费0.2668ms. BucketSort总共花费2.6375ms. RadixSort总共花费0.5076ms. 数组长度5000，数组元素(0–1000). BubbleSort总共花费134.6438ms. BubbleSort_E总共花费141.5785ms. SelectionSort总共花费32.566ms. InsertionSort总共花费82.5932ms. InsertionSort_E总共花费17.178ms. ShellSort总共花费22.8029ms. MergeSort总共花费1.0649ms. MergeSort_E总共花费0.7582ms. QuickSort总共花费0.7838ms. QuickSort_V总共花费0.8333ms. HeapSort总共花费1.5709ms. CountingSort总共花费0.2693ms. BucketSort总共花费1.7872ms. RadixSort总共花费0.4634ms. 数组长度10000，数组元素(0–1000). BubbleSort总共花费556.6481ms. BubbleSort_E总共花费528.7346ms. SelectionSort总共花费116.9845ms. InsertionSort总共花费306.6125ms. InsertionSort_E总共花费68.4407ms. ShellSort总共花费88.4968ms. MergeSort总共花费1.8969ms. MergeSort_E总共花费1.3673ms. QuickSort总共花费1.4713ms. QuickSort_V总共花费1.4491ms. HeapSort总共花费3.3177ms. CountingSort总共花费0.3216ms. BucketSort总共花费2.9245ms. RadixSort总共花费0.7497ms. 数组长度30000，数组元素(0–1000). BubbleSort总共花费4702.0921ms. BubbleSort_E总共花费4660.4316ms. SelectionSort总共花费952.3607ms. InsertionSort总共花费2763.3749ms. InsertionSort_E总共花费610.9831ms. ShellSort总共花费777.4363ms. MergeSort总共花费5.3142ms. MergeSort_E总共花费3.806ms. QuickSort总共花费4.2744ms. QuickSort_V总共花费4.4204ms. HeapSort总共花费10.0902ms. CountingSort总共花费0.5658ms. BucketSort总共花费18.1321ms. RadixSort总共花费1.8263ms. 数组长度100000，数组元素(0–1000). BubbleSort总共花费52096.3052ms. BubbleSort_E总共花费52299.5447ms. SelectionSort总共花费10567.5827ms. InsertionSort总共花费30973.0239ms. InsertionSort_E总共花费6888.8287ms. ShellSort总共花费8548.7395ms. MergeSort总共花费17.985ms. MergeSort_E总共花费13.3151ms. QuickSort总共花费19.1267ms. QuickSort_V总共花费18.6859ms. HeapSort总共花费36.055ms. CountingSort总共花费1.3793ms. BucketSort总共花费195.1004ms. RadixSort总共花费6.1907ms. 通过测试数据得出： 没有空间开销的算法中（不考虑原始数据局部有序） 小数据量（\u003c500） ==直接插入排序最优(E版本)== ；大数据量(\u003e500) ==快速排序最优（递归版本，不考虑递归开销）==。 有空间开销的算法中 (不考虑空间开销大小，大数据量\u003e1000）==基数排序和计数排序最优，其次是归并排序（E版本非递归）==。 桶排序的耗时不是最优的，这里的桶排序没有设置桶的size，所以桶排序耗时不考虑。 如果有出入或者错误望各位留言指正 ","date":"2020-09-03 21:57:56","objectID":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/:0:13","tags":["数据结构","排序算法"],"title":"【数据结构】 十大经典排序算法及比较与分析 ( 动画演示 ) ( 可视化工具 )","uri":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["数据结构"],"content":"0X13 十大算法比较与分析 这里是参考其他文章的结论进行了罗列，我自己的测试结论参考上一节（ 0X13 ）节 ==直接插入排序== 是对冒泡排序的改进，比冒泡排序快，但是只适用于数据量较小(1000 ) 的排序 ==希尔排序== 比较简单，适用于小数据量（5000以下）的排序，比直接插入排序快、冒泡排序快，因此，希尔排序适用于小数据量的、排序速度要求不高的排序。 ==直接选择排序== 和冒泡排序算法一样，适用于n值较小的场合，而且是排序算法发展的初级阶段，在实际应用中采用的几率较小。 ==堆排序== 比较适用于数据量达到百万及其以上的排序，在这种情况下，使用递归设计的快速排序和归并排序可能会发生堆栈溢出的现象。 ==冒泡排序== 是最慢的排序算法，是排序算法发展的初级阶段，实际应用中采用该算法的几率比较小。 ==快速排序== 是递归的、速度最快的排序算法，但是在内存有限的情况下不是一个好的选择;而且，对于基本有序的数据序列排序，快速排序反而变得比较慢。 ==归并排序== 比堆排序要快，但是需要的存储空间增加一倍。 ==基数排序== 适用于规模n值很大的场合，但是只适用于整数的排序，如果对浮点数进行基数排序，则必须明确浮点数的存储格式，然后通过某种方式将其映射到整数上，最后再映射回去，过程复杂。 摘自常用排序算法比较与分析 ==冒泡排序：== 效率太低，通过冒泡可以掌握swap。 ==选择排序：== 效率较低，但经常使用它内部的循环方式来找最大值和最小值。 ==插入排序：== 虽然平均效率低，但在序列基本有序时，它很快，所以也有其适用范围。 ==希尔排序：== 是插入排序的改良，对空间思维训练有帮助。 ==快速排序：== 快排是软件工业中最常见的常规排序法，其双向指针扫描和分区算法是核心。 往往用于解决类似问题，特别地partition算法用来划分不同性质的元素， partition-\u003eselectK,也用于著名的top问题 O(NlgN)，但是如果主元不是中位数的话，特别地如果每次主元都在数组区间的一侧，复杂度将退化为N² 工业优化：三点取中法，绝对中值法，小数据量用插入排序 快排重视子问题拆分 ==归并排序：== 空间换时间——逆序对数， 归并重视子问题的解的合并 ==堆排序：== 用到了二叉堆数据结构，是继续掌握树结构的起手式。=插排+二分查找 上面7种都是基于比较的排序，可证明它们在元素随机顺序情况下最好是NlgN的，用决策树证明 下面三个是非比较排序，在特定情况下会比基于比较的排序要快： ==计数排序：== 可以说是最快的：O(N+k),k=maxOf(sourceArr)，用它来解决问题时必须注意如果序列中的值分布非常广（最大值很大，元素分布很稀疏）， 空间将会浪费很多 所以计数排序的适用范围是：序列的关键字比较集中，已知边界，且边界较小 ==桶排序：== 先分桶，再用其他排序方法对桶内元素排序，按桶的编号依次检出。（分配-收集） 用它解决问题必须注意序列的值是否均匀地分布在桶中。 如果不均匀，那么个别桶中的元素会远多于其他桶，桶内排序用比较排序，极端情况下，全部元素在一个桶内，还是会退化成NlgN。 其时间复杂度是：时间复杂度： O(N+C)，其中C=N(logN-logM)，约等于NlgN N是元素个数，M是桶的个数。 基数排序： kN级别（k是最大数的位数）是整数数值型排序里面又快又稳的，无论元素分布如何， 只开辟固定的辅助空间（10个桶） 对比桶排序，基数排序每次需要的桶的数量并不多。而且基数排序几乎不需要任何“比较”操作，而桶排序在桶相对较少的情况下，桶内多个数据必须进行基于比较操作的排序。因此，在实际应用中，对十进制整数来说，基数排序更好用。 摘自10种排序算法的对比分析 ","date":"2020-09-03 21:57:56","objectID":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/:0:14","tags":["数据结构","排序算法"],"title":"【数据结构】 十大经典排序算法及比较与分析 ( 动画演示 ) ( 可视化工具 )","uri":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["数据结构"],"content":"0X14 数据结构可视化工具 可视化工具及动画展示地址：旧金山大学|数据结构可视化 十大排序算法可视化工具及动画演示展示 选择上面的按钮就可以播放啦 选择上面的按钮就可以播放啦 点击向后跳就然后点上面的某个排序按钮就可以重新播放啦 ","date":"2020-09-03 21:57:56","objectID":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/:0:15","tags":["数据结构","排序算法"],"title":"【数据结构】 十大经典排序算法及比较与分析 ( 动画演示 ) ( 可视化工具 )","uri":"/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["数据结构"],"content":" 最近发现A*算法忘的一干二净啊，记忆是个好东西，可惜吾没有啊，只能整理一篇文章以备日后翻看 这里只谈A*算法的实现，不谈A算法的优化* 这里的工程是unity版本的，当然理解A*算法是通用的 这里先放上A*算法的unity工程(unity2017.3.1) unity工程（github） ","date":"2020-09-03 21:09:12","objectID":"/a%E6%98%9F%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/:0:0","tags":["算法"],"title":"【数据结构】 A* 算法理解(C#)","uri":"/a%E6%98%9F%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/"},{"categories":["数据结构"],"content":"0X01 A*算法基本概念 启发式搜索： 启发式搜索就是在状态空间中的搜索对每一个搜索的位置进行评估，得到最好的位置，再从这个位置进行搜索直到目标。这样可以省略大量无畏的搜索路径，提到了效率。在启发式搜索中，对位置的估价是十分重要的。采用了不同的估价可以有不同的效果。 IDA*算法： 这种算法被称为迭代加深A算法，可以有效的解决A空间增长带来的问题，甚至可以不用到优先级队列。如果要知道详细：google一下。 搜索区域（The Search Area）： 图中的搜索区域被划分为了简单的二维数组，数组每个元素对应一个小方格，当然我们也可以将区域等分成是五角星，矩形等，通常将一个单位的中心点称之为搜索区域节点（Node）。　开放列表(Open List)： 我们将路径规划过程中待检测的节点存放于Open List中，而已检测过的格子则存放于Close List中。 关闭列表(Close List)： 我们将路径规划过程中已经检查过的节点放在Close List。 启发函数（Heuristics Function）（估价函数）： H为启发函数，也被认为是一种试探，由于在找到唯一路径前，我们不确定在前面会出现什么障碍物，因此用了一种计算H的算法，具体根据实际场景决定。在我们简化的模型中，H采用的是传统的曼哈顿距离（Manhattan Distance）估价函数，也就是横纵向走的距离之和。 ==F(n) = G + H。F代表当前检查点的总花费，G代表起点到当前检查点的花费，H代表当前检查点到终点的预估花费。== 父节点（parent）： 在路径规划中用于回溯的节点。 A*算法的特点： A*算法在理论上是时间最优的，但是也有缺点：它的空间增长是指数级别的。 ","date":"2020-09-03 21:09:12","objectID":"/a%E6%98%9F%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/:0:1","tags":["算法"],"title":"【数据结构】 A* 算法理解(C#)","uri":"/a%E6%98%9F%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/"},{"categories":["数据结构"],"content":"0X02 A*算法寻路过程 将起点A添加到open列表中（A没有计算花费F是因为当前open列表只有这一个节点）。 检查open列表，选取花费F最小的节点M（检查M如果为终点是则结束寻路，如果open列表没有则寻路失败，直接结束）。 对于与M相邻的每一节点N：（下面本来没有序号的，csdn markdown的bug） 如果N是阻挡障碍，那么不管它。 如果N在closed列表中，那么不管它。 如果N不在open列表中：添加它然后计算出它的花费F(n)=G+H。 如果N已在open列表中：当我们使用当前生成的路径时，检查F花费是否更小。如果是，更新它的花费F和它的父节点。 重复2，3步。 ","date":"2020-09-03 21:09:12","objectID":"/a%E6%98%9F%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/:0:2","tags":["算法"],"title":"【数据结构】 A* 算法理解(C#)","uri":"/a%E6%98%9F%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/"},{"categories":["数据结构"],"content":"0X03 A*算法寻路详细描述 寻路关键代码： /// \u003csummary\u003e /// 使用A*算法寻路 /// \u003c/summary\u003e /// \u003cparam name=\"start\"\u003e\u003c/param\u003e /// \u003cparam name=\"end\"\u003e\u003c/param\u003e void FindPath(Vector2 start,Vector2 end) { //和A*算法无关，只是为了显示使用 int showFindNum=1; //开启列表 List\u003cCell\u003e openLs = new List\u003cCell\u003e(); //关闭列表 List\u003cCell\u003e closeLs = new List\u003cCell\u003e(); //起点 Cell startCell = grid.GetCell(start); //终点 Cell endCell = grid.GetCell(end); Debug.LogFormat(\"寻路开始,start({0}),end({1})!\",start,end); //将起点作为待处理的点放入开启列表， openLs.Add(startCell); //如果开启列表没有待处理点表示寻路失败，此路不通 while(openLs.Count\u003e0) { //遍历开启列表，找到消费最小的点作为检查点 Cell cur = openLs[0]; for (int i = 0; i \u003c openLs.Count; i++) { if(openLs[i].fCost\u003ccur.fCost\u0026\u0026openLs[i].hCost\u003ccur.hCost) { cur = openLs[i]; } } Debug.Log(\"当前检查点：\" + cur.ToString()+\" 编号：\"+showFindNum+\" open列表节点数量：\"+openLs.Count); //显示在界面，和A*算法无关 cur.obj.transform.Find(\"Num\").GetComponent\u003cText\u003e().text=showFindNum.ToString(); showFindNum++; //从开启列表中删除检查点，把它加入到一个“关闭列表”，列表中保存所有不需要再次检查的方格。 openLs.Remove(cur); closeLs.Add(cur); //检查是否找到终点 if(cur==endCell) { Debug.Log(\"寻路结束!\"); grid.CreatePath(cur); return; } //根据检查点来找到周围可行走的点 //1.如果是墙或者在关闭列表中则跳过 //2.如果点不在开启列表中则添加 //3.如果点在开启列表中且当前的总花费比之前的总花费小，则更新该点信息 List\u003cCell\u003e aroundCells = GetAllAroundCells(cur); foreach (var cell in aroundCells) { if (cell.isWall || closeLs.Contains(cell)) continue; int cost= cur.gCost+ GetDistanceCost(cell, cur); if(cost\u003ccell.gCost||!openLs.Contains(cell)) { cell.gCost = cost; cell.hCost = GetDistanceCost(cell,endCell); cell.parent = cur; Debug.Log(\"cell:\" + cell.ToString() + \" parent:\" + cur.ToString() + \" \" + cell.PrintCost()); if(!openLs.Contains(cell)) { openLs.Add(cell); } //显示在界面，和A*算法无关 cell.obj.transform.Find(\"Cost\").GetComponent\u003cText\u003e().text = cell.fCost.ToString(); } } } Debug.Log(\"寻路失败!\"); } 根据上面的工程得到这个图： 圆点说明：黑色是障碍物体，红色是起点，绿色是终点，浅紫色是寻路路径 红色数字：总花费F 蓝色数字：寻路的过程描述 过程描述： 将起点（3，6）放到open列表中。 选择open列表中花费最小的点M（3，6）,将M从open中移除，添加到closed列表中，后面检查时不再检查该点。 计算（3，6）相邻的点，一共8个点，并且分别计算花费F（红色数字），都添加到open中 选择open列表中花费最小的点M（4，6）,将M从open中移除，添加到closed列表中，后面检查时不再检查该点。 计算（4，6）相邻的点，一共8个点，右侧是障碍物，其它5个点都在open中，分别计算当前路径花费和原来对比，都大，所以没有更新花费和父节点 选择open列表中花费最小的点M（4，5）,将M从open中移除，添加到closed列表中，后面检查时不再检查该点。 计算M相邻的点，在下面有三个新节点添加open中，其它五个点要么是障碍要么是已经在open中且花费比原来大， 选择open列表中花费最小的点M（4，7）,将M从open中移除，添加到closed列表中，后面检查时不再检查该点。 计算M相邻的点，在上面有三个新节点添加open中，其它五个点要么是障碍要么是已经在open中且花费比原来大， 选择open列表中花费最小的点M（3，5）,将M从open中移除，添加到closed列表中，后面检查时不再检查该点。 计算M相邻的点，在左下有一个新节点添加open中，在正下面有一个点（3，4）的花费比原来小，更新该节点信息，其它的点已经在open中且花费比原来大， 选择open列表中花费最小的点M（3，7）,将M从open中移除，添加到closed列表中，后面检查时不再检查该点。 计算M相邻的点，在左下有一个新节点添加open中，在正下面有一个点（3，8）的花费比原来小，更新该节点信息，其它的点已经在open中且花费比原来大， 选择open列表中花费最小的点M（5，4）,将M从open中移除，添加到closed列表中，后面检查时不再检查该点。 计算M相邻的点，有五个新节点添加open中，其它三个点要么是障碍要么是已经在open中且花费比原来大， 选择open列表中花费最小的点M（5，8）,将M从open中移除，添加到closed列表中，后面检查时不再检查该点。 计算M相邻的点，有五个新节点添加open中，其它三个点要么是障碍要么是已经在open中且花费比原来大， 选择open列表中花费最小的点M（6，5）,将M从open中移除，添加到closed列表中，后面检查时不再检查该点。 计算M相邻的点，有四个新节点添加open中，其它四个点要么是障碍要么是已经在open中且花费比原来大或者相等， 选择open列表中花费最小的点M（6，7）,将M从open中移除，添加到closed列表中，后面检查时不再检查该点。 计算M相邻的点，有两个新节点添加open中，其它六个点要么是障碍要么是已经在open中且花费比原来大或者相等， 选择open列表中花费最小的点M（7，6）,将M从open中移除，添加到closed列表中，和终点对比相等，寻路结束。 根据当前代码寻路有个情况就是寻路到终点前临近终点时，可以提前一步结束，这里没有结束，是为了方便演示 参考文章： A*算法完全理解 堪称最好最全的A*算法详解（译文） A星寻路算法介绍 这里的unity工程是参考一篇文章的，是两年前的文章，没有找到，就不放参考链接了 ","date":"2020-09-03 21:09:12","objectID":"/a%E6%98%9F%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/:0:3","tags":["算法"],"title":"【数据结构】 A* 算法理解(C#)","uri":"/a%E6%98%9F%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/"},{"categories":["数据结构"],"content":" 转自：AVL树(一)之 图文解析 和 C语言的实现（本文图片及文字描述部分转自该文） 参考：邓俊辉 的数据结构，部分图片来自该资料 代码是C#写的 AVL树是根据它的发明者G.M. Adelson-Velsky和E.M. Landis命名的。 它是最先发明的自平衡二叉查找树，也被称为高度平衡树。相比于\"二叉查找树\"，它的特点是：AVL树中任何节点的两个子树的高度最大差别为1。(树的高度：树中结点的最大层次) 上面的两张图片，左边的是AVL树，它的任何节点的两个子树的高度差别都\u003c=1；而右边的不是AVL树，因为7的两颗子树的高度相差为2(以2为根节点的树的高度是3，而节点8的高度是1)。 AVL树的查找、插入和删除在平均和最坏情况下都是O(logn)。 如果在AVL树中插入或删除节点后，使得高度之差大于1。此时，AVL树的平衡状态就被破坏，它就不再是一棵二叉树；为了让它重新维持在一个平衡状态，就需要对其进行旋转处理。学AVL树，重点的地方也就是它的旋转算法 首先要明确的是，== 平衡二叉树是一棵二叉排序树，它的出现是为了解决普通二叉排序树（普通二叉排序树）不平衡的问题。如图，在插入结点之前首先要查找插入位置，假如要在5结点后插入，普通二叉排序树需要比较五次，而平衡二叉树只需要比较三次。假如结点规模进一步加大，效率提升也会更明显。 (图片来自https://blog.csdn.net/m0_38036210/article/details/100517125) ","date":"2020-09-03 21:09:12","objectID":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/:0:0","tags":["数据结构"],"title":"【数据结构】 AVL树详解（可视化工具）","uri":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["数据结构"],"content":"0X01 节点和树的定义 1. 节点的定义 public class Node { public int Key; public Node Parent;//parent public Node L; //left public Node R; //right public int H; //height; public Node(int key, Node parent=null, Node left=null, Node right=null,int h=1) { Key = key; Parent = parent; L = left; R = right; H = h; } } 2. 树的定义 public class AVLTree { //树的根节点 public Node Root; } 3.树的高度 空的二叉树的高度是0，非空树只有一个节点根节点高度为1等等 /// \u003csummary\u003e /// 树的高度 /// 树的高度为最大层次。即空的二叉树的高度是0，非空树的高度等于它的最大层次(根的层次为1，根的子节点为第2层，依次类推)，这里空树的高度取0，有的教材资料是-1 /// \u003c/summary\u003e /// \u003cparam name=\"a\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public int Height(Node a) { return a == null ? 0 : a.H; } public int MaxHeight(Node a, Node b) { return a == null ? (b == null ? 0 : b.H) : (b == null ? a.H : a.H \u003e b.H ? a.H : b.H); } public int UpdateHeight(Node a) { a.H = MaxHeight(a.L, a.R) + 1; return a.H; } /// \u003csummary\u003e /// 是否平衡 /// \u003c/summary\u003e /// \u003cparam name=\"tree\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public bool IsBalanced(Node tree) { return -2 \u003c Height(tree.L) - Height(tree.R) \u0026\u0026 Height(tree.L) - Height(tree.R) \u003c 2; } /// \u003csummary\u003e /// 在左、右孩子中取更高者 /// \u003c/summary\u003e /// \u003cparam name=\"tree\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public Node TallerChild(Node tree) { if (tree == null) return null; if (Height(tree.L) \u003e Height(tree.R)) return tree.L; else return tree.R; } ","date":"2020-09-03 21:09:12","objectID":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/:1:0","tags":["数据结构"],"title":"【数据结构】 AVL树详解（可视化工具）","uri":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["数据结构"],"content":"0X02 单旋和双旋 前面说过，如果在AVL树中进行插入或删除节点后，可能导致AVL树失去平衡。 ","date":"2020-09-03 21:09:12","objectID":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/:2:0","tags":["数据结构"],"title":"【数据结构】 AVL树详解（可视化工具）","uri":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["数据结构"],"content":"2.1 zag单旋（左旋） 如果说节点g失去平衡，g的右孩子p高度比左孩子高，且右孩子p的右孩子v高度比右孩子p的左孩子高度高，那么进行逆时针旋转进行调整高度 假设在子树v中插入某个节点x（虚线连接部分，其中一个节点对应x，另一个为空节点），这时候v节点是平衡的，p节点也是平衡，但是g节点不平衡，g的右孩子高度减去g的做孩子高度等于2，需要对g节点进行调整，这时候以g为轴进行逆时针旋转（左旋），调整后从a子树变为b子树；从而达到子树的平衡， 而且高度未变化，所以该子树平衡后，父节点及除子树的其他树的部分都是平衡的。 旋转代码 /// \u003csummary\u003e /// zag 左旋转，逆时针旋转,单旋 /// （逆时针旋转g） /// g /// / \\ /// T0 p /// / \\ /// T1 v /// / \\ /// T2 T3 /// /// zag单旋后： /// p(b) /// / \\ /// g(a) v(c) /// / \\ / \\ /// T0 T1 T2 T3 /// /// \u003c/summary\u003e /// \u003cparam name=\"tree\"\u003e非空孙辈节点\u003c/param\u003e /// \u003creturns\u003e该树新的的根节点\u003c/returns\u003e public Node Zag(Node tree) { Node v = tree, p = v.Parent, g = p.Parent, r = g.Parent; Node a = g, b = p, c = v; Node T0 = g.L, T1 = p.L, T2 = v.L, T3 = v.R; a.L = T0; if (T0 != null) T0.Parent = a; a.R = T1; if (T1 != null) T1.Parent = a; UpdateHeight(a); c.L = T2; if (T2 != null) T2.Parent = c; c.R = T3; if (T3 != null) T3.Parent = c; UpdateHeight(c); b.L = a; a.Parent = b; b.R = c; c.Parent = b; UpdateHeight(b); Connect(r, b); //根节点和父节点联接 return b;//该树新的的根节点 } ","date":"2020-09-03 21:09:12","objectID":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/:2:1","tags":["数据结构"],"title":"【数据结构】 AVL树详解（可视化工具）","uri":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["数据结构"],"content":"2.2 zig单旋（右旋） 假设在子树v中插入某个节点x（虚线连接部分，其中一个节点对应x，另一个为空节点），这时候v节点是平衡的，p节点也是平衡，但是g节点不平衡，g的右孩子高度减去g的做孩子高度等于-2，需要对g节点进行调整，这时候以g为轴进行顺时针旋转（右旋），调整后从a子树变为b子树；从而达到子树的平衡， 而且高度未变化，所以该子树平衡后，父节点及除子树的其他树的部分都是平衡的。 旋转代码 /// \u003csummary\u003e /// Zig右旋，顺时针旋转,单旋 /// （顺时针旋转g） /// g /// / \\ /// p T3 /// / \\ /// v T2 /// / \\ /// T0 T1 /// /// zig单旋后： /// p(b) /// / \\ /// v(a) g(c) /// / \\ / \\ /// T0 T1 T2 T3 /// /// \u003c/summary\u003e /// \u003cparam name=\"tree\"\u003e非空孙辈节点\u003c/param\u003e /// \u003creturns\u003e该树新的的根节点\u003c/returns\u003e public Node Zig(Node tree) { Node v = tree, p = v.Parent, g = p.Parent, r = g.Parent; Node a = v, b = p, c = g; Node T0 = v.L, T1 = v.R, T2 = p.R, T3 = g.R; a.L = T0; if (T0 != null) T0.Parent = a; a.R = T1; if (T1 != null) T1.Parent = a; UpdateHeight(a); c.L = T2; if (T2 != null) T2.Parent = c; c.R = T3; if (T3 != null) T3.Parent = c; UpdateHeight(c); b.L = a; a.Parent = b; b.R = c; c.Parent = b; UpdateHeight(b); Connect(r, b); //根节点和父节点联接 return b;//该树新的的根节点 } ","date":"2020-09-03 21:09:12","objectID":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/:2:2","tags":["数据结构"],"title":"【数据结构】 AVL树详解（可视化工具）","uri":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["数据结构"],"content":"2.3 zagzig双旋 （先逆时针旋转p(zag)，后顺时针旋转g(zig)） 旋转代码 /// \u003csummary\u003e /// ZagZig 双旋(先左旋p后右旋g) /// /// （先逆时针旋转p(zag)，后顺时针旋转g(zig)） /// g /// / \\ /// p T3 /// / \\ /// T0 v /// / \\ /// T1 T2 /// /// zag-zig双旋后 /// v(b) /// / \\ /// p(a) g(c) /// / \\ / \\ /// T0 T1 T2 T3 /// /// \u003c/summary\u003e /// \u003cparam name=\"tree\"\u003e非空孙辈节点\u003c/param\u003e /// \u003creturns\u003e该树新的的根节点\u003c/returns\u003e public Node ZagZig(Node tree) { Node v = tree, p = v.Parent, g = p.Parent, r = g.Parent; Node a = p, b = v, c = g; Node T0 = p.L, T1 = v.L, T2 = v.R, T3 = g.R; a.L = T0; if (T0 != null) T0.Parent = a; a.R = T1; if (T1 != null) T1.Parent = a; UpdateHeight(a); c.L = T2; if (T2 != null) T2.Parent = c; c.R = T3; if (T3 != null) T3.Parent = c; UpdateHeight(c); b.L = a; a.Parent = b; b.R = c; c.Parent = b; UpdateHeight(b); Connect(r, b); //根节点和父节点联接 return b;//该树新的的根节点 } ","date":"2020-09-03 21:09:12","objectID":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/:2:3","tags":["数据结构"],"title":"【数据结构】 AVL树详解（可视化工具）","uri":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["数据结构"],"content":"2.4 zigzag双旋 先顺时针旋转p(zig)，后逆时针旋转g(zag) 旋转代码 /// \u003csummary\u003e /// ZigZag 双旋（先右旋p后左旋g） ///（先顺时针旋转p(zig)，后逆时针旋转g(zag)） /// g /// / \\ /// T0 p /// / \\ /// v T3 /// / \\ /// T1 T2 /// /// zig-zag双旋后 /// v(b) /// / \\ /// g(a) p(c) /// / \\ / \\ /// T0 T1 T2 T3 /// /// \u003c/summary\u003e /// \u003cparam name=\"tree\"\u003e非空孙辈节点\u003c/param\u003e /// \u003creturns\u003e该树新的的根节点\u003c/returns\u003e public Node ZigZag(Node tree) { Node v = tree, p = v.Parent, g = p.Parent, r = g.Parent; Node a = g, b = v, c = p; Node T0 = g.L, T1 = v.L, T2 = v.R, T3 = p.R; a.L = T0; if (T0 != null) T0.Parent = a; a.R = T1; if (T1 != null) T1.Parent = a; UpdateHeight(a); c.L = T2; if (T2 != null) T2.Parent = c; c.R = T3; if (T3 != null) T3.Parent = c; UpdateHeight(c); b.L = a; a.Parent = b; b.R = c; c.Parent = b; UpdateHeight(b); Connect(r, b); //根节点和父节点联接 return b;//该树新的的根节点 } ","date":"2020-09-03 21:09:12","objectID":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/:2:4","tags":["数据结构"],"title":"【数据结构】 AVL树详解（可视化工具）","uri":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["数据结构"],"content":"0X03 查找 /// \u003csummary\u003e /// 查找 /// \u003c/summary\u003e /// \u003cparam name=\"tree\"\u003e\u003c/param\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public Node Search(Node tree,int key) { return SearchIn(tree, key, out _); } /// \u003csummary\u003e /// 查找键值key的节点并且返回（key对应节点为命中节点） /// \u003c/summary\u003e /// \u003cparam name=\"tree\"\u003e子树\u003c/param\u003e /// \u003cparam name=\"key\"\u003e查找键值\u003c/param\u003e /// \u003cparam name=\"hot\"\u003e返回命中节点的父节点，如果不存在命中节点则返回预判命中节点的父节点；（当命中节点为tree时，hot为NULL）\u003c/param\u003e /// \u003creturns\u003e命中节点\u003c/returns\u003e public Node SearchIn(Node tree, int key, out Node hot) { // hot :如果没有命中节点，则hot命中后做多只有一个节点，且key是对应另外一个孩子空节点位置 Node n = tree; if (tree == key) //在子树根节点tree处命中 { hot = null; return tree; } for (; ; ) { hot = n; n = n \u003e key ? n.L : n.R; if (n == null || n == key) return n; //返回命中节点，hot指向父节点，hot必然命中（在key不存在时,n==null） } } ","date":"2020-09-03 21:09:12","objectID":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/:3:0","tags":["数据结构"],"title":"【数据结构】 AVL树详解（可视化工具）","uri":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["数据结构"],"content":"0X04 插入 插入节点的代码 public Node Insert(int key) { Console.WriteLine($\"Insert:{key}\"); //打印日志 Node n = Insert(Root, key); PrintTree(Root);//打印日志 打印树 return n; } public Node Insert(Node tree, int key) { if (Root == null) return Root = CreateNode(key); Node hot; Node x = SearchIn(tree, key, out hot); if (x != null) return x; x = CreateNode(key, hot); //hot最多只有一个节点 for (Node n = hot; n != null; n = n.Parent) // //从x之父出发向上，逐层检查各代祖先g { if (!IsBalanced(n)) //一旦发现g失衡，则（采用“3 + 4”算法）使之复衡，并将子树 { RotateAt(n); break; //g复衡后，局部子树高度必然复原；其祖先亦必如此，故调整随即结束 } else //否则（g依然平衡），只需简单地 UpdateHeight(n); //更新其高度（注意：即便g未失衡，高度亦可能增加） } // 至多只需一次调整；若果真做过调整，则全树高度必然复原 return x; //返回新节点位置 } ","date":"2020-09-03 21:09:12","objectID":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/:4:0","tags":["数据结构"],"title":"【数据结构】 AVL树详解（可视化工具）","uri":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["数据结构"],"content":"0X05 删除 删除节点的代码 /// \u003csummary\u003e /// 删除节点 /// \u003c/summary\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e Node Remove(int key) { Console.WriteLine($\"Remove:{key}\"); //打印日志 Node n = Remove(Root, key); PrintTree(Root);//打印日志 打印树 return n; } Node Remove(Node tree,int key) { Node hot; Node x = SearchIn(tree, key, out hot); x = RemoveAt(x, out hot); for (Node n = hot; n != null; n = n.Parent) // //从x之父出发向上，逐层检查各代祖先g { if (!IsBalanced(n)) //一旦发现g失衡，则（采用“3 + 4”算法）使之复衡，并将子树 { RotateAt(n); break; //g复衡后，局部子树高度必然复原；其祖先亦必如此，故调整随即结束 } else //否则（g依然平衡），只需简单地 UpdateHeight(n); //更新其高度（注意：即便g未失衡，高度亦可能增加） } // 至多只需一次调整；若果真做过调整，则全树高度必然复原 return x; } Node RemoveAt(Node x,out Node hot) { if (x == null) { hot = null; return null; } Node succ=null; Node parent = x.Parent; if (!HasLeft(x)) succ = x.R; else if (!HasRight(x)) succ = x.L; else { succ = Successor(x); SwapData(x, succ); x = succ; succ = x.R; //succ = Successor(x) 这行执行前，succ是x的后继，而且succ是x右子树中的一个节点，所以succ是没有左孩子的，可能有右孩子，那么succ的后继只能是succ.Parent，继succ=x.Parent parent = x.Parent; } if (IsLeft(x)) x.Parent.L = null; //断开父节点的连接 else if (IsRight(x)) x.Parent.R = null; //断开父节点的连接 Connect(parent, succ); hot = parent; x.L = x.R = x.Parent = null; //clean return x; } ","date":"2020-09-03 21:09:12","objectID":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/:5:0","tags":["数据结构"],"title":"【数据结构】 AVL树详解（可视化工具）","uri":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["数据结构"],"content":"0X07 打印二叉树代码（C#） public void Print(Node node) { Console.Write($\"{node.Key},\"); } /// \u003csummary\u003e /// 打印二叉树 打印数值最大3位数 /// \u003c/summary\u003e /// \u003cparam name=\"tree\"\u003e树的根节点\u003c/param\u003e public static void PrintTree(Node tree) { System.Text.StringBuilder builder = new System.Text.StringBuilder(); PrintTree(tree, builder); Console.WriteLine(builder.ToString()); } static void PrintTree(Node tree,System.Text.StringBuilder builder) { List\u003cList\u003cNode\u003e\u003e list = new List\u003cList\u003cNode\u003e\u003e(); Queue\u003cNode\u003e queue = new Queue\u003cNode\u003e(); Queue\u003cNode\u003e queue1 = null; queue.Enqueue(tree); while(queue.Count\u003e0) { List\u003cNode\u003e levels = new List\u003cNode\u003e(); queue1 = new Queue\u003cNode\u003e(); int nullCount = 0; while (queue.Count\u003e0) { Node n = queue.Dequeue(); Node l=n!=null?n.L:null, r= n != null ? n.R : null; levels.Add(n); queue1.Enqueue(l); queue1.Enqueue(r); nullCount += l == null ? 1 : 0; nullCount += r == null ? 1 : 0; } queue = queue1; list.Add(levels); if(queue.Count==nullCount) { break; } } int level = list.Count; int maxLevelNodeCount = GetMaxNodeCountByDepth(level); int space=0; for (int i = level-1; i \u003e=0; i--) { System.Text.StringBuilder sb = new System.Text.StringBuilder(); System.Text.StringBuilder top = new System.Text.StringBuilder(); int space1 = space; space = space * 2 + 1; for (int s = 0; s \u003c space1; s++) { sb.Append(\" \"); top.Append(\" \"); } List\u003cNode\u003e ls = list[i]; for (int k = 0; k \u003c ls.Count; k++) { string v = ls[k] == null ? \" N \" : ls[k].Key.ToString(\"D3\"); sb.Append($\"{v}\"); top.Append(\"/ \\\\\"); for (int j = 0; j \u003c space; j++) { sb.Append($\" \"); top.Append($\" \"); } } top.Append(\"\\n\"); sb.Append(\"\\n\"); if (i!=level-1) builder.Insert(0, top.ToString()); builder.Insert(0, sb.ToString()); } } 打印结果： 打印数值最大3位数 ","date":"2020-09-03 21:09:12","objectID":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/:6:0","tags":["数据结构"],"title":"【数据结构】 AVL树详解（可视化工具）","uri":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["数据结构"],"content":"0X07 完整代码（C#） 完整代码(github) ","date":"2020-09-03 21:09:12","objectID":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/:7:0","tags":["数据结构"],"title":"【数据结构】 AVL树详解（可视化工具）","uri":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["数据结构"],"content":"0X08 AVL树测试 测试完整代码(github)和完整代码一样 测试插入和删除。测试中对zig、zag、zigzag、zagzig操作在插入时都执行了；删除操作执行了部分操作，剩余可以自己完善测试案例， 测试代码 static void Main1() { AVLTree tree = new AVLTree(); Node n,n1,n2; tree.Insert(20); tree.Insert(10); tree.Insert(7); /* 执行zig （插入节点后右旋20）*/ tree.Insert(24); tree.Insert(26); /* 执行zag （插入节点后左旋20）*/ tree.Insert(12); /* 执行zig-zag （插入节点后先右旋24后左旋10）*/ tree.Insert(14); tree.Insert(16); /* 执行zag （插入节点后左旋12）*/ tree.Insert(13); /* 执行zig-zag （插入节点后先右旋14后左旋10）*/ tree.Insert(17); /* 执行zag-zig （插入节点后先左旋12后右旋20）*/ tree.Insert(18); /* 执行zag （插入节点后左旋16）*/ Console.Write(\" Preorder::\"); tree.Preorder(tree.Root); Console.WriteLine(); Console.Write(\" Inorder::\"); tree.Inorder(tree.Root); Console.WriteLine(); Console.Write(\" Postorder::\"); tree.Postorder(tree.Root); Console.WriteLine(); Console.Write(\" Levelorder::\"); tree.Levelorder(tree.Root); Console.WriteLine(); Console.Write(\" ZLevelorder:\"); tree.ZLevelorder(tree.Root); Console.WriteLine(\"\\n\\n\"); tree.Remove(14); tree.Remove(12);/* 执行zig （删除节点后右旋13）*/ tree.Remove(10); tree.Remove(7); /* 执行zag （删除节点后左旋16）*/ tree.Remove(26);/* 执行zag-zig （删除节点后先左旋16后右旋20）*/ tree.Remove(17); tree.Remove(18); Console.ReadKey(); } 测试结果 Insert:20 020 Insert:10 020 / \\ 010 N Insert:7 010 / \\ 007 020 Insert:24 010 / \\ 007 020 / \\ / \\ N N N 024 Insert:26 010 / \\ 007 024 / \\ / \\ N N 020 026 Insert:12 020 / \\ 010 024 / \\ / \\ 007 012 N 026 Insert:14 020 / \\ 010 024 / \\ / \\ 007 012 N 026 / \\ / \\ / \\ / \\ N N N 014 N N N N Insert:16 020 / \\ 010 024 / \\ / \\ 007 014 N 026 / \\ / \\ / \\ / \\ N N 012 016 N N N N Insert:13 020 / \\ 012 024 / \\ / \\ 010 014 N 026 / \\ / \\ / \\ / \\ 007 N 013 016 N N N N Insert:17 014 / \\ 012 020 / \\ / \\ 010 013 016 024 / \\ / \\ / \\ / \\ 007 N N N N 017 N 026 Insert:18 014 / \\ 012 020 / \\ / \\ 010 013 017 024 / \\ / \\ / \\ / \\ 007 N N N 016 018 N 026 Preorder::14,12,10,7,13,20,17,16,18,24,26, Inorder::7,10,12,13,14,16,17,18,20,24,26, Postorder::7,10,13,12,16,18,17,26,24,20,14, Levelorder::14,12,20,10,13,17,24,7,16,18,26, ZLevelorder:14,20,12,10,13,17,24,26,18,16,7, Remove:14 016 / \\ 012 020 / \\ / \\ 010 013 017 024 / \\ / \\ / \\ / \\ 007 N N N N 018 N 026 Remove:12 016 / \\ 010 020 / \\ / \\ 007 013 017 024 / \\ / \\ / \\ / \\ N N N N N 018 N 026 Remove:10 016 / \\ 013 020 / \\ / \\ 007 N 017 024 / \\ / \\ / \\ / \\ N N N N N 018 N 026 Remove:7 020 / \\ 016 024 / \\ / \\ 013 017 N 026 / \\ / \\ / \\ / \\ N N N 018 N N N N Remove:26 017 / \\ 016 020 / \\ / \\ 013 N 018 024 Remove:17 018 / \\ 016 020 / \\ / \\ 013 N N 024 ","date":"2020-09-03 21:09:12","objectID":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/:8:0","tags":["数据结构"],"title":"【数据结构】 AVL树详解（可视化工具）","uri":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["数据结构"],"content":"0X09 AVL树可视化工具 AVL树可视化工具（旧金山大学 (usfca)|数据结构可视化工具） ","date":"2020-09-03 21:09:12","objectID":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/:9:0","tags":["数据结构"],"title":"【数据结构】 AVL树详解（可视化工具）","uri":"/avl%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["数据结构"],"content":" 二叉查找树又叫 二叉排序树、二叉搜索树 文章中树的概念和二叉树的定义转自二叉查找树(一)之 图文解析 和 C语言的实现 前驱节点和后继节点 参考：二叉搜索树的前驱节点和后继节点 删除节点参考：二叉查找树 - 删除节点 详解(Java实现) 本文对前驱节点、后继节点、删除操作进行着重讲解 完整代码是C#实现 ","date":"2020-09-03 21:09:12","objectID":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/:0:0","tags":["数据结构"],"title":"【数据结构】 二叉查找树(二叉排序树、二叉搜索树)详解（可视化工具）","uri":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"},{"categories":["数据结构"],"content":"0X01 节点的定义 节点的定义 public class Node { public int Key; public Node Parent;//parent public Node L; //left public Node R; //right } 树的定义 public class BSTree { //树的根节点 public Node Root; } ","date":"2020-09-03 21:09:12","objectID":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/:1:0","tags":["数据结构"],"title":"【数据结构】 二叉查找树(二叉排序树、二叉搜索树)详解（可视化工具）","uri":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"},{"categories":["数据结构"],"content":"0X02 遍历 这里列举 前序遍历、中序遍历、后序遍历、层次遍历、Z形(蛇形)遍历。 ==二叉搜索树的中序遍历是单调递增的== ","date":"2020-09-03 21:09:12","objectID":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/:2:0","tags":["数据结构"],"title":"【数据结构】 二叉查找树(二叉排序树、二叉搜索树)详解（可视化工具）","uri":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"},{"categories":["数据结构"],"content":"2.1 前序遍历 public void Preorder(Node n) { if (n == null) return; Print(n); Preorder(n.L); Preorder(n.R); } ","date":"2020-09-03 21:09:12","objectID":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/:2:1","tags":["数据结构"],"title":"【数据结构】 二叉查找树(二叉排序树、二叉搜索树)详解（可视化工具）","uri":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"},{"categories":["数据结构"],"content":"2.2 中序遍历 /// \u003csummary\u003e /// 中序遍历 /// \u003c/summary\u003e /// \u003cparam name=\"n\"\u003e\u003c/param\u003e public void Inorder(Node n) { if (n == null) return; Inorder(n.L); Print(n); Inorder(n.R); } ==二叉搜索树的中序遍历是单调递增的== ","date":"2020-09-03 21:09:12","objectID":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/:2:2","tags":["数据结构"],"title":"【数据结构】 二叉查找树(二叉排序树、二叉搜索树)详解（可视化工具）","uri":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"},{"categories":["数据结构"],"content":"2.3 后序遍历 /// \u003csummary\u003e /// 后序遍历 /// \u003c/summary\u003e /// \u003cparam name=\"n\"\u003e\u003c/param\u003e public void Postorder(Node n) { if (n == null) return; Postorder(n.L); Postorder(n.R); Print(n); } ","date":"2020-09-03 21:09:12","objectID":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/:2:3","tags":["数据结构"],"title":"【数据结构】 二叉查找树(二叉排序树、二叉搜索树)详解（可视化工具）","uri":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"},{"categories":["数据结构"],"content":"2.4 层次遍历 /// \u003csummary\u003e /// 层次遍历 /// \u003c/summary\u003e /// \u003cparam name=\"n\"\u003e\u003c/param\u003e public void Levelorder(Node n) { if (n == null) return; Queue\u003cNode\u003e queue = new Queue\u003cNode\u003e(); queue.Enqueue(n); while(queue.Count\u003e0) { var item = queue.Dequeue(); if (item == null) continue; Print(item); queue.Enqueue(item.L); queue.Enqueue(item.R); } } ","date":"2020-09-03 21:09:12","objectID":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/:2:4","tags":["数据结构"],"title":"【数据结构】 二叉查找树(二叉排序树、二叉搜索树)详解（可视化工具）","uri":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"},{"categories":["数据结构"],"content":"2.5 Z形(蛇形)遍历 /// \u003csummary\u003e /// Z形(蛇形)遍历 /// \u003c/summary\u003e /// \u003cparam name=\"n\"\u003e\u003c/param\u003e public void ZLevelorder(Node n) { Stack\u003cNode\u003e stackl2r = new Stack\u003cNode\u003e(); Stack\u003cNode\u003e stackr2l = new Stack\u003cNode\u003e(); stackl2r.Push(n); while(stackl2r.Count\u003e0|| stackr2l.Count \u003e 0) { while (stackl2r.Count\u003e0) { n = stackl2r.Pop(); if (n == null) continue; Print(n); stackr2l.Push(n.L); stackr2l.Push(n.R); } while (stackr2l.Count \u003e 0) { n = stackr2l.Pop(); if (n == null) continue; Print(n); stackl2r.Push(n.R); stackl2r.Push(n.L); } } } ","date":"2020-09-03 21:09:12","objectID":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/:2:5","tags":["数据结构"],"title":"【数据结构】 二叉查找树(二叉排序树、二叉搜索树)详解（可视化工具）","uri":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"},{"categories":["数据结构"],"content":"0X03 前驱节点和后继节点详解 前驱节点：对一棵二叉树进行中序遍历，按照遍历后的顺序，当前节点的前一个节点为该节点的前驱节点。 后继节点：对一棵二叉树进行中序遍历，按照遍历后的顺序，当前节点的后一个节点为该节点的后继节点 ","date":"2020-09-03 21:09:12","objectID":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/:3:0","tags":["数据结构"],"title":"【数据结构】 二叉查找树(二叉排序树、二叉搜索树)详解（可视化工具）","uri":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"},{"categories":["数据结构"],"content":"3.1 前驱节点 若一个节点有左子树，那么该节点的前驱节点是其左子树中键值最大的节点（按照中序遍历，左子树中最大的节点后继就是父节点即当前节点）（==果有左子树，那么前驱节点是左子树中最大值==） 若一个节点没有左子树，那么判断该节点和其父节点的关系 ： 2.1 若该节点是其父节点的右边孩子，那么该节点的前驱结点即为其父节点。（==若该节点是右孩子，则前驱节点为它的父节点==）（按照中序遍历该节点是右孩子且没有该节点没有左孩子，则该节点的父节点的右子树中最小的节点即是后续节点，反过来父节点为该节点的前驱节点） 例：上图7的前驱是6 2.2 若该节点是其父节点的左边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的右边孩子，那么Q就是该节点的后继节点。（==若该节点是左孩子则找到最近的父节点且父节点的右孩子是该节点所在的子树，找到的那个父节点即为前驱节点==） 例：上图2的前驱是1，8的前驱是7 /// \u003csummary\u003e /// 前驱节点 /// 对一棵二叉树进行中序遍历，按照遍历后的顺序，当前节点的前一个节点为该节点的前驱节点 /// \u003c/summary\u003e /// \u003cparam name=\"node\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public Node Predecessor(Node node) { Node n = null; if (node == null) return null; //1.如果有左子树，那么前驱节点是左子树中最大值 else if (HasLeft(node)) return Maximum(node.L); //2.1如果是右孩子，node的前驱节点为它的父节点 else if (IsRight(node)) return node.Parent; //2.2如果是左孩子则找到最低的父节点且父节点的右孩子是node所在的子树 //另一种说法：如果是左孩子则找到node所在子树被称为右子树的父节点 else if (IsLeft(node)) { n = node.Parent; while (n != null) { if (IsLeft(n)) n = n.Parent; else return n.Parent; } } return null; } ","date":"2020-09-03 21:09:12","objectID":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/:3:1","tags":["数据结构"],"title":"【数据结构】 二叉查找树(二叉排序树、二叉搜索树)详解（可视化工具）","uri":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"},{"categories":["数据结构"],"content":"3.2 后继节点 若一个节点有右子树，那么该节点的后继节点是其右子树中val值最小的节点（==如果有右子树，那么后继节点是左子树中最大值==） 若一个节点没有右子树，那么判断该节点和其父节点的关系 ： 2.1 若该节点是其父节点的左边孩子，那么该节点的后继结点即为其父节点 （==如果是左孩子，该节点的后继节点为它的父节点==） 例：上图8的后继是9 2.2 若该节点是其父节点的右边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的左边孩子，那么Q就是该节点的后继节点（==该节点如果是右孩子则找到最近的父节点且父节点的左孩子是node所在的子树，找到的那个父节点即为后继节点==） 例：上图4的后继是5 /// \u003csummary\u003e /// 后继节点 /// 对一棵二叉树进行中序遍历，按照遍历后的顺序，当前节点的后一个节点为该节点的后继节点 /// \u003c/summary\u003e /// \u003cparam name=\"node\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public Node Successor(Node node) { Node n = null; //1.如果有右子树，那么后继节点是左子树中最大值 if (HasRight(node)) return Minimum(node.R); //2.1 如果是左孩子，node的后继节点为它的父节点 else if (IsLeft(node)) return node.Parent; //2.2 如果是右孩子则找到最低的父节点且父节点的左孩子是node所在的子树 //另一种说法：如果是右孩子则找到node所在子树被称为左子树的父节点 else if (IsRight(node)) { n = node.Parent; while (n != null) { if (IsRight(n)) n = n.Parent; else return n.Parent; } } return null; } ","date":"2020-09-03 21:09:12","objectID":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/:3:2","tags":["数据结构"],"title":"【数据结构】 二叉查找树(二叉排序树、二叉搜索树)详解（可视化工具）","uri":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"},{"categories":["数据结构"],"content":"0X04 查找 /// \u003csummary\u003e /// 查找 /// \u003c/summary\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public Node Search(int key) { return Search(Root, key); } public Node Search(Node node,int key) { if(node == null|| node.Key==key) { return node; } if (node.Key \u003e key) return Search(node.L,key); else return Search(node.R, key); } ","date":"2020-09-03 21:09:12","objectID":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/:4:0","tags":["数据结构"],"title":"【数据结构】 二叉查找树(二叉排序树、二叉搜索树)详解（可视化工具）","uri":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"},{"categories":["数据结构"],"content":"0X05 插入 /// \u003csummary\u003e /// 插入 /// \u003c/summary\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public Node Insert(int key) { return Insert(CreateNode(key)); } public Node Insert(Node node) { if (Root == null) { Root = node; return Root; } Node n = Root; Node x =null; while(n!=null) { x = n; if (node \u003e n) n = n.R; else if (node \u003c n) n = n.L; else { n = n.L; //允许插入相同键值，如果不允许注释该行，将return注释取消 //return n; } } node.Parent = x; if (node \u003e x) x.R = node; else x.L = node; return node; } ","date":"2020-09-03 21:09:12","objectID":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/:5:0","tags":["数据结构"],"title":"【数据结构】 二叉查找树(二叉排序树、二叉搜索树)详解（可视化工具）","uri":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"},{"categories":["数据结构"],"content":"0X06 删除详解 删除节点存在 3 种情况，几乎所有类似博客都提到了这点。这 3 种情况分别如下： 没有左右子节点，可以直接删除 存在左节点或者右节点，删除后需要对子节点移动 同时存在左右子节点，不能简单的删除，但是可以通过和后继节点交换后转换为前两种情况（后继节点不可能存在左孩子，有可能有右孩子；）(按照后继节点定义在有右孩子情况下后继节点只能是该节点的右子树最小的节点（所以这个节点没有左孩子，因为它是最小的）） /// \u003csummary\u003e /// 删除 /// \u003c/summary\u003e /// \u003cparam name=\"n\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public Node Remove(Node n) { Node x=null; //1. 没有左右子节点 if (!HasChild(n)) { if (IsLeft(n)) n.Parent.L = null; else n.Parent.R = null; } //2. 存在左节点或者右节点，删除后需要对子节点移动 else if (HasOneChild(n)) { x = n.L == null ? n.R : n.L; if (IsLeft(n)) n.Parent.L = x; else n.Parent.R = x; } //3. 同时存在左右子节点，通过和后继节点交换后转换为前两种情况（后继节点不可能存在左孩子，有可能有右孩子；） else { //找到后继节点，将后继节点填到删除节点位置，(继节点不可能有左孩子，可能右孩子，也就是变为删除后继节点问题，且后继节点最多有一个孩子节点（右孩子）) Node successorNode = Successor(n); //找到删除节点n的后继节点，后继节点不可能存在左孩子，有可能有右孩子 Node rightNode = successorNode.R; if(rightNode!=null) { rightNode.Parent = successorNode.Parent; } if (successorNode.Parent != null) if (IsLeft(successorNode)) successorNode.Parent.L = rightNode; else successorNode.Parent.R = rightNode; successorNode.Parent = n.Parent; if (IsLeft(n)) n.Parent.L = successorNode; else if (IsRight(n)) n.Parent.R = successorNode; else Root = successorNode; successorNode.L = n.L; if (n.L != null) n.L.Parent = successorNode; successorNode.R = n.R; if (n.R != null) n.R.Parent = successorNode; } n.L = null; n.R = null; n.Parent = null; return n; } ","date":"2020-09-03 21:09:12","objectID":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/:6:0","tags":["数据结构"],"title":"【数据结构】 二叉查找树(二叉排序树、二叉搜索树)详解（可视化工具）","uri":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"},{"categories":["数据结构"],"content":"0X07 完整代码（C#） 完整代码（github） ","date":"2020-09-03 21:09:12","objectID":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/:7:0","tags":["数据结构"],"title":"【数据结构】 二叉查找树(二叉排序树、二叉搜索树)详解（可视化工具）","uri":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"},{"categories":["数据结构"],"content":"0X08 可视化工具 二叉搜索树可视化工具（旧金山大学 (usfca)|数据结构可视化工具） ","date":"2020-09-03 21:09:12","objectID":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/:8:0","tags":["数据结构"],"title":"【数据结构】 二叉查找树(二叉排序树、二叉搜索树)详解（可视化工具）","uri":"/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"},{"categories":["数据结构"],"content":" 参考：邓俊辉 的数据结构，图片来自该资料 除了AVL树，本章将按照二叉搜索树的介绍，继续介绍平衡二叉搜索树家族中的另一个成员—Splay伸展树。 ","date":"2020-09-03 21:09:12","objectID":"/%E4%BC%B8%E5%B1%95%E6%A0%91%E8%AF%A6%E8%A7%A3/:0:0","tags":["数据结构"],"title":"【数据结构】 伸展树详解（SplayTree）（可视化工具）","uri":"/%E4%BC%B8%E5%B1%95%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["数据结构"],"content":"伸展树（SplayTree） 相对于AVL，Splay的实现更为简捷。伸展树无需时刻都严格地保持全树的平衡，但却能够在任何足够长的真实操作序列中，保持分摊意义上的高效率。伸展树也不需要对基本的二叉树节点结构，做任何附加的要求或改动，更不需要记录平衡因子或高度之类的额外信息，故适用范围更广。 通常在任意数据结构的生命期内，执行不同操作的概率往往极不均衡，而且各操作之间具有极强的相关性，并在整体上多呈现出极强的规律性。其中最为典型的，就是所谓的“==数据局部性==”(data locality)，这包括两个方面的含义: 刚刚被访问过的元素，极有可能在不久之后再次被访问到 将被访问的下一元素，极有可能就处于不久之前被访问过的某个元素的附近 如果将该策略应用于二叉搜索树。只需将刚被访问的节点，及时地“转移”至树根(附近)，即可加速后续的操作。当然， 转移前后的搜索树必须相互等价，故为此使用前文介绍的“旋转“等价变换的技巧。 逐层伸展 每访问过一个节点之后，随即反复地以它的父节点为轴，经适当的旋转将其提升一层，直至最终成为树根。以下图为例，若深度为3的节点E刚被访问–无论查找或插入，甚至“删除”都可通过3次旋转，将该树等价变换为以E为根的另一棵二叉搜索树 随着节点E的逐层上升，两侧子树的结构也不断地调整，故这一过程也形象地称作伸展 (splaying)，而采用这一调整策略的二叉搜索树也因此得名。不过，为实现真正意义上的伸 展树，还须对以上策略做点微妙而本质的改进。之所以必须改进，是因为目前的策略仍存在致命 的缺陷—对于很多访问序列，单次访问的分摊时间复杂度在极端情况下可能高达n。 不难验证，若从空树开始依次插入关键码{ 1, 2, 3, 4, 5 }，且其间采用如上调整策略， 则可得到如下图所示的二叉搜索树。 在各次访问之后，为将对应节点伸展调整至树根，分别需做4、4、3、2和1次旋转。 一般地，若节点总数为n，则旋转操作的总次数应为: (n - 1) + { (n - 1) + (n - 2) + … + 1 }= (n^2^ +n-2)/2 = O( n^2^)。 如此分摊下来，每次访问平均需要n时间。很遗憾，这一效率不仅远远低于AVL树，而且甚至与原始的二叉搜索树的最坏情况相当。 而事实上，问题还远不止于此。稍做比对即不难发现，上图a与f中二叉搜索树的结构完全相同。也就是说，经过以上连续的5次访问之后，全树的结构将会复原! 这就意味着，以上情况可以持续地再现。 当然，这一实例，完全可以推广至规模任意的二叉搜索树。于是对于规模为任意n的伸展树， 只要按关键码单调的次序，周期性地反复进行查找，则无论总的访问次数m » n有多大，就分摊意义而言，每次访问都将需要O(n)时间! 双层伸展 为克服上述伸展调整策略的缺陷，一种简便且有效的方法就是:将逐层伸展改为双层伸展。 具体地，每次都从当前节点v向上追溯两层(而不是仅一层)，并根据其父亲p以及祖父g的相对位置，进行相应的旋转。主要以下分三类情况： zig-zig/zag-zag 如下图所示， 设v是p的左孩子，且p也是g的左孩子; 设W和X分别是v的左、右子树，Y和Z分别是p和g的右子树。 针对这种情况，首先以节点g为轴做顺时针旋转zig(g)，其效果如图(b)所示。然后，再以p 为轴做顺时针旋转zig(p)，其效果如图(c)所示。如此连续的两次zig旋转，合称zig-zig调整。 自然地，另一完全对称的情形，v是p的右孩子，且p也是g的右孩子，则可通过连续的 两次逆时针旋转实现调整，合称zag-zag操作。 zig-zag/zag-zig 如下图所示，设v是p的左孩子，而p是g的右孩子; 设W是g的左子树，X和Y分别是v的左右子树，Z是p的右子树。 针对这种情况，首先以节点p为轴做顺时针旋转zig(p)，其效果如(b)所示。然后，再以g 为轴做逆时针旋转zag(g)，其效果如图(c)所示。如此zig旋转再加zag旋转，合称zig-zag调整。 同样地，另一完全对称的情形–v是p的右孩子，而p是g的左孩子—则可通过zag旋转再加zig旋转实现调整，合称zag-zig操作。 zig/zag 如下图所示，若v最初的深度为奇数，则经过若干次双层调整至最后一次调整时， v的父亲p即是树根r。 将v的左、右子树记作X和Y，节点p = r的另一子树记作Z。 此时，只需围绕p = r做顺时针旋转zig(p)，即 可如图(b)所示，使v最终攀升至树根，从而结束整个伸展调整的过程。 效果与效率 综合以上各种情况，每经过一次双层调整操作，节点v都会上升两层。若v的初始深度depth(v) 为偶数，则最终v将上升至树根。若depth(v)为奇数，则当v上升至深度为1时，不妨最后再相应 地做一次zig或zag单旋操作。无论如何，经过depth(v)次旋转后，v最终总能成为树根。 回顾最开始的单层伸展的例子中：在可持续重复的过程中，二叉搜索树的高度始终不小于n/2; 而且，至少有一半的节点在接受访问时，不仅没有如最初设想的那样靠近树根，而且反过来恰恰处于最底层。 从树高的角度看，问题根源也可再进一步地解释为：在持续访问的过程中，树高依算术级数逐步从n - 1递减至n/2，然后再逐步递增回到n - 1。 以如下图所示的二叉搜索树为例，在find(1)操作之后，采用逐层调整策略与双层调 整策略的效果，分别如图(a)和图(c)所示。 可见，最深节点(1)被访问之后再经过双层调整，不仅同样可将该节点伸展至树根，而且==同时可使树的高度接近于减半==。就树的形态而言，双层伸展策略可“智能”地“折叠”被访问的 子树分支，从而有效地避免对长分支的连续访问。这就意味着，即便节点v的深度为n，双层 伸展策略既可将v推至树根，亦可令对应分支的长度以几何级数(大致折半)的速度收缩。 ","date":"2020-09-03 21:09:12","objectID":"/%E4%BC%B8%E5%B1%95%E6%A0%91%E8%AF%A6%E8%A7%A3/:1:0","tags":["数据结构"],"title":"【数据结构】 伸展树详解（SplayTree）（可视化工具）","uri":"/%E4%BC%B8%E5%B1%95%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["数据结构"],"content":"伸展代码 /// \u003csummary\u003e /// 伸展操作 /// Zig:右旋转，顺时针旋转 /// Zag:左旋转，逆时针旋转 /// /// - 单旋(单层伸展) /// zig zag /// （顺时针旋转g） （逆时针旋转g） /// g g /// / \\ / \\ /// p T3 T0 p /// / \\ / \\ /// v T2 T1 v /// / \\ / \\ /// T0 T1 T2 T3 /// /// zig单旋后： zag单旋后： /// p p /// / \\ / \\ /// v g g v /// / \\ / \\ / \\ / \\ /// T0 T1 T2 T3 T0 T1 T2 T3 /// /// - 双旋(双层伸展) /// zig-zig zig-zag zag-zag zag-zig /// （先顺时针旋转g，后顺时针旋转p） （先顺时针旋转p(zig)，后逆时针旋转g(zag)） （先逆时针旋转g，后逆时针旋转p） （先逆时针旋转p(zag)，后顺时针旋转g(zig)） /// g g g g /// / \\ / \\ / \\ / \\ /// p T3 T0 p T0 p p T3 /// / \\ / \\ / \\ / \\ /// v T2 v T3 T1 v T0 v /// / \\ / \\ / \\ / \\ /// T0 T1 T1 T2 T2 T3 T1 T2 /// /// 双旋后： zig-zig 双旋后 zig-zag双旋后 zag-zag 双旋后 zag-zig双旋后 /// v v v v /// / \\ / \\ / \\ / \\ /// T0 p g p p T3 p g /// / \\ / \\ / \\ / \\ / \\ / \\ /// T1 g T0 T1 T2 T3 g T2 T0 T1 T2 T3 /// / \\ / \\ /// T2 T3 T0 T1 /// /// \u003c/summary\u003e /// \u003cparam name=\"v\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public Node Splay(Node v) { if (v==null) return null; Node g=null, p=null; while(!!(p=v.Parent)\u0026\u0026 !!(g=p.Parent))//自下而上，反复对v做双层伸展 { Node r = g.Parent; if(IsLeft(v)) { if(IsLeft(p)) //zig-zig 先旋转v的祖父节点，然后再旋转v的父节点 { AttachAsLChild(g, p.R);AttachAsLChild(p, v.R); AttachAsRChild(p, g);AttachAsRChild(v, p); } else //zig-zag 先旋转v的父节点，后旋转v的祖父节点 { AttachAsLChild(p, v.R); AttachAsRChild(g, v.L); AttachAsLChild(v, g); AttachAsRChild(v, p); } } else { if (IsRight(p))// zag-zag { AttachAsRChild(g, p.L); AttachAsRChild(p, v.L); AttachAsLChild(p, g); AttachAsLChild(v,p); } else //zag-zig { AttachAsRChild(p, v.L); AttachAsLChild(g, v.R); AttachAsRChild(v, g); AttachAsLChild(v, p); } } if (r == null)//若原v的曾祖父r不存在，则v现在为树根Root { v.Parent = null; } else { if (g == r.L) AttachAsLChild(r, v); else AttachAsRChild(r, v); } UpdateHeight(g); UpdateHeight(p); UpdateHeight(v); }//双层伸展结束时，必有g=null，但p可能非空 if(p==v.Parent\u0026\u0026p!=null) //如果p为非空，则需要做一次单旋 { if(IsLeft(v)) /* zig */ { AttachAsLChild(p, v.R);AttachAsRChild(v, p); } else /* zag */ { AttachAsRChild(p, v.L); AttachAsLChild(v, p); } UpdateHeight(p);UpdateHeight(v); } v.Parent = null; return v; } ","date":"2020-09-03 21:09:12","objectID":"/%E4%BC%B8%E5%B1%95%E6%A0%91%E8%AF%A6%E8%A7%A3/:2:0","tags":["数据结构"],"title":"【数据结构】 伸展树详解（SplayTree）（可视化工具）","uri":"/%E4%BC%B8%E5%B1%95%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["数据结构"],"content":"伸展树全部代码（C#） 全部代码（C#） ","date":"2020-09-03 21:09:12","objectID":"/%E4%BC%B8%E5%B1%95%E6%A0%91%E8%AF%A6%E8%A7%A3/:3:0","tags":["数据结构"],"title":"【数据结构】 伸展树详解（SplayTree）（可视化工具）","uri":"/%E4%BC%B8%E5%B1%95%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["数据结构"],"content":"伸展树测试 全部代码（C#） 测试代码 static void Main() { SplayTree tree = new SplayTree(); Node n, n1, n2; tree.Insert(20); tree.Insert(10); tree.Insert(7); tree.Insert(24); tree.Insert(26); tree.Insert(12); tree.Insert(18); Console.Write(\" Preorder::\"); tree.Preorder(tree.Root); Console.WriteLine(); Console.Write(\" Inorder::\"); tree.Inorder(tree.Root); Console.WriteLine(); Console.Write(\" Postorder::\"); tree.Postorder(tree.Root); Console.WriteLine(); Console.Write(\" Levelorder::\"); tree.Levelorder(tree.Root); Console.WriteLine(); Console.Write(\" ZLevelorder:\"); tree.ZLevelorder(tree.Root); Console.WriteLine(\"\\n\\n\"); tree.Remove(24); tree.Remove(20); tree.Remove(10); tree.Remove(18); tree.Remove(7); tree.Remove(26); tree.Remove(16); tree.Remove(12); Console.ReadKey(); } 测试结果 Insert:20 020 Insert:10 010 / \\ N 020 Insert:7 007 / \\ N 010 / \\ / \\ N N N 020 Insert:24 024 / \\ 020 N / \\ / \\ 010 N N N / \\ / \\ / \\ / \\ 007 N N N N N N N Insert:26 026 / \\ 024 N / \\ / \\ 020 N N N / \\ / \\ / \\ / \\ 010 N N N N N N N / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ 007 N N N N N N N N N N N N N N N Insert:12 012 / \\ 010 026 / \\ / \\ 007 N 020 N / \\ / \\ / \\ / \\ N N N N N 024 N N Insert:18 018 / \\ 012 020 / \\ / \\ 010 N N 026 / \\ / \\ / \\ / \\ 007 N N N N N 024 N Preorder::18,12,10,7,20,26,24, Inorder::7,10,12,18,20,24,26, Postorder::7,10,12,24,26,20,18, Levelorder::18,12,20,10,26,7,24, ZLevelorder:18,20,12,10,26,24,7, Remove:24 026 / \\ 018 N / \\ / \\ 012 020 N N / \\ / \\ / \\ / \\ 010 N N N N N N N / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ 007 N N N N N N N N N N N N N N N Remove:20 026 / \\ 018 N / \\ / \\ 012 N N N / \\ / \\ / \\ / \\ 010 N N N N N N N / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ 007 N N N N N N N N N N N N N N N Remove:10 012 / \\ 007 026 / \\ / \\ N N 018 N Remove:18 026 / \\ 012 N / \\ / \\ 007 N N N Remove:7 012 / \\ N 026 Remove:26 012 Remove:16 012 Remove:12 N ","date":"2020-09-03 21:09:12","objectID":"/%E4%BC%B8%E5%B1%95%E6%A0%91%E8%AF%A6%E8%A7%A3/:4:0","tags":["数据结构"],"title":"【数据结构】 伸展树详解（SplayTree）（可视化工具）","uri":"/%E4%BC%B8%E5%B1%95%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["数据结构"],"content":"可视化工具 可视化工具（旧金山大学 (usfca)|数据结构可视化工具） ","date":"2020-09-03 21:09:12","objectID":"/%E4%BC%B8%E5%B1%95%E6%A0%91%E8%AF%A6%E8%A7%A3/:5:0","tags":["数据结构"],"title":"【数据结构】 伸展树详解（SplayTree）（可视化工具）","uri":"/%E4%BC%B8%E5%B1%95%E6%A0%91%E8%AF%A6%E8%A7%A3/"},{"categories":["数据结构"],"content":" 文章中树的概念和二叉树的定义转自二叉查找树(一)之 图文解析 和 C语言的实现 ","date":"2020-09-03 21:09:12","objectID":"/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E8%AE%B2%E8%A7%A3/:0:0","tags":["数据结构"],"title":"【数据结构】树和二叉树基本讲解","uri":"/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E8%AE%B2%E8%A7%A3/"},{"categories":["数据结构"],"content":"0X01 树的概念 1. 树的定义 树是一种数据结构，它是由n（n\u003e=1）个有限节点组成一个具有层次关系的集合。 把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点： (01) 每个节点有零个或多个子节点； (02) 没有父节点的节点称为根节点； (03) 每一个非根节点有且只有一个父节点； (04) 除了根节点外，每个子节点可以分为多个不相交的子树。 2. 树的基本术语 若一个结点有子树，那么该结点称为子树根的\"双亲\"，子树的根是该结点的\"孩子\"。有相同双亲的结点互为\"兄弟\"。一个结点的所有子树上的任何结点都是该结点的后裔。从根结点到某个结点的路径上的所有结点都是该结点的祖先。 结点的度：结点拥有的子树的数目。 叶子：度为零的结点。 分支结点：度不为零的结点。 树的度：树中结点的最大的度。 层次：根结点的层次为1，其余结点的层次等于该结点的双亲结点的层次加1。 树的高度：树中结点的最大层次。 无序树：如果树中结点的各子树之间的次序是不重要的，可以交换位置。 有序树：如果树中结点的各子树之间的次序是重要的, 不可以交换位置。 森林：0个或多个不相交的树组成。对森林加上一个根，森林即成为树；删去根，树即成为森林。 ","date":"2020-09-03 21:09:12","objectID":"/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E8%AE%B2%E8%A7%A3/:0:1","tags":["数据结构"],"title":"【数据结构】树和二叉树基本讲解","uri":"/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E8%AE%B2%E8%A7%A3/"},{"categories":["数据结构"],"content":"0X02 二叉树的介绍 1. 二叉树的定义 二叉树是每个节点最多有两个子树的树结构。它有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；或者左、右子树皆为空。 2. 二叉树的性质 二叉树有以下几个性质：TODO(上标和下标) 性质1：二叉树第i层上的结点数目最多为 ==2^{i-1}^== (i≥1)。 性质2：深度为k的二叉树至多有==2^{k}^-1==个结点(k≥1)。 性质3：包含n个结点的二叉树的高度至少为==log~2~ (n+1)==。 性质4：在任意一棵二叉树中，若终端结点的个数为n~0~，度为2的结点数为n~2~，则n~0~=n~2~+1。 2.1 性质1：二叉树第i层上的结点数目最多为 2^{i-1}^ (i≥1) 证明：下面用\"数学归纳法\"进行证明。 (01) 当i=1时，第i层的节点数目为2^{i-1}^=2^{0}^=1。因为第1层上只有一个根结点，所以命题成立。 (02) 假设当i\u003e1，第i层的节点数目为2^{i-1}^。这个是根据(01)推断出来的！ 下面根据这个假设，推断出\"第(i+1)层的节点数目为2^{i}^“即可。 由于二叉树的每个结点至多有两个孩子，故\"第(i+1)层上的结点数目” 最多是 “第i层的结点数目的2倍”。即，第(i+1)层上的结点数目最大值=2×2^{i-1}^=2^{i}^。 故假设成立，原命题得证！ 2.2 性质2：深度为k的二叉树至多有2^{k}^-1个结点(k≥1) 证明：在具有相同深度的二叉树中，当每一层都含有最大结点数时，其树中结点数最多。利用\"性质1\"可知，深度为k的二叉树的结点数至多为： 2^0^+2^1^+…+2^k-1^=2^k^-1 故原命题得证！ 2.3 性质3：包含n个结点的二叉树的高度至少为log~2~ (n+1) 证明：根据\"性质2\"可知，高度为h的二叉树最多有2^{h}^–1个结点。反之，对于包含n个节点的二叉树的高度至少为log~2~(n+1)。 2.4 性质4：在任意一棵二叉树中，若终端结点的个数为n~0~，度为2的结点数为n~2~，则n~0~=n~2~+1 证明：因为二叉树中所有结点的度数均不大于2，所以结点总数(记为n)=“0度结点数(n~0~)” + “1度结点数(n~1~)” + “2度结点数(n~2~)\"。由此，得到等式一。 (等式一) n=n~0~+n~1~+n~2~ 另一方面，0度结点没有孩子，1度结点有一个孩子，2度结点有两个孩子，故二叉树中孩子结点总数是：n~1~+2n~2~。此外，只有根不是任何结点的孩子。故二叉树中的结点总数又可表示为等式二。 (等式二) n=n~1~+2n~2~+1 由(等式一)和(等式二)计算得到：n~0~=n~2~+1。原命题得证！ 3. 满二叉树，完全二叉树和二叉查找树 3.1 满二叉树 定义：高度为h，并且由2^{h}^ –1个结点的二叉树，被称为满二叉树。 3.2 完全二叉树 定义：一棵二叉树中，只有最下面两层结点的度可以小于2，并且最下一层的叶结点集中在靠左的若干位置上。这样的二叉树称为完全二叉树。 特点：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。显然，一棵满二叉树必定是一棵完全二叉树，而完全二叉树未必是满二叉树。 3.3 二叉查找树 定义：二叉查找树(Binary Search Tree)，又被称为二叉搜索树。设x为二叉查找树中的一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] \u003c= key[x]；如果y是x的右子树的一个结点，则key[y] \u003e= key[x]。 另一种定义：根节点的值大于等于其左子树中任意一个节点的值，小于等于其右节点中任意一节点的值，这一规则适用于二叉查找树中的每一个节点。 在二叉查找树中： (01) 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； (02) 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； (03) 任意节点的左、右子树也分别为二叉查找树。 (04) 没有键值相等的节点（no duplicate nodes）。 在实际应用中，二叉查找树的使用比较多。 ","date":"2020-09-03 21:09:12","objectID":"/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E8%AE%B2%E8%A7%A3/:0:2","tags":["数据结构"],"title":"【数据结构】树和二叉树基本讲解","uri":"/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E8%AE%B2%E8%A7%A3/"},{"categories":["Unity编辑器"],"content":"介绍自定义Inspector面板 假设为public class MyPlayer : MonoBehaviour类添加自定义Inspector面板 添加编辑器Editor代码如下（必须放在Editor目录中）： using UnityEditor; [CustomEditor(typeof(MyPlayer))] public class MyPlayerEditor : Editor { public override void OnInspectorGUI() { } } 实现OnInspectorGUI具体内容即可 */}} -- */}} -- ","date":"2020-09-02 17:38:56","objectID":"/unity%E7%BC%96%E8%BE%91%E5%99%A8-%E8%87%AA%E5%AE%9A%E4%B9%89inspector%E9%9D%A2%E6%9D%BF/:0:0","tags":["Unity编辑器"],"title":"【Unity编辑器】 自定义Inspector面板","uri":"/unity%E7%BC%96%E8%BE%91%E5%99%A8-%E8%87%AA%E5%AE%9A%E4%B9%89inspector%E9%9D%A2%E6%9D%BF/"},{"categories":["Unity编辑器"],"content":"写一个普通类 using System.Collections; using System.Collections.Generic; using UnityEngine; [ExecuteInEditMode] public class MyPlayer : MonoBehaviour { /// \u003csummary\u003e /// 枚举 /// 多选的时候枚举必须是2的次方值，有意义的最小值为1 /// \u003c/summary\u003e public enum CodingType { Nothing=0, One=1, Two=2, Three=4, Four=8, Five=16, } // Start is called before the first frame update public int id; public string playerName= \"https://codingriver.github.io \"; public string backStory= \"https://codingriver.github.io\"; public float health; public float damage; public float weaponDamage1, weaponDamage2; public string shoeName; public int shoeSize; public string shoeType; public GameObject obj; public Transform trans; public Material mat; public int popup; public int mixedPopup;//可以多选 public CodingType codingType; public CodingType mixedCodingType;//可以多选 public int gridId; public string password= \"codingriver\"; public bool isToggle; public GameObject go; public float knob=5.6f; public bool toggleGroupOpen; public float fadeGroupValue=1; void Start() { health = 50; } /// \u003csummary\u003e /// 将多选的值转换为多选数组的下标(多选后的值的计算和LayerMask.GetMask类似) /// 如果是枚举 则每个值+1后是对应的枚举 /// /// \u003c/summary\u003e /// \u003cparam name=\"mixedValue\"\u003emixed的值\u003c/param\u003e /// \u003cparam name=\"arrLen\"\u003e数组数量（如果是枚举则是枚举的数量，排除枚举为0的值）\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static List\u003cint\u003e ResolveMixed(int mixedValue, int arrLen) { List\u003cint\u003e ls = new List\u003cint\u003e(); //全选时值为-1 if (mixedValue == -1) { for (int i = 0; i \u003c arrLen; i++) ls.Add(i); return ls; } for (int i = 0; i \u003c 32; i++) { if ((mixedValue \u0026 1) == 1) ls.Add(i); mixedValue = mixedValue \u003e\u003e 1; } return ls; } private void Update() { } } 默认展示Inspector面板 ","date":"2020-09-02 17:38:56","objectID":"/unity%E7%BC%96%E8%BE%91%E5%99%A8-%E8%87%AA%E5%AE%9A%E4%B9%89inspector%E9%9D%A2%E6%9D%BF/:0:1","tags":["Unity编辑器"],"title":"【Unity编辑器】 自定义Inspector面板","uri":"/unity%E7%BC%96%E8%BE%91%E5%99%A8-%E8%87%AA%E5%AE%9A%E4%B9%89inspector%E9%9D%A2%E6%9D%BF/"},{"categories":["Unity编辑器"],"content":"添加Inspector的Editor类 using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEditor; using static MyPlayer; [CustomEditor(typeof(MyPlayer))] public class MyPlayerEditor : Editor { MyPlayer player; bool showWeapons; private void Awake() { Debug.Log(\"Awake\"); } private void OnEnable() { Debug.Log(\"OnEnable\"); //获取当前编辑自定义Inspector的对象 player = (MyPlayer)target; } private void OnDisable() { Debug.Log(\"OnDisable\"); } public override void OnInspectorGUI() { //设置整个界面是以垂直方向来布局 EditorGUILayout.BeginVertical(); //Button if (GUILayout.Button(\"Button\")) { Debug.Log(\"Button Click\"); } //RepeatButton 在按着的时候一直返回true，松开才返回false if (GUILayout.RepeatButton(\"RepeatButton\")) { Debug.Log(\"RepeatButton Down\"); } //LabelField EditorGUILayout.LabelField(\"Base Info\"); player.id = EditorGUILayout.IntField(\"Player ID\", player.id); //SelectableLabel EditorGUILayout.SelectableLabel(\"SelectableLabel8\\nSelectableLabel7\\nSelectableLabel6\\nSelectableLabel5\\nSelectableLabel4\\nSelectableLabel3\\nSelectableLabel2\\nSelectableLabel1\\n\"); //密码框 player.password = GUILayout.PasswordField(player.password, '*'); //TextField只能一行 player.playerName = EditorGUILayout.TextField(\"PlayerName\", player.playerName); //TextArea可以多行 EditorGUILayout.LabelField(\"Back Story\"); player.backStory = EditorGUILayout.TextArea(player.backStory, GUILayout.MinHeight(100)); //使用滑块绘制 Player 生命值 player.health = EditorGUILayout.Slider(\"Health\", player.health, 0, 100); //根据生命值设置生命条的背景颜色 if (player.health \u003c 20) { GUI.color = Color.red; } else if (player.health \u003e 80) { GUI.color = Color.green; } else { GUI.color = Color.gray; } //指定生命值的宽高 Rect progressRect = GUILayoutUtility.GetRect(50, 50); //绘制生命条 EditorGUI.ProgressBar(progressRect, player.health / 100.0f, \"Health\"); //用此处理，以防上面的颜色变化会影响到下面的颜色变化 GUI.color = Color.white; //使用滑块绘制伤害值 player.damage = EditorGUILayout.Slider(\"Damage\", player.damage, 0, 20); //根据伤害值的大小设置显示的类型和提示语 if (player.damage \u003c 10) { EditorGUILayout.HelpBox(\"伤害太低了吧！！\", MessageType.Error); } else if (player.damage \u003e 15) { EditorGUILayout.HelpBox(\"伤害有点高啊！！\", MessageType.Warning); } else { EditorGUILayout.HelpBox(\"伤害适中！！\", MessageType.Info); } //设置内容折叠 showWeapons = EditorGUILayout.Foldout(showWeapons, \"Weapons\"); if (showWeapons) { player.weaponDamage1 = EditorGUILayout.FloatField(\"Weapon 1 Damage\", player.weaponDamage1); player.weaponDamage2 = EditorGUILayout.FloatField(\"Weapon 2 Damage\", player.weaponDamage2); } //绘制鞋子信息 EditorGUILayout.LabelField(\"Shoe\"); //以水平方向绘制 EditorGUILayout.BeginHorizontal(); EditorGUILayout.LabelField(\"Name\", GUILayout.MaxWidth(50)); player.shoeName = EditorGUILayout.TextField(player.shoeName); EditorGUILayout.LabelField(\"Size\", GUILayout.MaxWidth(50)); player.shoeSize = EditorGUILayout.IntField(player.shoeSize); EditorGUILayout.LabelField(\"Type\", GUILayout.MaxWidth(50)); player.shoeType = EditorGUILayout.TextField(player.shoeType); EditorGUILayout.EndHorizontal(); GUILayout.Space(30); //ObjectField player.go = (GameObject)EditorGUILayout.ObjectField(\"ObjectField:\", player.go, typeof(GameObject), true); EditorGUI.indentLevel++; //单选 Enum player.codingType = (CodingType)EditorGUILayout.EnumPopup(\"单选（枚举Enum）\", player.codingType); //多选 Enum player.mixedCodingType = (CodingType)EditorGUILayout.EnumFlagsField(\"多选（枚举Enum）\", player.mixedCodingType); GUILayout.FlexibleSpace(); GUILayout.Space(15); //单选 String player.popup = EditorGUILayout.Popup(\"单选（字符串）\", player.popup, new string[] {\"one\",\"two\",\"three\",\"four\",\"five\" }); //多选 String int old = player.mixedPopup; player.mixedPopup = EditorGUILayout.MaskField(\"多选（字符串）\", player.mixedPopup, new string[] { \"one\", \"two\", \"three\", \"four\", \"five\" }); if(old!=player.mixedPopup) { Print(player.mixedPopup, new string[] { \"one\", \"two\", \"three\", \"four\", \"five\" }); } EditorGUI.indentLevel--; //SelectionGrid old = player.gridId; player.gridId = GUILayout.SelectionGrid(player.gridId, new[] { \"1\", \"2\", \"3\", \"4\", \"5\", \"6\" }, 4); if(player.gridId!=old) { Debug.Log(\"SelectionGrid:\" + player.gridId); } // ","date":"2020-09-02 17:38:56","objectID":"/unity%E7%BC%96%E8%BE%91%E5%99%A8-%E8%87%AA%E5%AE%9A%E4%B9%89inspector%E9%9D%A2%E6%9D%BF/:0:2","tags":["Unity编辑器"],"title":"【Unity编辑器】 自定义Inspector面板","uri":"/unity%E7%BC%96%E8%BE%91%E5%99%A8-%E8%87%AA%E5%AE%9A%E4%B9%89inspector%E9%9D%A2%E6%9D%BF/"},{"categories":["hugo"],"content":" 我们怎么设置日期都和想要的不一样，怎么解决呢? 这里的时间格式用的时间点是固定的，找到这个规律就好了，也就是： 2006-01-02 15:04:05 dateFormat = \"2006-01-02 15:04:05\" 这样就能解决了 日期时间格式可能是每一个 go 程序员都遇到过的问题，但是对于一个 hugo 使用者来说， 未免不太友好，如果你正在为这个问题烦恼，希望本文会对你有所帮助。 参考：hugo / go 模版中的日期格式 ","date":"2020-09-01 21:08:09","objectID":"/hugo%E6%A8%A1%E7%89%88%E4%B8%AD%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F/:0:0","tags":["hugo"],"title":"hugo / go 模版中的日期格式","uri":"/hugo%E6%A8%A1%E7%89%88%E4%B8%AD%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F/"},{"categories":null,"content":"😄 😄 😀🙈🙈🙈🙈 👉👉👉👉👉👈👈👈👈👈 个人博客： 👉👉 \u003c https://wgqing.com \u003e 👉👉 github: \u003c https://codingriver.github.io \u003e 👉👉 mail: \u003c codingriver@163.com \u003e my iframe -- ","date":"2020-09-01 19:59:41","objectID":"/about/:0:0","tags":null,"title":"关于 Codingriver","uri":"/about/"},{"categories":["hugo"],"content":"不支持tweet和instagram 的shortcode 网络访问不了，执行hugo直接失败，执行hugo serve也会失败，必须删除。 ","date":"2020-08-29 15:58:08","objectID":"/hugo-loveit-problems/:0:1","tags":["hugo"],"title":"Loveit 使用中的问题","uri":"/hugo-loveit-problems/"},{"categories":["hugo"],"content":"提交github page报错 config中配置不生成md就好了，因为md中有go语言写法，github编译过不去,把md文件删除。 ","date":"2020-08-29 15:58:08","objectID":"/hugo-loveit-problems/:0:2","tags":["hugo"],"title":"Loveit 使用中的问题","uri":"/hugo-loveit-problems/"},{"categories":["“Shader”"],"content":"边缘光和流光特效 ‘‘‘c Shader “Unlit/EdgeAndScan” { Properties { _MainTex (“Texture”, 2D) = “white” {} _PowEmiss(“Pow Emiss”,float)=5 _RimMin(“RimMin”,Range(-1,1)) = 0.0 _RimMax(“RimMax”,Range(0,2)) = 1.0 _InnerColor(“Inner Color”,Color) = (0.0,0.0,0.0,0.0) _RimColor(“Rim Color”,Color) = (1,1,1,1) _RimIntensity(“Rim Intensity”,Float) = 1.0 _FlowTilling(“Flow Tilling”,Vector) = (1,1,0,0) _FlowSpeed(“Flow Speed”,Vector) = (1,1,0,0) _FlowTex(“Flow Tex”,2D) = “white”{} _FlowIntensity(“Flow Intensity”,Float) = 0.5 } SubShader { Tags { “Queue”=“Transparent” } LOD 100 Pass { //这个Pass不输出颜色，只是输出深度，透明会有问题，如果不处理深度 //只是测试流光和边缘光可以删除该pass Cull Off ZWrite On ColorMask 0 CGPROGRAM float4 _Color; #pragma vertex vert #pragma fragment frag float4 vert(float4 vertexPos : POSITION) : SV_POSITION { return UnityObjectToClipPos(vertexPos); } float4 frag(void) : COLOR { return _Color; } ENDCG } Pass { ZWrite Off Blend SrcAlpha One CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" struct appdata { float4 vertex : POSITION; float2 uv : TEXCOORD0; float3 normal: NORMAL; }; struct v2f { float2 uv : TEXCOORD0; float4 vertex : SV_POSITION; float3 world_normal: TEXCOORD1; float3 world_pos: TEXCOORD2; float3 world_pivot:TEXCOORD3; }; sampler2D _MainTex; float4 _MainTex_ST; float _RimMin; float _RimMax; float4 _InnerColor; float4 _RimColor; float _RimIntensity; float4 _FlowTilling; float4 _FlowSpeed; sampler2D _FlowTex; float _FlowIntensity; float _InnerAlpha; float _PowEmiss; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _MainTex); o.world_normal=normalize(mul(float4(v.normal,0.0),unity_WorldToObject).xyz); o.world_pos=mul(unity_ObjectToWorld,float4(v.vertex.xyz,1)).xyz; o.world_pivot=mul(unity_ObjectToWorld,float4(0,0,0,1)).xyz; return o; } fixed4 frag (v2f i) : SV_Target { //边缘光 half3 world_normal=normalize(i.world_normal); float3 world_view=normalize(_WorldSpaceCameraPos.xyz-i.world_pos); float dotV=saturate(dot(world_normal,world_view)); float fresnel=1-dotV; fresnel = smoothstep(_RimMin, _RimMax, fresnel); //用于增加细节，也可以不要 half emiss = tex2D(_MainTex, i.uv).r; emiss = pow(emiss, _PowEmiss); float final_edge_alpha=saturate(emiss+fresnel); float3 final_edge_col=lerp(_InnerColor.xyz, _RimColor.xyz * _RimIntensity, final_edge_alpha); //流光 float2 flow_uv=(i.world_pos.xy-i.world_pivot.xy)*_FlowTilling.xy; flow_uv=_Time.y*_FlowSpeed.xy+flow_uv; float4 flow_col=tex2D(_FlowTex,flow_uv)*_FlowIntensity; //合并 float3 final_col=final_edge_col+flow_col.rgb; float final_alpha=saturate(final_edge_alpha+flow_col.a); return float4(final_col.rgb,final_alpha); } ENDCG } } } ’’’ 材质球属性： 效果： ","date":"2020-02-09 19:31:05","objectID":"/%E8%BE%B9%E7%BC%98%E5%85%89%E5%92%8C%E6%B5%81%E5%85%89%E7%89%B9%E6%95%88/:1:0","tags":["“Shader”"],"title":"边缘光和流光特效","uri":"/%E8%BE%B9%E7%BC%98%E5%85%89%E5%92%8C%E6%B5%81%E5%85%89%E7%89%B9%E6%95%88/"},{"categories":["“Shader”"],"content":"‘‘‘c Shader “Unlit/Edge” { Properties { _EdgeColor(“Edge Color”,Color)=(1,1,1,1) _RimMin(“RimMin”,Range(-1,1)) = 0.0 _RimMax(“RimMax”,Range(0,2)) = 1.0 } SubShader { Tags { “Queue”=“Transparent” } LOD 100 Pass { ZWrite Off Blend SrcAlpha One CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" struct appdata { float4 vertex : POSITION; float2 uv : TEXCOORD0; float3 normal: NORMAL; }; struct v2f { float2 uv : TEXCOORD0; float4 vertex : SV_POSITION; float3 world_normal: TEXCOORD1; float3 world_pos: TEXCOORD2; }; sampler2D _MainTex; float4 _MainTex_ST; float4 _EdgeColor; float _PowEmiss; float _InnerAlpha; float _RimMin; float _RimMax; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _MainTex); o.world_normal=normalize(mul(float4(v.normal,0.0),unity_WorldToObject).xyz); o.world_pos=mul(unity_ObjectToWorld,float4(v.vertex.xyz,1)).xyz; return o; } fixed4 frag (v2f i) : SV_Target { //边缘光 half3 world_normal=normalize(i.world_normal); float3 world_view=normalize(_WorldSpaceCameraPos.xyz-i.world_pos); float dotV=saturate(dot(world_normal,world_view)); float fresnel=1-dotV; fresnel = smoothstep(_RimMin, _RimMax, fresnel); half emiss = tex2D(_MainTex, i.uv).r; emiss = pow(emiss, 5.0); float final_edge_alpha=saturate(emiss+fresnel); //float emiss=pow(fresnel,_PowEmiss); //fixed4 col = tex2D(_MainTex, i.uv); return float4(_EdgeColor.rgb,fresnel); } ENDCG } } } ’’’ 材质球面板： 效果： ","date":"2020-02-09 18:29:01","objectID":"/%E8%BE%B9%E7%BC%98%E5%85%89%E7%89%B9%E6%95%88/:0:0","tags":["“Shader”"],"title":"边缘光特效","uri":"/%E8%BE%B9%E7%BC%98%E5%85%89%E7%89%B9%E6%95%88/"},{"categories":["笔记"],"content":"ssh-keygen 基本用法 ssh-keygen命令用于为“ssh”生成、管理和转换认证密钥，它支持RSA和DSA两种认证密钥. ssh-keygen(选项) -b：指定密钥长度； -e：读取openssh的私钥或者公钥文件； -C：添加注释； -f：指定用来保存密钥的文件名； -i：读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥； -l：显示公钥文件的指纹数据； -N：提供一个新密语； -P：提供（旧）密语； -q：静默模式； -t：指定要创建的密钥类型。 特别注意 -C 参数： -C：添加注释 如果在github中配置ssh 则这个参数的值必须是github的邮件名称，不能是其他的 案例： ssh-keygen -t rsa -f id_rsa_github -C \"codingriver@163.com\" # -t 指定要创建的密钥类型 # -f 指定创建的密钥文件名字 # -C 注释 注意如果是github配置ssh，这里必须是github的邮箱名称 ssh-keygen -t ed25519 -C \"codingriver@163.com\" ","date":"2019-12-19 22:39:07","objectID":"/ssh%E7%AC%94%E8%AE%B0/:1:0","tags":["笔记","git","ssh"],"title":"SSH笔记","uri":"/ssh%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"验证ssh # 验证github ssh配置是否成功 ssh -vT git@github.com # or # 验证github ssh配置是否成功 ssh -vT git@github.com ","date":"2019-12-19 22:39:07","objectID":"/ssh%E7%AC%94%E8%AE%B0/:2:0","tags":["笔记","git","ssh"],"title":"SSH笔记","uri":"/ssh%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"配置ssh密钥登录 在本地电脑上生成密钥 ssh-keygen -t rsa 生成密钥和公钥，将公钥复制到远程服务器的.ssh目录下 远程ssh配置 cd ~/.ssh ls //ls你可以看到这个文件 touch authorized_keys //生成认证文件，其实已经有了 cat id_rsa.pub \u003e\u003e authorized_keys // 将上面生成公钥复制到.ssh后然后复制到authorized_keys文件 chmod 600 authorized_keys //设置文件权限 chmod 700 -R .ssh //是指文件夹权限 远程sshd_config文件配置 文件位置： /etc/ssh/sshd_config,需要使用管理员权限打开 几步处理： //使用密钥登录 RSAAuthentication yes PubkeyAuthentication yes //禁止空密码和Root密码登录： PermitEmptyPasswords no PasswordAuthentication no ssh登录测试 ssh -i .ssh/remote_rsa root@101.43.160.247 // - i 指定密钥的文件路径 // root 登录的用户名 // 最后是ip 参考 https://blog.csdn.net/ouzuosong/article/details/52225087 安装ssh https://www.cnblogs.com/wangboyu/articles/11611925.html ","date":"2019-12-19 22:39:07","objectID":"/ssh%E7%AC%94%E8%AE%B0/:3:0","tags":["笔记","git","ssh"],"title":"SSH笔记","uri":"/ssh%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"ssh登录 第一种 在命令行中指定私钥文件 # -i 指定私钥地址（私钥和公钥的文件名是一样的，只不过公钥文件有一个 .pub 后缀名。换句话说，如果把本地公钥给删了，只剩下私钥是无法登录的，因为在登录时要将公钥id发送给服务端，这样服务端才知道要选择哪个公钥加密） $ ssh -p 22 root@192.168.56.102 -i ~/.ssh/id_rsa_server 第二种 使用 ssh-agent 代理 # 先添加私钥 $ ssh-add ~/.ssh/id_rsa_server # 查看添加的私钥 $ ssh-add -l # 使用 ssh-agent 代理，ssh-agent 会在 ssh-add 列表中寻找到合适的私钥 $ ssh root@192.168.56.102 第三种 在 SSH 配置中指定私钥文件 $ vim ~/.ssh/config Host gateway # 主机别名，使用 ssh gateway 命令可以直接登录该主机 Protocol 2 # SSH 协议版本 HostName example.com # 主机地址，支持IP或域名 Port 22 # SSH 服务端口号 User ubuntu # 登录用户名，会被 ssh root@gateway 覆盖，除非使用 ssh gateway IdentityFile ~/.ssh/id_rsa # 使用的私钥文件 例子：~/.ssh/config 权限： # 为.ssh目录设置权限 chmod 600 ~/.ssh/config Host server HostName 101.43.160.247 IdentityFile ~/.ssh/remote_rsa User root Port 22 Host remote HostName wgqing.com IdentityFile ~/.ssh/remote_rsa User root Port 22 参考： https://zhuanlan.zhihu.com/p/257430478 https://blog.csdn.net/baalhuo/article/details/78067621 ","date":"2019-12-19 22:39:07","objectID":"/ssh%E7%AC%94%E8%AE%B0/:4:0","tags":["笔记","git","ssh"],"title":"SSH笔记","uri":"/ssh%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"问题 关于ECDSA key fingerprint is mrwang@CodingdeMBP .ssh % ssh -T git@github.com The authenticity of host 'github.com (20.205.243.166)' can't be established. ECDSA key fingerprint is SHA256:p2QAMXNIC1TJYWeIOttrVc98/R1BUFWu3/LiyKgUfQM. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added 'github.com,20.205.243.166' (ECDSA) to the list of known hosts. git@github.com: Permission denied (publickey). mrwang@CodingdeMBP .ssh % ssh-add ~/.ssh/github Identity added: /Users/mrwang/.ssh/github (my mac for github codingriver@163.com) mrwang@CodingdeMBP .ssh % ssh -T git@github.com Hi codingriver! You've successfully authenticated, but GitHub does not provide shell access. 新建ssh，将公钥添加至github后，使用ssh -T git@github.com验证报ECDSA key fingerprint is xxx 错误。 是因为新建SSH后没有开启代理 为SSH key 启用SSH代理 $ ssh-add ~/.ssh/id_rsa ssh 出现Permission denied (publickey)问题 % git push git@github.com: Permission denied (publickey). fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. 修改配置文件 /etc/ssh/ssh_config (windows系统 C:\\Program Files\\Git\\etc\\ssh\\ssh_config)，添加如下一行 IdentityFile ~/.ssh/github_rsa # github_rsa是密钥文件的名字 就可以了 这里可能是因为我修改密钥文件名字造成的，通配符匹配不到 SSH用私钥登录远程服务器时提示私钥不安全 使用 chmod 600 id_ed25519就好了，私钥文件权限问题 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: UNPROTECTED PRIVATE KEY FILE! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ Permissions 0644 for '/Users/mrwang/.ssh/***' are too open. It is required that your private key files are NOT accessible by others. This private key will be ignored. Load key \"/Users/mrwang/.ssh/***\": bad permissions git@codeup.aliyun.com: Permission denied (publickey). fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. 私钥的权限 -rw-r--r--@ 1 mrwang staff 432 3 11 13:18 id_ed25519 -rw-r--r--@ 1 mrwang staff 113 3 11 13:18 id_ed25519.pub -rw------- 1 mrwang staff 2602 12 19 22:37 id_rsa -rw-r--r--@ 1 mrwang staff 573 12 19 22:37 id_rsa.pub 使用 chmod 600 id_ed25519就好了，私钥文件权限问题 -rw-r--r--@ 1 mrwang staff 627 2 12 18:52 config -rw-------@ 1 mrwang staff 432 3 11 13:18 id_ed25519 -rw-r--r--@ 1 mrwang staff 113 3 11 13:18 id_ed25519.pub -rw------- 1 mrwang staff 2602 12 19 22:37 id_rsa -rw-r--r--@ 1 mrwang staff 573 12 19 22:37 id_rsa.pub 参考：https://my.oschina.net/philosopher/blog/314134 ","date":"2019-12-19 22:39:07","objectID":"/ssh%E7%AC%94%E8%AE%B0/:5:0","tags":["笔记","git","ssh"],"title":"SSH笔记","uri":"/ssh%E7%AC%94%E8%AE%B0/"},{"categories":["随笔"],"content":" 字体裁剪教程 http://blog.csdn.net/wuming22222/article/details/51713350 工具需要将文本保存为utf8有BOM的格式，utf8 无BOM导入会识别失败 一 乙 二 十 丁 厂 七 卜 人 入 八 九 几 儿 了 力 乃 刀 又 三 于 干 亏 士 工 土 才 寸 下 大 丈 与 万 上 小 口 巾 山 千 乞 川 亿 个 勺 久 凡 及 夕 丸 么 广 亡 门 义 之 尸 弓 己 已 子 卫 也 女 飞 刃 习 叉 马 乡 丰 王 井 开 夫 天 无 元 专 云 扎 艺 木 五 支 厅 不 太 犬 区 历 尤 友 匹 车 巨 牙 屯 比 互 切 瓦 止 少 日 中 冈 贝 内 水 见 午 牛 手 毛 气 升 长 仁 什 片 仆 化 仇 币 仍 仅 斤 爪 反 介 父 从 今 凶 分 乏 公 仓 月 氏 勿 欠 风 丹 匀 乌 凤 勾 文 六 方 火 为 斗 忆 订 计 户 认 心 尺 引 丑 巴 孔 队 办 以 允 予 劝 双 书 幻 玉 刊 示 末 未 击 打 巧 正 扑 扒 功 扔 去 甘 世 古 节 本 术 可 丙 左 厉 右 石 布 龙 平 灭 轧 东 卡 北 占 业 旧 帅 归 且 旦 目 叶 甲 申 叮 电 号 田 由 史 只 央 兄 叼 叫 另 叨 叹 四 生 失 禾 丘 付 仗 代 仙 们 仪 白 仔 他 斥 瓜 乎 丛 令 用 甩 印 乐 句 匆 册 犯 外 处 冬 鸟 务 包 饥 主 市 立 闪 兰 半 汁 汇 头 汉 宁 穴 它 讨 写 让 礼 训 必 议 讯 记 永 司 尼 民 出 辽 奶 奴 加 召 皮 边 发 孕 圣 对 台 矛 纠 母 幼 丝 式 刑 动 扛 寺 吉 扣 考 托 老 执 巩 圾 扩 扫 地 扬 场 耳 共 芒 亚 芝 朽 朴 机 权 过 臣 再 协 西 压 厌 在 有 百 存 而 页 匠 夸 夺 灰 达 列 死 成 夹 轨 邪 划 迈 毕 至 此 贞 师 尘 尖 劣 光 当 早 吐 吓 虫 曲 团 同 吊 吃 因 吸 吗 屿 帆 岁 回 岂 刚 则 肉 网 年 朱 先 丢 舌 竹 迁 乔 伟 传 乒 乓 休 伍 伏 优 伐 延 件 任 伤 价 份 华 仰 仿 伙 伪 自 血 向 似 后 行 舟 全 会 杀 合 兆 企 众 爷 伞 创 肌 朵 杂 危 旬 旨 负 各 名 多 争 色 壮 冲 冰 庄 庆 亦 刘 齐 交 次 衣 产 决 充 妄 闭 问 闯 羊 并 关 米 灯 州 汗 污 江 池 汤 忙 兴 宇 守 宅 字 安 讲 军 许 论 农 讽 设 访 寻 那 迅 尽 导 异 孙 阵 阳 收 阶 阴 防 奸 如 妇 好 她 妈 戏 羽 观 欢 买 红 纤 级 约 纪 驰 巡 寿 弄 麦 形 进 戒 吞 远 违 运 扶 抚 坛 技 坏 扰 拒 找 批 扯 址 走 抄 坝 贡 攻 赤 折 抓 扮 抢 孝 均 抛 投 坟 抗 坑 坊 抖 护 壳 志 扭 块 声 把 报 却 劫 芽 花 芹 芬 苍 芳 严 芦 劳 克 苏 杆 杠 杜 材 村 杏 极 李 杨 求 更 束 豆 两 丽 医 辰 励 否 还 歼 来 连 步 坚 旱 盯 呈 时 吴 助 县 里 呆 园 旷 围 呀 吨 足 邮 男 困 吵 串 员 听 吩 吹 呜 吧 吼 别 岗 帐 财 针 钉 告 我 乱 利 秃 秀 私 每 兵 估 体 何 但 伸 作 伯 伶 佣 低 你 住 位 伴 身 皂 佛 近 彻 役 返 余 希 坐 谷 妥 含 邻 岔 肝 肚 肠 龟 免 狂 犹 角 删 条 卵 岛 迎 饭 饮 系 言 冻 状 亩 况 床 库 疗 应 冷 这 序 辛 弃 冶 忘 闲 间 闷 判 灶 灿 弟 汪 沙 汽 沃 泛 沟 没 沈 沉 怀 忧 快 完 宋 宏 牢 究 穷 灾 良 证 启 评 补 初 社 识 诉 诊 词 译 君 灵 即 层 尿 尾 迟 局 改 张 忌 际 陆 阿 陈 阻 附 妙 妖 妨 努 忍 劲 鸡 驱 纯 纱 纳 纲 驳 纵 纷 纸 纹 纺 驴 纽 奉 玩 环 武 青 责 现 表 规 抹 拢 拔 拣 担 坦 押 抽 拐 拖 拍 者 顶 拆 拥 抵 拘 势 抱 垃 拉 拦 拌 幸 招 坡 披 拨 择 抬 其 取 苦 若 茂 苹 苗 英 范 直 茄 茎 茅 林 枝 杯 柜 析 板 松 枪 构 杰 述 枕 丧 或 画 卧 事 刺 枣 雨 卖 矿 码 厕 奔 奇 奋 态 欧 垄 妻 轰 顷 转 斩 轮 软 到 非 叔 肯 齿 些 虎 虏 肾 贤 尚 旺 具 果 味 昆 国 昌 畅 明 易 昂 典 固 忠 咐 呼 鸣 咏 呢 岸 岩 帖 罗 帜 岭 凯 败 贩 购 图 钓 制 知 垂 牧 物 乖 刮 秆 和 季 委 佳 侍 供 使 例 版 侄 侦 侧 凭 侨 佩 货 依 的 迫 质 欣 征 往 爬 彼 径 所 舍 金 命 斧 爸 采 受 乳 贪 念 贫 肤 肺 肢 肿 胀 朋 股 肥 服 胁 周 昏 鱼 兔 狐 忽 狗 备 饰 饱 饲 变 京 享 店 夜 庙 府 底 剂 郊 废 净 盲 放 刻 育 闸 闹 郑 券 卷 单 炒 炊 炕 炎 炉 沫 浅 法 泄 河 沾 泪 油 泊 沿 泡 注 泻 泳 泥 沸 波 泼 泽 治 怖 性 怕 怜 怪 学 宝 宗 定 宜 审 宙 官 空 帘 实 试 郎 诗 肩 房 诚 衬 衫 视 话 诞 询 该 详 建 肃 录 隶 居 届 刷 屈 弦 承 孟 孤 陕 降 限 妹 姑 姐 姓 始 驾 参 艰 线 练 组 细 驶 织 终 驻 驼 绍 经 贯 奏 春 帮 珍 玻 毒 型 挂 封 持 项 垮 挎 城 挠 政 赴 赵 挡 挺 括 拴 拾 挑 指 垫 挣 挤 拼 挖 按 挥 挪 某 甚 革 荐 巷 带 草 茧 茶 荒 茫 荡 荣 故 胡 南 药 标 枯 柄 栋 相 查 柏 柳 柱 柿 栏 树 要 咸 威 歪 研 砖 厘 厚 砌 砍 面 耐 耍 牵 残 殃 轻 鸦 皆 背 战 点 临 览 竖 省 削 尝 是 盼 眨 哄 显 哑 冒 映 星 昨 畏 趴 胃 贵 界 虹 虾 蚁 思 蚂 虽 品 咽 骂 哗 咱 响 哈 咬 咳 哪 炭 峡 罚 贱 贴 骨 钞 钟 钢 钥 钩 卸 缸 拜 看 矩 怎 牲 选 适 秒 香 种 秋 科 重 复 竿 段 便 俩 贷 顺 修 保 促 侮 俭 俗 俘 信 皇 泉 鬼 侵 追 俊 盾 待 律 很 须 叙 剑 逃 食 盆 胆 胜 胞 胖 脉 勉 狭 狮 独 狡 狱 狠 贸 怨 急 饶 蚀 饺 饼 弯 将 奖 哀 亭 亮 度 迹 庭 疮 疯 疫 疤 姿 亲 音 帝 施 闻 阀 阁 差 养 美 姜 叛 送 类 迷 前 首 逆 总 炼 炸 炮 烂 剃 洁 洪 洒 浇 浊 洞 测 洗 活 派 洽 染 济 洋 洲 浑 浓 津 恒 恢 恰 恼 恨 举 觉 宣 室 宫 宪 突 穿 窃 客 冠 语 扁 袄 祖 神 祝 误 诱 说 诵 垦 退 既 屋 昼 费 陡 眉 孩 除 险 院 娃 姥 姨 姻 娇 怒 架 贺 盈 勇 怠 柔 垒 绑 绒 结 绕 骄 绘 给 络 骆 绝 绞 统 耕 耗 艳 泰 珠 班 素 蚕 顽 盏 匪 捞 栽 捕 振 载 赶 起 盐 捎 捏 埋 捉 捆 捐 损 都 哲 逝 捡 换 挽 热 恐 壶 挨 耻 耽 恭 莲 莫 荷 获 晋 恶 真 框 桂 档 桐 株 桥 桃 格 校 核 样 根 索 哥 速 逗 栗 配 翅 辱 唇 夏 础 破 原 套 逐 烈 殊 顾 轿 较 顿 毙 致 柴 桌 虑 监 紧 党 晒 眠 晓 鸭 晃 晌 晕 蚊 哨 哭 恩 唤 啊 唉 罢 峰 圆 贼 贿 钱 钳 钻 铁 铃 铅 缺 氧 特 牺 造 乘 敌 秤 租 积 秧 秩 称 秘 透 笔 笑 笋 债 借 值 倚 倾 倒 倘 俱 倡 候 俯 倍 倦 健 臭 射 躬 息 徒 徐 舰 舱 般 航 途 拿 爹 爱 颂 翁 脆 脂 胸 胳 脏 胶 脑 狸 狼 逢 留 皱 饿 恋 桨 浆 衰 高 席 准 座 脊 症 病 疾 疼 疲 效 离 唐 资 凉 站 剖 竞 部 旁 旅 畜 阅 羞 瓶 拳 粉 料 益 兼 烤 烘 烦 烧 烛 烟 递 涛 浙 涝 酒 涉 消 浩 海 涂 浴 浮 流 润 浪 浸 涨 烫 涌 悟 悄 悔 悦 害 宽 家 宵 宴 宾 窄 容 宰 案 请 朗 诸 读 扇 袜 袖 袍 被 祥 课 谁 调 冤 谅 谈 谊 剥 恳 展 剧 屑 弱 陵 陶 陷 陪 娱 娘 通 能 难 预 桑 绢 绣 验 继 球 理 捧 堵 描 域 掩 捷 排 掉 堆 推 掀 授 教 掏 掠 培 接 控 探 据 掘 职 基 著 勒 黄 萌 萝 菌 菜 萄 菊 萍 菠 营 械 梦 梢 梅 检 梳 梯 桶 救 副 票 戚 爽 聋 袭 盛 雪 辅 辆 虚 雀 堂 常 匙 晨 睁 眯 眼 悬 野 啦 晚 啄 距 跃 略 蛇 累 唱 患 唯 崖 崭 崇 圈 铜 铲 银 甜 梨 犁 移 笨 笼 笛 符 第 敏 做 袋 悠 偿 偶 偷 您 售 停 偏 假 得 衔 盘 船 斜 盒 鸽 悉 欲 彩 领 脚 脖 脸 脱 象 够 猜 猪 猎 猫 猛 馅 馆 凑 减 毫 麻 痒 痕 廊 康 庸 鹿 盗 章 竟 商 族 旋 望 率 着 盖 粘 粗 粒 断 剪 兽 清 添 淋 淹 渠 渐 混 渔 淘 液 淡 深 婆 梁 渗 情 惜 惭 悼 惧 惕 惊 惨 惯 寇 寄 宿 窑 密 谋 谎 祸 谜 逮 敢 屠 弹 随 蛋 隆 隐 婚 婶 颈 绩 绪 续 骑 绳 维 绵 绸 绿 琴 斑 替 款 堪 搭 塔 越 趁 趋 超 提 堤 博 揭 喜 插 揪 搜 煮 援 裁 搁 搂 搅 握 揉 斯 期 欺 联 散 惹 葬 葛 董 葡 敬","date":"2019-12-01 21:57:40","objectID":"/3500%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B1%89%E5%AD%97%E5%AD%97%E4%BD%93%E8%A3%81%E5%89%AA%E7%94%A8/:0:0","tags":[""],"title":"3500个常用汉字(字体裁剪用)","uri":"/3500%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%B1%89%E5%AD%97%E5%AD%97%E4%BD%93%E8%A3%81%E5%89%AA%E7%94%A8/"},{"categories":["Unity"],"content":" import android.net.NetworkInfo; import android.net.Uri; public void OpenWebView(String url) { Log.i(\"pay\",url); Intent intent = new Intent(); intent.setAction(\"android.intent.action.VIEW\"); Uri content_url = Uri.parse(url); intent.setData(content_url); intent.setClassName(\"com.android.browser\",\"com.android.browser.BrowserActivity\"); startActivity(intent); } ","date":"2019-12-01 21:57:40","objectID":"/android-app%E5%86%85%E6%89%93%E5%BC%80%E8%87%AA%E5%B8%A6%E6%B5%8F%E8%A7%88%E5%99%A8/:0:0","tags":["Android","Unity"],"title":"Android-App内打开自带浏览器","uri":"/android-app%E5%86%85%E6%89%93%E5%BC%80%E8%87%AA%E5%B8%A6%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"categories":["Unity"],"content":" 参考文章：https://www.cnblogs.com/jasonkent27/p/5113184.html /** * bitmap中的透明色用白色替换 * * @param bitmap * @return */ public static Bitmap changeColor(Bitmap bitmap) { if (bitmap == null) { return null; } int w = bitmap.getWidth(); int h = bitmap.getHeight(); int[] colorArray = new int[w * h]; int n = 0; for (int i = 0; i \u003c h; i++) { for (int j = 0; j \u003c w; j++) { int color = getMixtureWhite(bitmap.getPixel(j, i)); colorArray[n++] = color; } } return Bitmap.createBitmap(colorArray, w, h, Bitmap.Config.ARGB_8888); } /** * 获取和白色混合颜色 * * @return */ private static int getMixtureWhite(int color) { int alpha = Color.alpha(color); int red = Color.red(color); int green = Color.green(color); int blue = Color.blue(color); return Color.rgb(getSingleMixtureWhite(red, alpha), getSingleMixtureWhite (green, alpha), getSingleMixtureWhite(blue, alpha)); } /** * 获取单色的混合值 * * @param color * @param alpha * @return */ private static int getSingleMixtureWhite(int color, int alpha) { int newColor = color * alpha / 255 + 255 - alpha; return newColor \u003e 255 ? 255 : newColor; } ","date":"2019-12-01 21:57:40","objectID":"/android-%E5%88%86%E4%BA%ABapp-icon%E9%80%8F%E6%98%8E%E5%9B%BE%E7%89%87%E5%88%B0%E5%BE%AE%E4%BF%A1%E5%8F%98%E9%BB%91%E7%9A%84%E9%97%AE%E9%A2%98/:0:0","tags":["Android","Unity"],"title":"Android　分享App-Icon透明图片到微信变黑的问题","uri":"/android-%E5%88%86%E4%BA%ABapp-icon%E9%80%8F%E6%98%8E%E5%9B%BE%E7%89%87%E5%88%B0%E5%BE%AE%E4%BF%A1%E5%8F%98%E9%BB%91%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["Unity"],"content":"https://www.cnblogs.com/sexintercourse/p/5898242.html Android的android:scheme不要设置成http,否则打不开 IOS的scheme 在浏览器中用window.location.href=设置有时候没有反应，不知道是不是bug ","date":"2019-12-01 21:57:40","objectID":"/androidios-%E9%80%9A%E8%BF%87%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80app/:0:0","tags":["Android","Unity","IOS"],"title":"Android，iOS-通过浏览器打开app","uri":"/androidios-%E9%80%9A%E8%BF%87%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80app/"},{"categories":["CSharp"],"content":"string s = “hello”; string y = $\"{s} world\"; 等同于使用Format方法： string y = string.Format(\"{0} world\",s); 并且我们可以调用值的方法，如： string y = $\"{s.ToLower()} world\"; 使用新的字符串格式代码可读性要好一些如： int a = 1; int b = 2; string c = $\"{a} + {b} = {a + b}\";//使用$ string d = string.Format(\"{0} + {1} = {2}\", a, b, a + b);//使用Format 参考文章 https://blog.csdn.net/xc917563264/article/details/79348233 ","date":"2019-12-01 21:57:40","objectID":"/csharp%E8%AF%AD%E8%A8%806-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%92%E5%80%BC/:0:0","tags":["CSharp"],"title":"C# 6 字符串插值(使用前缀$)","uri":"/csharp%E8%AF%AD%E8%A8%806-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%92%E5%80%BC/"},{"categories":["CSharp"],"content":" C# 异步编程提供了两个关键字，async 和await，这里说明下怎么用 C# 5 引入了一种简便方法，即异步编程。==此方法利用了 .NET Framework 4.5 及更高版本==、.NET Core 和 Windows 运行时中的异步支持。 编译器可执行开发人员曾进行的高难度工作，且应用程序保留了一个类似于同步代码的逻辑结构。 因此，你只需做一小部分工作就可以获得异步编程的所有好处。 本主题概述了何时以及如何使用异步编程，并包括指向包含详细信息和示例的支持主题的链接。 测试环境：vs2017，.Net Framework4.6.1。 用法 async 用在方法定义前面，await只能写在带有async标记的方法中。 ==注意await异步等待的地方，await后面的代码和前面的代码执行的线程可能不一样== ==async关键字创建了一个状态机，类似yield return 语句；await会解除当前线程的阻塞，完成其他任务== 0X01 简单用法 测试代码 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace AsyncAndAwait_Test { class Program { static void Main(string[] args) { Console.WriteLine(\"主线程ManagedThreadId:\" + Thread.CurrentThread.ManagedThreadId); AsyncTest(); } static async void AsyncTest() { Console.WriteLine(\"*******Start************ManagedThreadId:\" + Thread.CurrentThread.ManagedThreadId); Task\u003cint\u003e taskA= Print(); Console.WriteLine(\"*********Middle**********ManagedThreadId:\" + Thread.CurrentThread.ManagedThreadId); int a = await taskA; Console.WriteLine(\"*********End**********ManagedThreadId:\" + Thread.CurrentThread.ManagedThreadId); } static Task\u003cint\u003e Print() { var tcs = new TaskCompletionSource\u003cint\u003e(); var thrd = new Thread(() =\u003e { Console.WriteLine(\"子线程ManagedThreadId:\" + Thread.CurrentThread.ManagedThreadId); for (int i = 0; i \u003c 3; i++) { Console.WriteLine(\"===========等待==========\" + i); System.Threading.Thread.Sleep(1000); } tcs.SetResult(99); }); thrd.Start(); return tcs.Task; } } } 结果 这里的结果红框这个地方线程id变了，按照我的理解是异步调用await前面代码的线程和await后面代码的线程可能不一样 再看一个测试例子 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace AsyncAndAwait_Test { class Program { /// \u003csummary\u003e /// async 和await 实践测试 /// \u003c/summary\u003e /// \u003cparam name=\"args\"\u003e\u003c/param\u003e static void Main(string[] args) { var tcs1 = new TaskCompletionSource\u003cint\u003e(); var tcs2 = new TaskCompletionSource\u003cint\u003e(); Console.WriteLine(\"主线程ManagedThreadId:\" + Thread.CurrentThread.ManagedThreadId); AsyncTest(tcs1,tcs2); Thread.Sleep(1000); tcs1.SetResult(100); Thread.Sleep(5000); tcs2.SetResult(100); Console.WriteLine(\"主线程结束ManagedThreadId:\" + Thread.CurrentThread.ManagedThreadId); } static async void AsyncTest(TaskCompletionSource\u003cint\u003e tcs1, TaskCompletionSource\u003cint\u003e tcs2) { Console.WriteLine(\"AsyncTest方法执行的线程id:\" + Thread.CurrentThread.ManagedThreadId); //await后线程出现变化，异步执行（线程id不一样） int a = await Print(); Console.WriteLine(\"11****await tcs3后的线程id:\" + Thread.CurrentThread.ManagedThreadId); //await后的线程没有变化，是因为SetResult比较早，这里可以直接同步执行（我认为的） int b = await tcs1.Task; Console.WriteLine(\"22****await tcs1后的线程id:\" + Thread.CurrentThread.ManagedThreadId); //await后线程出现变化，异步执行（线程id不一样） int c= await tcs2.Task; Console.WriteLine(\"33****await tcs2后的线程id：\" + Thread.CurrentThread.ManagedThreadId); } static Task\u003cint\u003e Print() { var tcs3 = new TaskCompletionSource\u003cint\u003e(); var thrd = new Thread(() =\u003e { Console.WriteLine(\"子线程ManagedThreadId:\" + Thread.CurrentThread.ManagedThreadId); for (int i = 0; i \u003c 3; i++) { Console.WriteLine(\"===========等待==========\" + i); System.Threading.Thread.Sleep(1000); } tcs3.SetResult(99); }); thrd.Start(); return tcs3.Task; } } } 结果： 代码里面await用法，这里异步返回的是一个Task\u003cint\u003e类型，通过await等待Task执行完成后返回的是int，或者返回的是T模板 根据结果总结结论如下： 如果执行到await时TaskCompletionSource没有设置SetResult、SetCanceled、SetException中的一个则await后面的线程可能出现变化（异步操作） 如果执行到await时TaskCompletionSource有设置SetResult、SetCanceled、SetException中的一个则await后面的线程不变化（同步操作） 0X02 深入用法 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace AsyncAwaitTest { class Program { static void Main(string[] args) { Main1(); Main2(); } static void Main1() { AsyncMethod1(); Console.WriteLine(\"Main finished!!!\"); //这里是为了处理Task启动一个后台线程的问题，主线程结束时，后台线程自动关闭 Thread.Sleep(5000); } static async void AsyncMethod1() { Console.WriteLine(\"主线程id:\" + Thread.CurrentThread.ManagedThreadId); //切换线程等待完成 string res ","date":"2019-12-01 21:57:40","objectID":"/async%E4%B8%8Eawait%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/:0:0","tags":["CSharp"],"title":"C# async与await的使用说明","uri":"/async%E4%B8%8Eawait%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"},{"categories":["CSharp"],"content":"C# Enum,Int,String的互相转换 Enum为枚举提供基类，其基础类型可以是除 Char 外的任何整型。如果没有显式声明基础类型，则使用 Int32。编程语言通常提供语法来声明由一组已命名的常数和它们的值组成的枚举。 注意：枚举类型的基类型是除 Char 外的任何整型，所以枚举类型的值是整型值。 Enum 提供一些实用的静态方法： (1)比较枚举类的实例的方法 (2)将实例的值转换为其字符串表示形式的方法 (3)将数字的字符串表示形式转换为此类的实例的方法 (4)创建指定枚举和值的实例的方法。 举例：enum Colors { Red, Green, Blue, Yellow }; Enum–\u003eString (1)利用Object.ToString()方法：如Colors.Green.ToString()的值是\"Green\"字符串； (2)利用Enum的静态方法GetName与GetNames： public static string GetName(Type enumType,Object value) public static string[] GetNames(Type enumType) 例如：Enum.GetName(typeof(Colors),3))与Enum.GetName(typeof(Colors), Colors.Blue))的值都是\"Blue\" Enum.GetNames(typeof(Colors))将返回枚举字符串数组。 String–\u003eEnum (1)利用Enum的静态方法Parse： public static Object Parse(Type enumType,string value) 例如：(Colors)Enum.Parse(typeof(Colors), “Red”) Enum–\u003eInt (1)因为枚举的基类型是除 Char 外的整型，所以可以进行强制转换。 例如：(int)Colors.Red, (byte)Colors.Green Int–\u003eEnum (1)可以强制转换将整型转换成枚举类型。 例如：Colors color = (Colors)2 ，那么color即为Colors.Blue (2)利用Enum的静态方法ToObject。 public static Object ToObject(Type enumType,int value) 例如：Colors color = (Colors)Enum.ToObject(typeof(Colors), 2)，那么color即为Colors.Blue 判断某个整型是否定义在枚举中的方法：Enum.IsDefined public static bool IsDefined(Type enumType,Object value) 例如：Enum.IsDefined(typeof(Colors), n)) 参考文章 C# Enum,Int,String的互相转换 ","date":"2019-12-01 21:57:40","objectID":"/enum_int_string%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/:0:0","tags":["CSharp"],"title":"C# Enum,Int,String的互相转换","uri":"/enum_int_string%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/"},{"categories":["CSharp"],"content":" SynchronizationContext线程上下文说明 SynchronizationContext在通讯中充当传输者的角色，实现功能就是一个线程和另外一个线程的通讯 那么SynchronizationContext的Send()和Post() Send() 是简单的在当前线程上去调用委托来实现（同步调用）。也就是在子线程上直接调用UI线程执行，等UI线程执行完成后子线程才继续执行。 Post() 是在线程池上去调用委托来实现（异步调用）。这是子线程会从线程池中找一个线程去调UI线程，子线程不等待UI线程的完成而直接执行自己下面的代码。 SynchronizationContext.Send(SendOrPostCallback d,object state); SynchronizationContext.Post(SendOrPostCallback d,object state); 测试代码： using System; using System.Collections.Concurrent; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading; using System.Threading.Tasks; namespace ContextTest { class Program { static SynchronizationContext context; // 线程同步队列,发送接收socket回调都放到该队列,由poll线程统一执行 //private ConcurrentQueue\u003cAction\u003e queue = new ConcurrentQueue\u003cAction\u003e(); /// \u003csummary\u003e /// 测试上下文同步 /// SynchronizationContext /// \u003c/summary\u003e /// \u003cparam name=\"args\"\u003e\u003c/param\u003e static void Main(string[] args) { context = new SynchronizationContext(); Console.WriteLine(\"主线程id：\"+Thread.CurrentThread.ManagedThreadId); TestThread(); Thread.Sleep(6000); Console.WriteLine(\"主线程执行\"); context.Send(EventMethod, \"Send\"); context.Post(EventMethod, \"Post\"); Console.WriteLine(\"主线程结束\"); } static void TestThread() { var thrd= new Thread(Start); thrd.Start(); } static void Start() { Console.WriteLine(\"子线程id：\" + Thread.CurrentThread.ManagedThreadId); context.Send(EventMethod, \"子线程Send\"); context.Post(EventMethod, \"子线程Post\"); Console.WriteLine(\"子线程结束\"); } static void EventMethod(object arg) { Console.WriteLine(\"CallBack::当前线程id：\" + Thread.CurrentThread.ManagedThreadId+\" arg:\"+(string)arg); } } } 结果： 根据结果分下得出： Send是在当前线程执行的（同步） Post是在新的线程执行的（异步） 其它的不同后面再补充 参考文章 梦琪小生 【C#】【Thread】SynchronizationContext线程间同步 ","date":"2019-12-01 21:57:40","objectID":"/synchronizationcontext%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E/:0:0","tags":["CSharp"],"title":"C# SynchronizationContext线程上下文简单说明","uri":"/synchronizationcontext%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E/"},{"categories":["计算机基础"],"content":" 引用：http://blog.csdn.net/u011511086/article/details/72865006 /// \u003csummary\u003e /// 字符串转Unicode /// \u003c/summary\u003e /// \u003cparam name=\"source\"\u003e源字符串\u003c/param\u003e /// \u003creturns\u003eUnicode编码后的字符串\u003c/returns\u003e public static string String2Unicode(string source) { var bytes = Encoding.Unicode.GetBytes(source); var stringBuilder = new StringBuilder(); for (var i = 0; i \u003c bytes.Length; i += 2) { stringBuilder.AppendFormat(\"\\\\u{0:x2}{1:x2}\", bytes[i + 1], bytes[i]); } return stringBuilder.ToString(); } /// \u003csummary\u003e /// 字符串转为UniCode码字符串 /// \u003c/summary\u003e /// \u003cparam name=\"s\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static string StringToUnicode(string s) { char[] charbuffers = s.ToCharArray(); byte[] buffer; StringBuilder sb = new StringBuilder(); for (int i = 0; i \u003c charbuffers.Length; i++) { buffer = System.Text.Encoding.Unicode.GetBytes(charbuffers[i].ToString()); sb.Append(String.Format(\"\\\\u{0:X2}{1:X2}\", buffer[1], buffer[0])); } return sb.ToString(); } /// \u003csummary\u003e /// Unicode字符串转为正常字符串 /// \u003c/summary\u003e /// \u003cparam name=\"srcText\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static string UnicodeToString(string srcText) { string dst = \"\"; string src = srcText; int len = srcText.Length / 6; for (int i = 0; i \u003c= len - 1; i++) { string str = \"\"; str = src.Substring(0, 6).Substring(2); src = src.Substring(6); byte[] bytes = new byte[2]; bytes[1] = byte.Parse(int.Parse(str.Substring(0, 2), System.Globalization.NumberStyles.HexNumber).ToString()); bytes[0] = byte.Parse(int.Parse(str.Substring(2, 2), System.Globalization.NumberStyles.HexNumber).ToString()); dst += Encoding.Unicode.GetString(bytes); } return dst; } ","date":"2019-12-01 21:57:40","objectID":"/%E4%B8%AD%E6%96%87%E5%92%8Cunicode%E4%BA%92%E8%BD%AC/:0:0","tags":["Unicode编码"],"title":"C# 中文和unicode互转","uri":"/%E4%B8%AD%E6%96%87%E5%92%8Cunicode%E4%BA%92%E8%BD%AC/"},{"categories":["CSharp"],"content":"这里用String比较的静态方法public static int Compare(String strA, String strB, StringComparison comparisonType);来测试不同的StringComparison的效率 直接上代码： using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; using System.Globalization; using System.Diagnostics; namespace StringCompare { class Program { static void Main(string[] args) { Compare(StringComparison.Ordinal); Compare(StringComparison.OrdinalIgnoreCase); Compare(StringComparison.InvariantCulture); Compare(StringComparison.InvariantCultureIgnoreCase); Compare(StringComparison.CurrentCulture); Compare(StringComparison.CurrentCultureIgnoreCase); } public static void Compare(StringComparison comparison) { string s1 = \"visualstudio\"; string s2 = \"windows\"; Stopwatch watch = new Stopwatch(); watch.Start(); for (int i = 0; i \u003c 10000000; i++) { String.Compare(s1, s2, comparison); } watch.Stop(); Console.WriteLine(watch.ElapsedMilliseconds+\" \" +comparison.ToString()); } } } 结果： 通过结果可以看出： ==StringComparison.Ordinal效率是最高的，是其它两个的20倍多！== 所以比较的时候没有需求要求的情况下尽量用Ordinal 参考文章： C# 字符串比较优化（StringComparison） ","date":"2019-12-01 21:57:40","objectID":"/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%E6%95%88%E7%8E%87%E6%B5%8B%E8%AF%95/:0:0","tags":["CSharp"],"title":"C# 字符串比较效率测试","uri":"/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%E6%95%88%E7%8E%87%E6%B5%8B%E8%AF%95/"},{"categories":["CSharp"],"content":" 今天整理关于特性的资料，之前都忘了，今天整理一下 参考《C#高级编程》第10版 0X01 特性（Attribute） ","date":"2019-12-01 21:57:40","objectID":"/csharp%E7%9A%84%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/:0:0","tags":["CSharp"],"title":"C# 特性详解（Attribute）","uri":"/csharp%E7%9A%84%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/"},{"categories":["CSharp"],"content":"特性定义 特性不会影响编译过程，因为编译器不能识别它们，但这些特性在应用于程序元素时，可以在编译好的程序集中用作元数据 上面这句话是书上说的，但不太认可，如果通过反射来使用特性呢 这里假设某个类上使用了特性如下： [Test] class BBB { } 当编译器发现这个类BBB应用了Test特性时，首先会把字符串Attribute追加到这个名称后面，形成一个组合名称 TestAttribute，然后在其搜索路径的所有名称空间 （即using使用的命名空间）中搜索有指定名称的类，如果特性本身已Attribute结尾，编译器就不会再追加Attritude了，而是不修改该特性名。如下 [TestAttritude] class BBB { } 编译器会找到含有该名称的类（TestAttribute），且这个类直接或者间接派生自System.Attribute。编译器还人为这个类包含控制特性用法的信息。 现在来看这个类的定义 public enum Flag { None, Input, Output } [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.ReturnValue | AttributeTargets.Assembly,AllowMultiple=true,Inherited=false)] class TestAttribute:Attribute { public TestAttribute(Flag flag = Flag.None) { } } ","date":"2019-12-01 21:57:40","objectID":"/csharp%E7%9A%84%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/:0:1","tags":["CSharp"],"title":"C# 特性详解（Attribute）","uri":"/csharp%E7%9A%84%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/"},{"categories":["CSharp"],"content":"指定AttributeUsage特性 引申： 特性（Attribute）本身用特性（System.AttributeUsage）来标记，C#编译器为它提供了特殊支持，其实AttributeUsage不能认为是一个特性了，应该理解为==元特性==，它只能用来标记特性类，不能标记其它的类。 使用： AttributeUsage主要用于标识自定义特性可以应用到哪些类型的程序元素上。这些信息由它的第一个参数给出（AttributeTargets），像上面使用的一样。 AttributeTargets的定义 public sealed class AttributeUsageAttribute : Attribute { // 摘要: // 用指定的 System.AttributeTargets、System.AttributeUsageAttribute.AllowMultiple // 值和 System.AttributeUsageAttribute.Inherited 值列表初始化 System.AttributeUsageAttribute // 类的新实例。 // // 参数: // validOn: // 使用按位\"或\"运算符组合的一组值，用于指示哪些程序元素是有效的。 public AttributeUsageAttribute(AttributeTargets validOn); // 摘要: // 获取或设置一个布尔值，该值指示能否为一个程序元素指定多个指示属性实例。 // // 返回结果: // 如果允许指定多个实例，则为 true；否则为 false。 默认值为 false。 public bool AllowMultiple { get; set; } // // 摘要: // 获取或设置一个布尔值，该值指示指示的属性能否由派生类和重写成员继承。 // // 返回结果: // 如果该属性可由派生类和重写成员继承，则为 true，否则为 false。 默认值为 true。 public bool Inherited { get; set; } // // 摘要: // 获取一组值，这组值标识指示的属性可应用到的程序元素。 // // 返回结果: // 一个或多个 System.AttributeTargets 值。 默认值为 All。 public AttributeTargets ValidOn { get; } } AttributeTargets的定义 // 摘要: // 指定可以对它们应用特性的应用程序元素。 [Serializable] [ComVisible(true)] [Flags] public enum AttributeTargets { // 摘要: // 可以对程序集应用属性。 Assembly = 1, // // 摘要: // 可以对模块应用属性。 Module = 2, // // 摘要: // 可以对类应用属性。 Class = 4, // // 摘要: // 可以对结构应用属性，即值类型。 Struct = 8, // // 摘要: // 可以对枚举应用属性。 Enum = 16, // // 摘要: // 可以对构造函数应用属性。 Constructor = 32, // // 摘要: // 可以对方法应用属性。 Method = 64, // // 摘要: // 可以对属性 (Property) 应用属性 (Attribute)。 Property = 128, // // 摘要: // 可以对字段应用属性。 Field = 256, // // 摘要: // 可以对事件应用属性。 Event = 512, // // 摘要: // 可以对接口应用属性。 Interface = 1024, // // 摘要: // 可以对参数应用属性。 Parameter = 2048, // // 摘要: // 可以对委托应用属性。 Delegate = 4096, // // 摘要: // 可以对返回值应用属性。 ReturnValue = 8192, // // 摘要: // 可以对泛型参数应用属性。 GenericParameter = 16384, // // 摘要: // 可以对任何应用程序元素应用属性。 All = 32767, } 特性应用于Assembly或者Module时，要这样写： [assembly: someAssemblyAttribute(Parameters)] [module: someAssemblyAttribute(Parameters)] 在指定自定义特性的有效目标元素时可以用为操作 |或运算符来组合 ，例如 [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.ReturnValue | AttributeTargets.Assembly,AllowMultiple=true,Inherited=false)] class TestAttribute:Attribute 该类有两个可选参数AllowMultiple 和Inherited ： AllowMultiple 参数表示一个特性是否能够多次应用在同一项上。 Inherited 参数如果为true，表示应用到类或者接口上的特性也自动应用到所有派生类或者接口上。如果应用到方法或者属性上，就可以自动应用到该方法或属性等重写的版本上 using AttributeTest; using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; [assembly: TestAttribute] [module: TestAttribute] namespace AttributeTest { /// \u003csummary\u003e /// AllowMultiple=true 表示同一个元素可以被应用多次该特性 /// Inherited=true 表示特性可以被继承 /// \u003c/summary\u003e [AttributeUsage(AttributeTargets.All,AllowMultiple=true,Inherited=true)] class TestAttribute:Attribute { /// \u003csummary\u003e /// 可选参数 /// \u003c/summary\u003e public int flag; /// \u003csummary\u003e /// 可选参数 /// \u003c/summary\u003e public bool isInner; /// \u003csummary\u003e /// 构造函数的参数是和正常构造函数传参一样的 /// \u003c/summary\u003e /// \u003cparam name=\"arg\"\u003e\u003c/param\u003e public TestAttribute(string arg=null){ } } [Test(\"class\",flag=3,isInner=true)] class AAA { [Test(\"constructor\",flag=2)] public AAA(){ } [Test] [Test] [Test(\"hello method\")] public void SSS(){ } } /// \u003csummary\u003e /// 这里特性的构造函数默认参数就是arg=null，可选参数没有传，按照正常默认值处理 /// \u003c/summary\u003e [Test] class BBB{ } class Program { static void Main(string[] args) { } } } ","date":"2019-12-01 21:57:40","objectID":"/csharp%E7%9A%84%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/:0:2","tags":["CSharp"],"title":"C# 特性详解（Attribute）","uri":"/csharp%E7%9A%84%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/"},{"categories":["CSharp"],"content":"指定特性参数 特性参数就是特性构造函数的参数，参考上面例子arg传参 ","date":"2019-12-01 21:57:40","objectID":"/csharp%E7%9A%84%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/:0:3","tags":["CSharp"],"title":"C# 特性详解（Attribute）","uri":"/csharp%E7%9A%84%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/"},{"categories":["CSharp"],"content":"指定特性可选参数 如上面例子的flag和isInner用法 0X02 特性例子 直接上代码 using AttributeTest; using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; [assembly: TestAttribute] [module: TestAttribute] namespace AttributeTest { /// \u003csummary\u003e /// AllowMultiple=true 表示同一个元素可以被应用多次该特性 /// Inherited=true 表示特性可以被继承 /// \u003c/summary\u003e [AttributeUsage(AttributeTargets.All,AllowMultiple=true,Inherited=true)] class TestAttribute:Attribute { /// \u003csummary\u003e /// 可选参数 /// \u003c/summary\u003e public int flag; /// \u003csummary\u003e /// 可选参数 /// \u003c/summary\u003e public bool isInner; /// \u003csummary\u003e /// 构造函数的参数是和正常构造函数传参一样的 /// \u003c/summary\u003e /// \u003cparam name=\"arg\"\u003e\u003c/param\u003e public TestAttribute(string arg=null){ } } [Test(\"class\",flag=3,isInner=true)] class AAA { [Test(\"constructor\",flag=2)] public AAA(){ } [Test] [Test(flag=10)] [Test(\"hello method\",flag=9)] public void SSS(){ } } /// \u003csummary\u003e /// 这里特性的构造函数默认参数就是arg=null，可选参数没有传，按照正常默认值处理 /// \u003c/summary\u003e [Test] class BBB{ } class Program { static void Main(string[] args) { Type t1 = typeof(AAA); object[] objs= t1.GetCustomAttributes(typeof(TestAttribute),false); foreach (var item in objs) { Console.WriteLine(\"AAA:::::::\" + ((TestAttribute)item).flag); } foreach (var item in t1.GetMethod(\"SSS\").GetCustomAttributes(typeof(TestAttribute), false)) { Console.WriteLine(\"AAA::Method:::::\" + ((TestAttribute)item).flag); } foreach (var item in typeof(BBB).GetCustomAttributes(typeof(TestAttribute), false)) { Console.WriteLine(\"BBB:::::::\" + ((TestAttribute)item).flag); } } } } 结果： ","date":"2019-12-01 21:57:40","objectID":"/csharp%E7%9A%84%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/:0:4","tags":["CSharp"],"title":"C# 特性详解（Attribute）","uri":"/csharp%E7%9A%84%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/"},{"categories":["CSharp"],"content":" 考虑了下，还是记录下吧 ，要不然以后又忘了 参考文章： C#与闭包 public class TCloser{ public Func\u003cint\u003e T1() { var n = 999; Func\u003cint\u003e result = () =\u003e { return n; }; n = 10; return result; } public dynamic T2() { var n = 999; dynamic result =new { A = n }; n = 10; return result; } static void Main(){ var a = new TCloser(); var b = a.T1(); var c = a.T2(); Console.WriteLine(b()); Console.WriteLine(c.A); } } 返回结果： 因为闭包的特性，这里匿名函数中所使用的变量就是实际T1中的变量，与之相反的是，匿名对象result里面的A只是初始化时被赋予了变量n的值，它并不是n，所以后面n改变之后A并未随之而改变。这正是闭包的魔力所在。 还有就是像T1方法带upvalue的返回函数其实IL中返回的是一个类，将变量n作为类的一个属性去处理的 ","date":"2019-12-01 21:57:40","objectID":"/%E9%97%AD%E5%8C%85closure/:0:0","tags":["CSharp"],"title":"C# 闭包Closure","uri":"/%E9%97%AD%E5%8C%85closure/"},{"categories":["计算机基础"],"content":"直接上代码 //===================================================== // - FileName: UnicodeTools // - Description: // - Author: wangguoqing // - Email: wangguoqing@hehemj.com // - Created: 2018/3/2 17:17:50 // - CLR version: 4.0.30319.42000 // - UserName: Wang // - (C) Copyright 2008 - 2015, hehehuyu,Inc. // - All Rights Reserved. //====================================================== using System; using System.Text; /// \u003csummary\u003e /// Unicode编码和中文互转 /// 这里的Unicode编码是Unicode Big Endian (UCS-2 Big Endian) /// \u003c/summary\u003e class UnicodeTools { /// \u003csummary\u003e /// 标准unicode编码 /// \u003c/summary\u003e /// \u003cparam name=\"text\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static string EncodeString(string text) { if (string.IsNullOrEmpty(text)) { return string.Empty; } int len = text.Length; StringBuilder builder = new StringBuilder(); for (int i = 0; i \u003c len; i++) { builder.Append(\"\\\\u\"); builder.Append(UShortToHex((ushort)text[i])); } return builder.ToString(); } /// \u003csummary\u003e /// 编码Unicode /// \u003c/summary\u003e /// \u003cparam name=\"text\"\u003e原字符串\u003c/param\u003e /// \u003creturns\u003eunicode编码\u003c/returns\u003e public static string EncodeString1(string text) { if (string.IsNullOrEmpty(text)) { return string.Empty; } var bytes = Encoding.Unicode.GetBytes(text); int len = bytes.Length; StringBuilder builder = new StringBuilder(); for (int i = 0; i \u003c len; i += 2) { builder.Append(\"\\\\u\"); builder.Append(bytes[i + 1].ToString(\"x2\")); builder.Append(bytes[i].ToString(\"x2\")); } return builder.ToString(); } public static string EncodeString2(string text) { if (string.IsNullOrEmpty(text)) { return string.Empty; } int len = text.Length; StringBuilder builder = new StringBuilder(); for (int i = 0; i \u003c len; i++) { builder.Append(\"\\\\u\"); builder.Append(((ushort)text[i]).ToString(\"x4\")); } return builder.ToString(); } private static char[] UShortToHex(ushort n) { int num; char[] hex = new char[4]; for (int i = 0; i \u003c 4; i++) { num = n % 16; if (num \u003c 10) hex[3 - i] = (char)('0' + num); else hex[3 - i] = (char)('A' + (num - 10)); n \u003e\u003e= 4; } return hex; } private static char[] UShortToHexE(ushort n) { var hex = n.ToString(\"x\").ToCharArray(); return hex; } public static string DecodeString(string unicode) { if (string.IsNullOrEmpty(unicode)) { return string.Empty; } //string[] ls = unicode.Replace(\"\\\\\", \"\").Split(new char[]{'u'},StringSplitOptions.RemoveEmptyEntries); string[] ls = unicode.Split(new string[] { \"\\\\u\" }, StringSplitOptions.RemoveEmptyEntries); StringBuilder builder = new StringBuilder(); int len = ls.Length; for (int i = 0; i \u003c len; i++) { //builder.Append((Char)ushort.Parse(ls[i], System.Globalization.NumberStyles.HexNumber)); builder.Append(Convert.ToChar(ushort.Parse(ls[i], System.Globalization.NumberStyles.HexNumber))); } return builder.ToString(); } /// \u003csummary\u003e /// 这种只能解出标准unicode编码 /// \u003c/summary\u003e /// \u003cparam name=\"unicode\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static string DecodeString1(string unicode) { if (string.IsNullOrEmpty(unicode)) { return string.Empty; } return System.Text.RegularExpressions.Regex.Unescape(unicode); } } 测试 string s = \"天空测试s\"; Console.WriteLine(UnicodeTools.EncodeString(s)); Console.WriteLine(UnicodeTools.EncodeString1(s)); Console.WriteLine(UnicodeTools.EncodeString2(s)); Console.WriteLine(UnicodeTools.DecodeString(UnicodeTools.EncodeString(s))); Console.WriteLine(UnicodeTools.DecodeString(UnicodeTools.EncodeString1(s))); Console.WriteLine(UnicodeTools.DecodeString(UnicodeTools.EncodeString2(s))); Console.WriteLine(UnicodeTools.DecodeString1(UnicodeTools.EncodeString(s))); Console.WriteLine(UnicodeTools.DecodeString1(UnicodeTools.EncodeString1(s))); Console.WriteLine(UnicodeTools.DecodeString1(UnicodeTools.EncodeString2(s))); 结果 ","date":"2019-12-01 21:57:40","objectID":"/csharp-unicode%E7%BC%96%E7%A0%81%E5%92%8C%E4%B8%AD%E6%96%87%E4%BA%92%E8%BD%AC/:0:0","tags":["Unicode编码"],"title":"C#-Unicode编码和中文互转","uri":"/csharp-unicode%E7%BC%96%E7%A0%81%E5%92%8C%E4%B8%AD%E6%96%87%E4%BA%92%E8%BD%AC/"},{"categories":[""],"content":"###变量 1.变量的声明和定义 C#基础：变量的声明、定义、初始化 ","date":"2019-12-01 21:57:40","objectID":"/csharp%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/:0:0","tags":[""],"title":"C#基础笔记","uri":"/csharp%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"},{"categories":["CSharp"],"content":"直接上代码 //===================================================== // - FileName: ProcessTask // - Description: // - Author: wangguoqing // - Email: wangguoqing@hehemj.com // - Created: 2017/12/13 17:12:17 // - CLR version: 4.0.30319.42000 // - UserName: Wang // - (C) Copyright 2008 - 2015, hehehuyu,Inc. // - All Rights Reserved. //====================================================== using System; using System.Collections.Generic; using System.Diagnostics; using System.IO; using System.Text; using System.Threading; using UnityEngine; using Debug = UnityEngine.Debug; class ProcessTask { public static bool RunProcess(string filePath,string args=\"\") { bool isSuncc = true; ProcessStartInfo start = new ProcessStartInfo(); start.FileName = filePath; //start.Arguments = args+\"\u0026exit\"; start.UseShellExecute = false;//是否使用操作系统shell启动 start.RedirectStandardOutput = true;//由调用程序获取输出信息 start.RedirectStandardError = true;//重定向标准错误输出 start.RedirectStandardInput = true;//接受来自调用程序的输入信息 //start.CreateNoWindow = true;/不显示程序窗口 //start.WorkingDirectory = \"\"; using (Process process = Process.Start(start)) { process.StandardInput.WriteLine(args); process.StandardInput.WriteLine(\"exit\"); process.EnableRaisingEvents = true; process.BeginOutputReadLine(); process.OutputDataReceived += (s, e) =\u003e { if (!string.IsNullOrEmpty(e.Data)) Console.WriteLine(e.Data); }; using (StreamReader reader = process.StandardError) { string result = reader.ReadToEnd(); if (!string.IsNullOrEmpty(result)) { Debug.LogError(result); isSuncc = false; } } //using (StreamReader reader = process.StandardOutput) //{ // string result = reader.ReadToEnd(); // if (!string.IsNullOrEmpty(result)) // { // UnityEngine.Debug.Log(\"\" + result); // } //} process.WaitForExit(); } return isSuncc; } public static string[] RunProcess(string filePath, string args, string workDir) { bool isSuncc = true; List\u003cstring\u003e ls = new List\u003cstring\u003e(); ProcessStartInfo start = new ProcessStartInfo(); start.FileName = filePath; start.Arguments = args; start.UseShellExecute = false; start.RedirectStandardOutput = true; start.RedirectStandardError = true; start.RedirectStandardInput = true; //start.CreateNoWindow = true; //start.WorkingDirectory = workDir; string CurDir = Environment.CurrentDirectory; Environment.CurrentDirectory = workDir; using (Process process = Process.Start(start)) { process.EnableRaisingEvents = true; //process.BeginOutputReadLine(); process.OutputDataReceived += (s, e) =\u003e { if (!string.IsNullOrEmpty(e.Data)) Console.WriteLine(e.Data); }; using (StreamReader reader = process.StandardError) { string result = reader.ReadToEnd(); if (!string.IsNullOrEmpty(result)) { Debug.LogError(result); isSuncc = false; } } using (StreamReader reader = process.StandardOutput) { string line = string.Empty; while((line=reader.ReadLine())!=null) { ls.Add(line); } } process.WaitForExit(); } Environment.CurrentDirectory = CurDir; if(isSuncc) { return ls.ToArray(); } return null; } public static void RunCmdAsync(string arg) { System.Console.InputEncoding = System.Text.Encoding.UTF8; Process process = new Process(); process.StartInfo.FileName = \"cmd.exe\"; //process.StartInfo.Arguments = arg; process.StartInfo.UseShellExecute = false;//是否使用操作系统shell启动 process.StartInfo.RedirectStandardOutput = true;//由调用程序获取输出信息 process.StartInfo.RedirectStandardError = true;//重定向标准错误输出 process.StartInfo.RedirectStandardInput = true;//接受来自调用程序的输入信息 //process.StartInfo.CreateNoWindow = true;//不显示程序窗口 //process.StartInfo.WorkingDirectory = \"./\"; process.OutputDataReceived += new DataReceivedEventHandler(OutputReceived); process.ErrorDataReceived += new DataReceivedEventHandler(ErrorReceived); process.EnableRaisingEvents = true; // 启用Exited事件 process.Exited += new EventHandler(ExitReceived); // 注册进程结束事件 process.Start(); process.StandardInput.WriteLine(arg); process.StandardInput.WriteLine(\"exit\"); process.BeginOutputReadLine(); process.BeginErrorReadLine(); // 如果打开注释，则以同步方式执行命令，此例子中用Exited事件异步执行。 // CmdProcess.WaitForExit(); } private st","date":"2019-12-01 21:57:40","objectID":"/csharp%E7%94%A8process%E7%B1%BB%E8%B0%83%E7%94%A8cmd%E6%89%A7%E8%A1%8C%E5%8F%8A%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%A6%96%E5%AD%97%E6%AF%8D%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/:0:0","tags":["Unicode编码"],"title":"C#用Process类调用cmd执行及命令行首字母乱码问题","uri":"/csharp%E7%94%A8process%E7%B1%BB%E8%B0%83%E7%94%A8cmd%E6%89%A7%E8%A1%8C%E5%8F%8A%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%A6%96%E5%AD%97%E6%AF%8D%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"},{"categories":["CSharp"],"content":"一共有三种用法： 在 C# 中，new 关键字可用作运算符、修饰符或约束。 ==1）new 运算符：用于创建对象和调用构造函数。这种大家都比较熟悉，没什么好说的了。== ==2）new 修饰符：在用作修饰符时，new 关键字可以显式隐藏从基类继承的成员。== ==3）new 约束：用于在泛型声明中约束可能用作类型参数的参数的类型。== 直接上代码： using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace NewTest { /* * a) 作为运算符用来创建一个对象和调用构造函数。 * b) 作为修饰符。 * c) 用于在泛型声明中约束可能用作类型参数的参数的类型。 * */ class A { public A() { } public int data; public int Data { get { return data; } set { data = value; } } public int Data1 { get; set; } public virtual void Get() { Console.WriteLine(\"AAAAAAA\"); } } class B : A { public B():base() { } new public int data; new public int Data { get; set; } new public int Data1 { get; set; } new public void Get() { Console.WriteLine(\"BBBBBBB\"); } } class C\u003cT\u003e where T:new() { } class Program { static void Main(string[] args) { B b = new B(); b.data = 10; b.Data = 12; b.Data1 = 13; Console.WriteLine($\"B:::data:{b.data},Data:{b.Data},Data1:{b.Data1}\"); b.Get(); A a = b ; Console.WriteLine($\"A:::data:{a.data},Data:{a.Data},Data1:{a.Data1}\"); a.data = 100; a.Data = 120; a.Data1 = 130; Console.WriteLine($\"A:::data:{a.data},Data:{a.Data},Data1:{a.Data1}\"); a.Get(); Console.WriteLine($\"B:::data:{b.data},Data:{b.Data},Data1:{b.Data1}\"); b.Get(); C\u003cB\u003e c = new C\u003cB\u003e(); } } } 结果： b断点调试结果： 这里说明下，重写父类的变量其实是重新定义了一个新的变量，变量名相同是把父类的变量隐藏了，会增加内存 参考文章： C#的new关键字的几种用法 ","date":"2019-12-01 21:57:40","objectID":"/new%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95/:0:0","tags":["CSharp"],"title":"C#的new关键字的几种用法","uri":"/new%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95/"},{"categories":["c++"],"content":" 数据对齐几年前看过，都忘了，看深入理解计算机系统又看到了，今天回顾下做下记录 参考文章: struct union数据对齐和sizeof大小 这篇文章只说明struct结构体和union联合体的对齐 基本数据类型的数据对齐 基本类型的数据对齐值是其本身的大小。 struct/class的自身对齐值。对于结构体和类的自身对齐值是所有成员中最大的自身对齐值。 结构体和类的对齐规则：先将数据成员对齐，在将结构体和类自身对齐，最终大小与数据成员顺序 有关。 这里的数据对齐是指数据的地址是对齐 union的自身对齐值。union的自身对齐值是所有成员中最大的对齐值。union的对齐规则，只需要union自身对齐，不需要数据成员对齐,最终大小与数据成员顺序无关。 指定对齐值。使用#pragma pack(n)指定对齐值为n,使用#pragma pack() 回复默认对齐值。 有效对齐值。 对于指定了对齐值的代码， 有效对齐值=min(类/结构体/成员的自身对齐值， 指定对齐值) 未指定对齐值时，默认的对齐值一般为4。 有效对齐值决定了数据存放的方式，sizeof运算符是根据有效对齐值计算大小的。 ","date":"2019-12-01 21:57:40","objectID":"/c-_structunion%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90/:0:0","tags":["c++"],"title":"C++ struct union数据对齐","uri":"/c-_structunion%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90/"},{"categories":["c++"],"content":"struct结构体的数据对齐 上测试代码： #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e struct A { char a[7]; short b; int c; }; struct B { short a; int b; char c[9]; }; struct C { int a; char b[7]; short c; }; void main() { printf(\"A:%d\\n\", sizeof(A)); printf(\"B:%d\\n\", sizeof(B)); printf(\"C:%d\\n\", sizeof(C)); A a; printf(\"a:%0x,a.a:%0x,a.b:%0x,a.c:%0x\\n\", \u0026a, \u0026a.a, \u0026a.b, \u0026a.c); B b; printf(\"b:%0x,b.a:%0x,b.b:%0x,b.c:%0x\\n\", \u0026b, \u0026b.a, \u0026b.b, \u0026b.c); C c; printf(\"c:%0x,c.a:%0x,c.b:%0x,c.c:%0x\\n\", \u0026c, \u0026c.a, \u0026c.b, \u0026c.c); system(\"pause\"); } 结果： A A的大小如果不考虑数据对齐的话为13，假设a变量起始位0X00,a.a是第一个变量，所以a.a的地址位0X00，a.a的地址对齐值是1，共分配7个字节；a.b的地址对齐值是2 ，所以a.b起始地址必须满足被2整除，所以a.b的地址是0X08（(7+1)%2=0），分配2个字节；a.c的地址对齐值是4，前面占用10个字节了，所以地址是0X0C（(10+2)%4=0）,分配4个字节，当前A的大小是16个字节，A的对齐值是4，16%4=0，所以A的大小是16字节 B 假设b变量起始位0X00,b.a是第一个变量，所以b.a的地址位0X00，b.a的地址对齐值是2，分配2个字节；b.b的地址对齐值是4 ，所以b.b起始地址必须满足被4整除，所以b.b的地址是0X04（(2+2)%4=0），分配4个字节；b.c的地址对齐值是1个字节，前面占用8个字节了，所以地址是0X08（(8+0)%1=0）,分配9字节，当前B的大小是17个字节，B的对齐值是4，(17+3)%4=0，所以B的大小是20字节 C 假设c变量起始位0X00,c.a是第一个变量，所以b.a的地址位0X00，c.a的地址对齐值是4，分配4个字节；c.b的地址对齐值是1 ，所以c.b起始地址必须满足被1整除，所以c.b的地址是0X04（(4+0)%4=0），分配7个字节；c.c的地址对齐值是2，前面占用11个字节了，所以地址是0X0C（(11+1)%2=0）,分配2字节，当前B的大小是14个字节，B的对齐值是4，(14+2)%4=0，所以B的大小是16字节 A,B,C结构体的数据对齐值是所有基础变量的最大值，这里是int，对齐值4， 根据打印结果验证通过 ","date":"2019-12-01 21:57:40","objectID":"/c-_structunion%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90/:1:0","tags":["c++"],"title":"C++ struct union数据对齐","uri":"/c-_structunion%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90/"},{"categories":["c++"],"content":"union联合体数据对齐 上测试代码： #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e union A { char a[7]; short b; int c; }; union B { short a; long long b; char c[9]; }; void main() { printf(\"A:%d\\n\", sizeof(A)); printf(\"B:%d\\n\", sizeof(B)); printf(\"long long size:%d\\n\", sizeof(long long)); A a; printf(\"a:%0x,a.a:%0x,a.b:%0x,a.c:%0x\\n\", \u0026a, \u0026a.a, \u0026a.b, \u0026a.c); B b; printf(\"b:%0x,b.a:%0x,b.b:%0x,b.c:%0x\\n\", \u0026b, \u0026b.a, \u0026b.b, \u0026b.c); system(\"pause\"); } 结果： A A 三个变量占用字节最大的值是a,7个字节，A的对齐值是4，所以A的大小是7+1=8（（7+1）%4=0） B B 三个变量占用字节最大的值是c,9个字节，B的对齐值是8，所以B的大小是9+7=16 （（9+7）%8=0） 结构体和联合体嵌套混合也是这么分析，这里不再做说明了 ","date":"2019-12-01 21:57:40","objectID":"/c-_structunion%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90/:2:0","tags":["c++"],"title":"C++ struct union数据对齐","uri":"/c-_structunion%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90/"},{"categories":["随笔"],"content":"本人亲测有效 https://www.jianshu.com/p/189fd945f38f ","date":"2019-12-01 21:57:40","objectID":"/github-hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A22017/:0:0","tags":[""],"title":"github+hexo建立个人博客2017","uri":"/github-hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A22017/"},{"categories":["随笔"],"content":"在执行命令时报错ssh -T git@github.com $ ssh -T git@github.com The authenticity of host 'github.com (192.30.255.113)' can't be established. RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added 'github.com,192.30.255.113' (RSA) to the list of known hosts. git@github.com: Permission denied (publickey). 使用命令查看 ssh -v git@github.com $ ssh -v git@github.com OpenSSH_7.6p1, OpenSSL 1.0.2l 25 May 2017 debug1: Reading configuration data /etc/ssh/ssh_config debug1: Connecting to github.com [192.30.255.112] port 22. debug1: Connection established. debug1: key_load_public: No such file or directory debug1: identity file /c/Users/Wang/.ssh/id_rsa type -1 debug1: key_load_public: No such file or directory debug1: identity file /c/Users/Wang/.ssh/id_rsa-cert type -1 debug1: key_load_public: No such file or directory debug1: identity file /c/Users/Wang/.ssh/id_dsa type -1 debug1: key_load_public: No such file or directory debug1: identity file /c/Users/Wang/.ssh/id_dsa-cert type -1 debug1: key_load_public: No such file or directory debug1: identity file /c/Users/Wang/.ssh/id_ecdsa type -1 debug1: key_load_public: No such file or directory debug1: identity file /c/Users/Wang/.ssh/id_ecdsa-cert type -1 debug1: key_load_public: No such file or directory debug1: identity file /c/Users/Wang/.ssh/id_ed25519 type -1 debug1: key_load_public: No such file or directory debug1: identity file /c/Users/Wang/.ssh/id_ed25519-cert type -1 debug1: Local version string SSH-2.0-OpenSSH_7.6 debug1: Remote protocol version 2.0, remote software version libssh_0.7.0 debug1: no match: libssh_0.7.0 debug1: Authenticating to github.com:22 as 'git' debug1: SSH2_MSG_KEXINIT sent debug1: SSH2_MSG_KEXINIT received debug1: kex: algorithm: curve25519-sha256@libssh.org debug1: kex: host key algorithm: ssh-rsa debug1: kex: server-\u003eclient cipher: aes128-ctr MAC: hmac-sha2-256 compression: none debug1: kex: client-\u003eserver cipher: aes128-ctr MAC: hmac-sha2-256 compression: none debug1: expecting SSH2_MSG_KEX_ECDH_REPLY debug1: Server host key: ssh-rsa SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8 debug1: Host 'github.com' is known and matches the RSA host key. debug1: Found key in /c/Users/Wang/.ssh/known_hosts:1 Warning: Permanently added the RSA host key for IP address '192.30.255.112' to the list of known hosts. debug1: rekey after 4294967296 blocks debug1: SSH2_MSG_NEWKEYS sent debug1: expecting SSH2_MSG_NEWKEYS debug1: SSH2_MSG_NEWKEYS received debug1: rekey after 4294967296 blocks debug1: SSH2_MSG_SERVICE_ACCEPT received debug1: Authentications that can continue: publickey debug1: Next authentication method: publickey debug1: Trying private key: /c/Users/Wang/.ssh/id_rsa debug1: Trying private key: /c/Users/Wang/.ssh/id_dsa debug1: Trying private key: /c/Users/Wang/.ssh/id_ecdsa debug1: Trying private key: /c/Users/Wang/.ssh/id_ed25519 debug1: No more authentication methods to try. git@github.com: Permission denied (publickey). 最后发现使用.ssh目录下的几个private key ，把自己私钥的文件名改成第一个Trying private key的名字id_rsa 然后在重新执行就能连上了 ","date":"2019-12-01 21:57:40","objectID":"/github-ssh%E5%A4%B1%E8%B4%A5permission-denied-publickey/:0:0","tags":[""],"title":"GitHub-ssh失败Permission-denied-(publickey)","uri":"/github-ssh%E5%A4%B1%E8%B4%A5permission-denied-publickey/"},{"categories":["随笔"],"content":" 参考 Hugo 入门 安装和使用 ","date":"2019-12-01 21:57:40","objectID":"/hugo-%E5%85%A5%E9%97%A8-%E5%AE%89%E8%A3%85windows/:0:0","tags":[""],"title":"Hugo 入门 安装（Windows）","uri":"/hugo-%E5%85%A5%E9%97%A8-%E5%AE%89%E8%A3%85windows/"},{"categories":["随笔"],"content":"1. 下载Hugo Hugo官网 github 下载：下载Hugo 这里下载的是hugo_0.74.3_Windows-64bit.zip 解压后就一个exe文件 放在文件夹F:\\Hugo\\bin\\中，然后添加到环境变量中 执行 hugo -version 出现版本号，配置完成 ","date":"2019-12-01 21:57:40","objectID":"/hugo-%E5%85%A5%E9%97%A8-%E5%AE%89%E8%A3%85windows/:0:1","tags":[""],"title":"Hugo 入门 安装（Windows）","uri":"/hugo-%E5%85%A5%E9%97%A8-%E5%AE%89%E8%A3%85windows/"},{"categories":["随笔"],"content":"2. 创建站点项目 假设要创建站点存放在F:\\Hugo\\Sites\\目录中 在命令行切换到该目录下执行hugo new site codingriver 创建codingriver站点项目 创建完成 ","date":"2019-12-01 21:57:40","objectID":"/hugo-%E5%85%A5%E9%97%A8-%E5%AE%89%E8%A3%85windows/:0:2","tags":[""],"title":"Hugo 入门 安装（Windows）","uri":"/hugo-%E5%85%A5%E9%97%A8-%E5%AE%89%E8%A3%85windows/"},{"categories":["随笔"],"content":"3.添加主题 命令行切换到新创建站点项目codingriver内 添加主题 maupassant执行git clone https://github.com/JokerQyou/maupassant-hugo.git themes/maupassant 这样主题下载完成然后，在当前项目目录内打开config.toml配置文件，在最后添加一行theme = \"maupassant\" 这样主题配置完成 ","date":"2019-12-01 21:57:40","objectID":"/hugo-%E5%85%A5%E9%97%A8-%E5%AE%89%E8%A3%85windows/:0:3","tags":[""],"title":"Hugo 入门 安装（Windows）","uri":"/hugo-%E5%85%A5%E9%97%A8-%E5%AE%89%E8%A3%85windows/"},{"categories":["随笔"],"content":"4. 运行站点项目 在站点项目内执行命令hugo server -D 这里表示执行成功，打开网页http://localhost:1313/ 安装配置完成 ","date":"2019-12-01 21:57:40","objectID":"/hugo-%E5%85%A5%E9%97%A8-%E5%AE%89%E8%A3%85windows/:0:4","tags":[""],"title":"Hugo 入门 安装（Windows）","uri":"/hugo-%E5%85%A5%E9%97%A8-%E5%AE%89%E8%A3%85windows/"},{"categories":["随笔"],"content":"5. 使用 使用教程https://www.flysnow.org/2018/07/29/from-hexo-to-hugo.html 使用教程 https://blog.csdn.net/weixin_30952535/article/details/97155453 主題説明 https://github.com/JokerQyou/maupassant-hugo/blob/master/README_zh.md 主題説明 https://github.com/flysnow-org/maupassant-hugo 參考文章 https://www.cnblogs.com/kika/p/10851605.html ","date":"2019-12-01 21:57:40","objectID":"/hugo-%E5%85%A5%E9%97%A8-%E5%AE%89%E8%A3%85windows/:0:5","tags":[""],"title":"Hugo 入门 安装（Windows）","uri":"/hugo-%E5%85%A5%E9%97%A8-%E5%AE%89%E8%A3%85windows/"},{"categories":["随笔"],"content":"6. 常见问题 Unable to locate Config file 启动 hugo 内置服务器时，会在当前目录执行的目录中寻找项目的配置文件。所以，需要在项目根目录中执行这个命令，否则报错如下： C:\\Users\\kika\\kikakika\\themes\u003ehugo server --theme=hugo-bootstrap --buildDrafts --watch Error: Unable to locate Config file. Perhaps you need to create a new site. Run `hugo help new` for details. (Config File \"config\" Not Found in \"[C:\\\\Users\\\\kika\\\\kikakika\\\\themes]\") Unable to find theme Directory hugo 默认在项目中的 themes 目录中寻找指定的主题。所有下载的主题都要放在这个目录中才能使用，否则报错如下： C:\\Users\\kika\\kikakika\u003ehugo server --theme=hugo-bootstrap --buildDrafts --watch Error: Unable to find theme Directory: C:\\Users\\kika\\kikakika\\themes\\hugo-bootstrap 生成的网站没有文章 生成静态网站时，hugo 会忽略所有通过 draft: true 标记为草稿的文件。必须改为 draft: false 才会编译进 HTML 文件。 ","date":"2019-12-01 21:57:40","objectID":"/hugo-%E5%85%A5%E9%97%A8-%E5%AE%89%E8%A3%85windows/:0:6","tags":[""],"title":"Hugo 入门 安装（Windows）","uri":"/hugo-%E5%85%A5%E9%97%A8-%E5%AE%89%E8%A3%85windows/"},{"categories":["IOS"],"content":"这个错误是因为Xcode缺少对应ios版本的supoort文件 iOS 升级到11之后，你会发现无法进行真机测试了。这种情况我在iOS 10.0更新的时候也遇到过。原因是Xcode 的DeviceSupport里面缺少了对应iOS系统版本的SDK。所以你可以选择将Xcode更新到最新版本。 或者从新版的Xcode目录支持文件复制到自己的Xcode目录中 文件路径：/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport 打开这个路径，然后看到ios 系统列表 找到自己需要的版本（我用的是11.1）将整个文件夹拷贝到自己的Xcode目录中 ","date":"2019-12-01 21:57:40","objectID":"/ios-11-%E5%8D%87%E7%BA%A7%E5%90%8E%E6%97%A0%E6%B3%95%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95could-not-locate-device-support-files/:0:0","tags":["IOS","Xcode"],"title":"iOS-11-升级后无法真机调试（could-not-locate-device-support-files）","uri":"/ios-11-%E5%8D%87%E7%BA%A7%E5%90%8E%E6%97%A0%E6%B3%95%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95could-not-locate-device-support-files/"},{"categories":["IOS"],"content":" 1.等比缩放 - (UIImage *) scaleImage:(UIImage *)image toScale:(float)scaleSize { UIGraphicsBeginImageContext(CGSizeMake(image.size.width * scaleSize, image.size.height * scaleSize); [image drawInRect:CGRectMake(0, 0, image.size.width * scaleSize, image.size.height * scaleSize)]; UIImage *scaledImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return scaledImage; } 2.自定义大小 - (UIImage *) reSizeImage:(UIImage *)image toSize:(CGSize)reSize { UIGraphicsBeginImageContext(CGSizeMake(reSize.width, reSize.height)); [image drawInRect:CGRectMake(0, 0, reSize.width, reSize.height)]; UIImage *reSizeImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return reSizeImage; } ","date":"2019-12-01 21:57:40","objectID":"/ios-object-c-uiimage%E5%9B%BE%E7%89%87%E7%BC%A9%E6%94%BE/:0:0","tags":["IOS"],"title":"ios-object-c-UIImage图片缩放","uri":"/ios-object-c-uiimage%E5%9B%BE%E7%89%87%E7%BC%A9%E6%94%BE/"},{"categories":["IOS"],"content":" //获取appIconName -(NSString*)GetAppIconName{ NSDictionary *infoPlist = [[NSBundle mainBundle] infoDictionary]; NSString *icon = [[infoPlist valueForKeyPath:@\"CFBundleIcons.CFBundlePrimaryIcon.CFBundleIconFiles\"] lastObject]; NSLog(@\"GetAppIconName,icon:%@\",icon); return icon; } ··· ","date":"2019-12-01 21:57:40","objectID":"/ios-object-c-%E8%8E%B7%E5%8F%96app%E5%9B%BE%E6%A0%87%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E5%90%8D%E5%AD%97appicon/:0:0","tags":["IOS"],"title":"ios-object-c-获取App图标使用的图片名字AppIcon","uri":"/ios-object-c-%E8%8E%B7%E5%8F%96app%E5%9B%BE%E6%A0%87%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E5%90%8D%E5%AD%97appicon/"},{"categories":["IOS"],"content":" 关于怎么配置开发者证书和添加AppID 参考 http://www.jianshu.com/writer#/notebooks/6185424/notes/23554406/preview ","date":"2019-12-01 21:57:40","objectID":"/ios-%E9%85%8D%E7%BD%AEitunesconnect%E6%B7%BB%E5%8A%A0%E5%BA%94%E7%94%A8/:0:0","tags":["IOS","Xcode"],"title":"ios-配置ItunesConnect添加应用","uri":"/ios-%E9%85%8D%E7%BD%AEitunesconnect%E6%B7%BB%E5%8A%A0%E5%BA%94%E7%94%A8/"},{"categories":["IOS"],"content":"01 在ItunesConnect中添加新的应用 1.打开 https://itunesconnect.apple.com/login 并且登录 2.点击我的App 3.点击*+*====\u003e新建App 4.配置信息 平台：根据需求选择，这里选择iOS 应用名字 语言 套装ID：通过开发者账户配置添加的AppID,参考引用的连接 SKU ：这里我写的bundleID,随意 点击创建,这样就创建完成 ","date":"2019-12-01 21:57:40","objectID":"/ios-%E9%85%8D%E7%BD%AEitunesconnect%E6%B7%BB%E5%8A%A0%E5%BA%94%E7%94%A8/:1:0","tags":["IOS","Xcode"],"title":"ios-配置ItunesConnect添加应用","uri":"/ios-%E9%85%8D%E7%BD%AEitunesconnect%E6%B7%BB%E5%8A%A0%E5%BA%94%E7%94%A8/"},{"categories":["IOS"],"content":"02 在ItunesConnect中配置应用的付费信息 1.配置应用收费是否收费下载，这里配置是免费 2.添加商品 点击应用的功能===\u003e点击+添加商品 根据自己需求选择添加商品的类型 配置商品的信息，添加商城截图，完成后点击存储 然后看到该条商品的信息了，状态是准备提交 在提审前打开提审的版本1.0配置界面，向下拉，找到App内购项目，点击+号，然后勾选自己的商品（可以选多个），这里是一小袋钻石，点击完成 提审的时候商品也需要审核的！提审的时候商品也需要审核的！提审的时候商品也需要审核的！重要的事情说三遍 到这里完成了 ","date":"2019-12-01 21:57:40","objectID":"/ios-%E9%85%8D%E7%BD%AEitunesconnect%E6%B7%BB%E5%8A%A0%E5%BA%94%E7%94%A8/:2:0","tags":["IOS","Xcode"],"title":"ios-配置ItunesConnect添加应用","uri":"/ios-%E9%85%8D%E7%BD%AEitunesconnect%E6%B7%BB%E5%8A%A0%E5%BA%94%E7%94%A8/"},{"categories":["IOS"],"content":" 引用文章: http://blog.csdn.net/hicui/article/details/51146969 ","date":"2019-12-01 21:57:40","objectID":"/ios%E4%B8%ADxcode-framework%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%ABheaders%E7%9B%AE%E5%BD%95%E9%97%AE%E9%A2%98%E5%A4%B4%E6%96%87%E4%BB%B6%E8%AF%BB%E4%B8%8D%E5%87%BA%E6%9D%A5/:0:0","tags":["IOS","Xcode"],"title":"IOS中Xcode-framework无法识别headers目录问题，头文件读不出来","uri":"/ios%E4%B8%ADxcode-framework%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%ABheaders%E7%9B%AE%E5%BD%95%E9%97%AE%E9%A2%98%E5%A4%B4%E6%96%87%E4%BB%B6%E8%AF%BB%E4%B8%8D%E5%87%BA%E6%9D%A5/"},{"categories":["IOS"],"content":"问题现象 framework是ios开发中经常使用到的一个组件，但是有些情况下拿到第三方提供的framework，导入自己的项目后会发现，Headers目录无法识别，编译出错的情况，比如这里：http://tieba.baidu.com/p/4405458569# ","date":"2019-12-01 21:57:40","objectID":"/ios%E4%B8%ADxcode-framework%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%ABheaders%E7%9B%AE%E5%BD%95%E9%97%AE%E9%A2%98%E5%A4%B4%E6%96%87%E4%BB%B6%E8%AF%BB%E4%B8%8D%E5%87%BA%E6%9D%A5/:1:0","tags":["IOS","Xcode"],"title":"IOS中Xcode-framework无法识别headers目录问题，头文件读不出来","uri":"/ios%E4%B8%ADxcode-framework%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%ABheaders%E7%9B%AE%E5%BD%95%E9%97%AE%E9%A2%98%E5%A4%B4%E6%96%87%E4%BB%B6%E8%AF%BB%E4%B8%8D%E5%87%BA%E6%9D%A5/"},{"categories":["IOS"],"content":"问题原因 常见IOS framework的目录结构为： sdk.framework目录  Headers目录 SDK文件 但是有些第三方framework生成时，脚本有问题，生成的目录结构为： sdk.framework目录  Headers软链接 SDK软链接 Versions目录 -current软链接 -A目录  Headers目录 SDK文件 软链接在不同的电脑上移动时可能会出现路径不存在，因此就导致xcode无法识别Headers目录的情况。 ","date":"2019-12-01 21:57:40","objectID":"/ios%E4%B8%ADxcode-framework%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%ABheaders%E7%9B%AE%E5%BD%95%E9%97%AE%E9%A2%98%E5%A4%B4%E6%96%87%E4%BB%B6%E8%AF%BB%E4%B8%8D%E5%87%BA%E6%9D%A5/:2:0","tags":["IOS","Xcode"],"title":"IOS中Xcode-framework无法识别headers目录问题，头文件读不出来","uri":"/ios%E4%B8%ADxcode-framework%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%ABheaders%E7%9B%AE%E5%BD%95%E9%97%AE%E9%A2%98%E5%A4%B4%E6%96%87%E4%BB%B6%E8%AF%BB%E4%B8%8D%E5%87%BA%E6%9D%A5/"},{"categories":["IOS"],"content":"解决 将sdk.framework/Versions/A/ 下的Headers和SDK文件移动到sdk.framework目录下，将其他文件删除，重新编译即可。 ","date":"2019-12-01 21:57:40","objectID":"/ios%E4%B8%ADxcode-framework%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%ABheaders%E7%9B%AE%E5%BD%95%E9%97%AE%E9%A2%98%E5%A4%B4%E6%96%87%E4%BB%B6%E8%AF%BB%E4%B8%8D%E5%87%BA%E6%9D%A5/:3:0","tags":["IOS","Xcode"],"title":"IOS中Xcode-framework无法识别headers目录问题，头文件读不出来","uri":"/ios%E4%B8%ADxcode-framework%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%ABheaders%E7%9B%AE%E5%BD%95%E9%97%AE%E9%A2%98%E5%A4%B4%E6%96%87%E4%BB%B6%E8%AF%BB%E4%B8%8D%E5%87%BA%E6%9D%A5/"},{"categories":["IOS"],"content":" 原文： ios配置开发者证书及添加AppID 一. 有两种配置开发者证书的方法 ","date":"2019-12-01 21:57:40","objectID":"/ios%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E8%80%85%E8%AF%81%E4%B9%A6%E5%8F%8A%E6%B7%BB%E5%8A%A0appid/:0:0","tags":["IOS"],"title":"ios配置开发者证书及添加AppID","uri":"/ios%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E8%80%85%E8%AF%81%E4%B9%A6%E5%8F%8A%E6%B7%BB%E5%8A%A0appid/"},{"categories":["IOS"],"content":"第一种，通用的并且复杂的一种 ","date":"2019-12-01 21:57:40","objectID":"/ios%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E8%80%85%E8%AF%81%E4%B9%A6%E5%8F%8A%E6%B7%BB%E5%8A%A0appid/:1:0","tags":["IOS"],"title":"ios配置开发者证书及添加AppID","uri":"/ios%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E8%80%85%E8%AF%81%E4%B9%A6%E5%8F%8A%E6%B7%BB%E5%8A%A0appid/"},{"categories":["IOS"],"content":"0X01 创建请求证书的请求文件 1.打开钥匙串 2 2.创建请求文件 打开：钥匙串访问===\u003e证书助理===\u003e从证书颁发机构请求证书… 请求是：存储到磁盘 设置电邮地址 点击继续 存储请求文件 ","date":"2019-12-01 21:57:40","objectID":"/ios%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E8%80%85%E8%AF%81%E4%B9%A6%E5%8F%8A%E6%B7%BB%E5%8A%A0appid/:2:0","tags":["IOS"],"title":"ios配置开发者证书及添加AppID","uri":"/ios%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E8%80%85%E8%AF%81%E4%B9%A6%E5%8F%8A%E6%B7%BB%E5%8A%A0appid/"},{"categories":["IOS"],"content":"0X02 创建开发证书 1.打开https://developer.apple.com 点击Account 登录 点击：Certificates, Identifiers \u0026 Profiles 点击Certificates 的+号，准备创建开发者证书 这里根据自己的需求选择开发证书还是生产证书（如果是自己测试可以选择Development开发证书，如果发布appstore提审，则需要Production生产证书） 拖到屏幕最下面，选择继续 选择继续 这里选择刚才生成的创建开发者证书的请求文件 选择继续 这里选择下载，证书已经配置完成，下载到本地,然后点击Done 证书下载完成后双击自动导入证书，检查证书是否成功导入! 创建开发者证书12.png 我之前在创建证书请求文件时配置的常用名称wang_develop 这里看到表示成功了 ","date":"2019-12-01 21:57:40","objectID":"/ios%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E8%80%85%E8%AF%81%E4%B9%A6%E5%8F%8A%E6%B7%BB%E5%8A%A0appid/:3:0","tags":["IOS"],"title":"ios配置开发者证书及添加AppID","uri":"/ios%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E8%80%85%E8%AF%81%E4%B9%A6%E5%8F%8A%E6%B7%BB%E5%8A%A0appid/"},{"categories":["IOS"],"content":"第二种，通过Xcode配置，（我这里是Xcode9.2，Xcode8.0及以上都可以） 1.打开Xcode，这里就不说怎么打开了 2.点击左上角Xcode按钮===\u003ePreferences… 点击 Accounts 选择自己apple账户，然后点击 * Manage Certificates* 4.点击+号 这里点击+号后展开菜单有Development和App Store（这里根据自己的需求选择开发证书还是生产证书（如果是自己测试可以选择Development开发证书，如果发布appstore提审，则需要App Store生产证书）） 等待证书添加完成 这里证书添加完成，然后重启Xcode，防止出现未知bug #二. 添加AppId 打开开发者账户网站（上面网页中配置证书的地方） 1.App IDs==\u003e+号 选择左侧的appIds 添加AppId的名字和BundleID 点击继续，（在屏幕最下面） 3.选择选项点击继续 4.点击Register完成 ","date":"2019-12-01 21:57:40","objectID":"/ios%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E8%80%85%E8%AF%81%E4%B9%A6%E5%8F%8A%E6%B7%BB%E5%8A%A0appid/:4:0","tags":["IOS"],"title":"ios配置开发者证书及添加AppID","uri":"/ios%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E8%80%85%E8%AF%81%E4%B9%A6%E5%8F%8A%E6%B7%BB%E5%8A%A0appid/"},{"categories":["随笔"],"content":" 今天遇到个问题Can’t assign value ‘11.88’ (type System.Double) to type System.Single litjson不支持单精度浮点数float 只用修改JsonMapper.cs脚本就可以，一共修改两处 1.在JsonMapper.cs脚本里面增加如下代码 #region litjson support float modified by codingriver wangguoqing 2018-10-29 base_exporters_table[typeof(float)] = delegate (object obj, JsonWriter writer) { writer.Write((float)obj); }; #endregion 增加到如下位置： 2.在JsonMapper.cs脚本里面增加如下代码 #region litjson support float modified by codingriver 2018-10-29 importer = delegate (object input) { return Convert.ToSingle((double)input); }; RegisterImporter(base_importers_table, typeof(double), typeof(float), importer); #endregion 增加后是这样的 3.最后贴上修改后的JsonMapper.cs代码： #region Header /** * JsonMapper.cs * JSON to .Net object and object to JSON conversions. * * The authors disclaim copyright to this source code. For more details, see * the COPYING file included with this distribution. **/ #endregion using System; using System.Collections; using System.Collections.Generic; using System.Globalization; using System.IO; using System.Reflection; using ILRuntime.Runtime.Intepreter; using ILRuntime.Runtime.Stack; using ILRuntime.CLR.Method; using ILRuntime.CLR.Utils; namespace LitJson { internal struct PropertyMetadata { public MemberInfo Info; public bool IsField; public Type Type; } internal struct ArrayMetadata { private Type element_type; private bool is_array; private bool is_list; public Type ElementType { get { if (element_type == null) return typeof (JsonData); return element_type; } set { element_type = value; } } public bool IsArray { get { return is_array; } set { is_array = value; } } public bool IsList { get { return is_list; } set { is_list = value; } } } internal struct ObjectMetadata { private Type element_type; private bool is_dictionary; private IDictionary\u003cstring, PropertyMetadata\u003e properties; public Type ElementType { get { if (element_type == null) return typeof (JsonData); return element_type; } set { element_type = value; } } public bool IsDictionary { get { return is_dictionary; } set { is_dictionary = value; } } public IDictionary\u003cstring, PropertyMetadata\u003e Properties { get { return properties; } set { properties = value; } } } internal delegate void ExporterFunc (object obj, JsonWriter writer); public delegate void ExporterFunc\u003cT\u003e (T obj, JsonWriter writer); internal delegate object ImporterFunc (object input); public delegate TValue ImporterFunc\u003cTJson, TValue\u003e (TJson input); public delegate IJsonWrapper WrapperFactory (); public class JsonMapper { #region Fields private static int max_nesting_depth; private static IFormatProvider datetime_format; private static IDictionary\u003cType, ExporterFunc\u003e base_exporters_table; private static IDictionary\u003cType, ExporterFunc\u003e custom_exporters_table; private static IDictionary\u003cType, IDictionary\u003cType, ImporterFunc\u003e\u003e base_importers_table; private static IDictionary\u003cType, IDictionary\u003cType, ImporterFunc\u003e\u003e custom_importers_table; private static IDictionary\u003cType, ArrayMetadata\u003e array_metadata; private static readonly object array_metadata_lock = new Object (); private static IDictionary\u003cType, IDictionary\u003cType, MethodInfo\u003e\u003e conv_ops; private static readonly object conv_ops_lock = new Object (); private static IDictionary\u003cType, ObjectMetadata\u003e object_metadata; private static readonly object object_metadata_lock = new Object (); private static IDictionary\u003cType, IList\u003cPropertyMetadata\u003e\u003e type_properties; private static readonly object type_properties_lock = new Object (); private static JsonWriter static_writer; private static readonly object static_writer_lock = new Object (); #endregion #region Constructors static JsonMapper () { max_nesting_depth = 100; array_metadata = new Dictionary\u003cType, ArrayMetadata\u003e (); conv_ops = new Dictionary\u003cType, IDictionary\u003cType, MethodInfo\u003e\u003e (); object_metadata = new Dictionary\u003cType, ObjectMetadata\u003e (); type_properties = new Dictionary\u003cType, IList\u003cPropertyMetadata\u003e\u003e (); static_writer = new JsonWriter (); datetime_format = DateTimeFormatInfo.InvariantInfo; base_exporter","date":"2019-12-01 21:57:40","objectID":"/json%E7%9A%84float%E5%8D%95%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%94%AF%E6%8C%81/:0:0","tags":[""],"title":"Json的float单精度浮点数类型支持Can't assign value '11.88' (type System.Double) to type System.Single","uri":"/json%E7%9A%84float%E5%8D%95%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%94%AF%E6%8C%81/"},{"categories":["随笔"],"content":" linux gcc版本如何升级到gcc4.8.2 亲测 安装版本没有问题，验证版本gcc -v时不行，重新打开一个终端是对的了，我的是从4.4.7升级到4.8.5 ","date":"2019-12-01 21:57:40","objectID":"/linux-gcc%E7%89%88%E6%9C%AC%E5%A6%82%E4%BD%95%E5%8D%87%E7%BA%A7%E5%88%B0gcc4.8.2/:0:0","tags":[],"title":"linux gcc版本如何升级到gcc4.8.2","uri":"/linux-gcc%E7%89%88%E6%9C%AC%E5%A6%82%E4%BD%95%E5%8D%87%E7%BA%A7%E5%88%B0gcc4.8.2/"},{"categories":["lua"],"content":" 今天发现学过的知识不常用的都忘了差不多了，这里重新整理下，做下记录吧 0X01 闭包 在Lua中，闭包（closure）是由一个函数和该函数会访问到的非局部变量（或者是upvalue）组成的，其中非局部变量（non-local variable）是指不是在局部作用范围内定义的一个变量，但同时又不是一个全局变量，主要应用在嵌套函数和匿名函数里，因此若一个闭包没有会访问的非局部变量，那么它就是通常说的函数。也就是说，在Lua中，函数是闭包一种特殊情况。简而言之，闭包就是一个函数加一个upvalue。那么接下来看下upvalue是啥。 Lua使用结构体upvalue来实现闭包。外面的局部变量可以直接通过upvalue进行访问。upvalue最开始的时候指向栈中的一个变量，此时这个变量还在它的生存周期内。当变量离开作用域（译者注：就是函数返回后，变量的生存周期结束时），这个变量就从栈转移到了upvalue中。虽然这个变量存储在upvalue中，但是访问这个变量还是间接通过upvalue中的一个指针进行的（译者注：和在栈中时候的访问方式一样）。因此，变量位置的转移对任何试图读写这个变量的代码都是透明的。有别于这个变量在一个函数内部时候的行为，函数声明、访问这个变量，就是直接对栈的操作。 来自lua闭包全面解析 这篇有详细说明 lua的闭包之前自己也研究过这里做下记录吧，直接上代码 function test() local i=0; local f=function() i=i+1; return i end return f end --这里生成一个闭包f1，同时变量i也是闭包的一部分 local f1 = test() local a = f1() local b = f1() --这里再生成一个闭包f2，同时变量i也重新创建也是闭包的一部分，是和前面没有任何关系的 local f2=test() local c=f2() local e=f1() local d=f2() print(\"a:\"..a..\" b:\"..b..\" c:\"..c..\" d:\"..d..\" e:\"..e) 结果： 关于闭包的应用场景，这里没有过多的去注意，很尴尬，至今为止可能用过没有注意， 这里有个例子： 方法参数button，clickHandler，caller，data，isNotSound对于evtHandler方法是upvalue数据，属于 evtHandler闭包相关的，之前没注意 --isSound:true:没有声音。false：有声音 function UIComponent:RegisterButtonClickHandler(button, clickHandler, caller,data,isNotSound) --local obj = self:GetChildObj(childName); --if nil == obj then return end; if nil == button then return end; local evtHandler = function() if(isNotSound ~= true)then local musicstr = \"click\" audio.AudioMgr.GetInstance():PlayEffect(musicstr) --音效 end if nil == caller then clickHandler(); else if data then clickHandler(caller,button,data); else clickHandler(caller,button); end end -- audios.AudioManager.GetInstance():PlayEffectSound(11); end --button.onClick:AddListener(evtHandler); --button.colors.pressedColor = UnityEngine.Color.black self.m_Behaviour:AddClick(button,evtHandler, caller); return obj; end 再来一个例子 方法参数obj,params对于cb方法是upvalue数据，属于 cb闭包相关的，其实用的蛮多的 function utils.HttpUtil.FileUploadAsync(url,path,fileName,callback,obj,params) local maxRetryCount=2; local cb=function(content,errcode) if obj then callback(obj,content,errcode,params) else callback(content,errcode,params) end end CSHttpUtil.FileUploadAsync(url,path,fileName,cb,maxRetryCount) end 参考文章 深入理解Lua的闭包一：概念、应用和实现原理，关于应用还是不要参考这篇文章了，感觉不对，文章说的table.sort方法我觉得不是闭包 lua闭包全面解析 这篇有详细说明 0X02 and/or操作符 操作符这里有坑，之前以为和c语言类似，但今天发现不对 Lua中的逻辑运算符：与(and)、或(or)和非(not)，与其他语言的逻辑运算符功能一致，这里不做赘述。只说一点，==所有的逻辑运算符将false和nil视为假，其他任何东西视为真，0也视为真。== 直接上代码： --and 操作符 如果前面的参数为假则直接输出前面的值 local a = 0 and 3 local b = nil and 3 local m = false and 3 --nil和false不能直接拼接字符串，所以需要先tostring print( \"a:\"..a..\" b:\"..tostring( b)..\" m:\"..tostring( m)) --or 操作符 如果前面的参数为假则直接输出后面的值 local c = 0 or 5 local d = nil or 5 local e = false or 5 local f = nil or false print( \"c:\"..c..\" d:\"..d..\" e:\"..e..\" f:\"..tostring(f)) if 0 then print(\"0 is true !\") else print(\"0 is false\") end if nil then print(\"nil is true !\") else print(\"nil is false\") end if false then print(\"false is true !\") else print(\"false is false\") end 结果： 参考文章： Lua中and、or的一些特殊用法 0X03 多行字符串 一个字符串带换行的怎么处理这里说明下,使用[[ ]]来处理 local text=[[ abc def hello world ]] print(text) 0X04 lua递归函数 c语言允许函数内部调用函数本身，==但lua不允许函数内部调用函数本身== 递归调用需要先定义一个函数变量，这样在函数内部调用本身的时候后能访问到定义的函数变量地址 --一个阶乘的例子 --递归调用需要先定义一个函数变量，这样在函数内部调用本身的时候后能访问到定义的变量地址 local fact fact = function (n) if n == 0 then return 1 else return n*fact(n-1) end end --120 print(fact(5)) --错误的用法 local fact1 = function (n) if n == 0 then return 1 else return n*fact1(n-1) end end print(fact1(5)) 结果： ","date":"2019-12-01 21:57:40","objectID":"/lua%E9%97%AD%E5%8C%85%E5%92%8Cand-or%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%8F%8A%E5%85%B6%E5%AE%83%E7%9A%84%E8%AF%B4%E6%98%8E/:0:0","tags":["lua"],"title":"lua 闭包 和and/or 操作符及其它的说明","uri":"/lua%E9%97%AD%E5%8C%85%E5%92%8Cand-or%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%8F%8A%E5%85%B6%E5%AE%83%E7%9A%84%E8%AF%B4%E6%98%8E/"},{"categories":["随笔"],"content":"先安装vcredist_x86.exe文件 ","date":"2019-12-01 21:57:40","objectID":"/luaforwindows-%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99/:0:0","tags":[""],"title":"LuaForWindows-安装报错","uri":"/luaforwindows-%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99/"},{"categories":["lua"],"content":" 这里说明下unity中一般用C# 加lua的方式来支持代码的热更新，而在lua中一般封装类来实现业务 这里两年前研究过，没有做记录，今天提到了，发现忘干净了，今天借此机会复习下做下记录吧! 第二节的代码已经找不到出处了 ","date":"2019-12-01 21:57:40","objectID":"/lua%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:0:0","tags":["lua"],"title":"lua中类的实现","uri":"/lua%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["lua"],"content":"0X01 lua元表和元方法 元表设置： setmetatable(table, metatable) 元表读取： getmetatable(table) 元方法操作： metatable.元方法 = function (可接受参数) (函数体) end table访问的元方法 元方法： 算数运算符：__add(加法)[+]、__mul(乘法)[*]、__sub(减法)[-]、__div(除法)[/]、__unm(相反数)[-]、__mod(取模)[%]、__pow(乘幂)[^]。 逻辑运算符：__eq(等于)[=]、__lt(小于)[\u003c]、__le(小于等于)[\u003c=]。 其他运算符：__concat(连接)[..]、__len(取长度)[#]。 其他元方法： __tostring：返回值(可接受参数：table) __call：函数调用(可接受参数：table, key) __metatable：保护元方法(字符串) __index：查找表索引(可接受参数：table, key) __newindex：添加新索引(可接受参数：table, key, value) 说明： __add 如果任何不是数字的值（包括不能转换为数字的字符串）做加法， Lua 就会尝试调用元方法。 首先、Lua 检查第一个操作数（即使它是合法的）， 如果这个操作数没有为 “__add” 事件定义元方法， Lua 就会接着检查第二个操作数。 一旦 Lua 找到了元方法， 它将把两个操作数作为参数传入元方法， 元方法的结果（调整为单个值）作为这个操作的结果。 如果找不到元方法，将抛出一个错误。(其它 算数运算符和逻辑运算符及其它运算符跟这个类似) __index 当我们访问一个表的不存在的域，返回结果为nil，这是正确的，但并不一定正确。实际上，这种访问触发lua解释器去查找__index元方法：如果不存在，返回结果为nil；如果存在则由__index 元方法返回结果。当我们想不通过调用__index 元方法来访问一个表，我们可以使用rawget函数。Rawget(t,i)的调用以raw access方式访问表。这种访问方式不会使你的代码变快（the overhead of a function call kills any gain you could have），但有些时候我们需要他，在后面我们将会看到。 __newindex __newindex元方法用来对表更新，__index则用来对表访问。当你给表的一个缺少的域赋值，解释器就会查找__newindex元方法：如果存在则调用这个函数而不进行赋值操作。像__index一样，如果元方法是一个表，解释器对指定的那个表，而不是原始的表进行赋值操作。另外，有一个raw函数可以绕过元方法：调用rawset(t,k,v)不掉用任何元方法对表t的k域赋值为v。__index和__newindex 元方法的混合使用提供了强大的结构：从只读表到面向对象编程的带有继承默认值的表。 参考文章 Lua 元表与元方法 lua元表以及元方法 ","date":"2019-12-01 21:57:40","objectID":"/lua%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:1:0","tags":["lua"],"title":"lua中类的实现","uri":"/lua%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["lua"],"content":"0X02 lua类的实现 lua类的实现直接上类的实现的代码,注释加好了,文件名 class.lua --class.lua local _class = { } function class(super) -- 一个类的构建，这里构建的是类本身，ctor是构造函数，super是父类，这里继承只允许一个父类 local class_type = { ctor = false, super = super } --vtbl是当前类中所有域存放的地方 local vtbl = { } _class[class_type] = vtbl --_class[super]这里返回的是super 本身作为class_type 对应的vtbl --父类的vtbl vtbl.super = _class[super] class_type.superclass = _class[super] --设置class_type类本身的元方法，这里操作的是vtbl，并没有修改class_type本身（查找域和添加域都是操作的vtbl，class_type只是简单的原型） setmetatable(class_type, { __newindex = function(t, k, v) vtbl[k] = v end, __index = function(t, k) return vtbl[k] end, } ) if super then --关联父类子类的关系的查找域，vtbl关联父类的btbl查找域 setmetatable(vtbl, { __index = function(t, k) if k and _class[super] then local ret = _class[super][k] vtbl[k] = ret return ret else return nil end end } ) end class_type.New = function(...) -- 一个类实例的构建 local obj = { class = class_type } -- 设置实例关联类的查找域vtbl setmetatable(obj, { __index = function(t, k) return _class[class_type][k] end } ) --类和所有父类的ctor构造函数收集，第一个当前类的ctor，第二个父类的ctor，第三个父类的父类的ctor，.... local inherit_list = { } local class_ptr = class_type while class_ptr do if class_ptr.ctor then table.insert(inherit_list, class_ptr) end class_ptr = class_ptr.super end local inherit_length = #inherit_list --调用所有构造函数，从最上层的父类ctor开始知道当前类的ctor if inherit_length \u003e 0 then for i = inherit_length, 1, -1 do inherit_list[i].ctor(obj, ...) end end obj.super = inherit_list[2]; if detectMemoryLeak then registerToWeakTable(obj, debug.traceback(\"obj lua stack:\")); end obj.class = class_type return obj end class_type.is = function(self_ptr, compare_class) if not compare_class or not self_ptr then return false end local raw_class = self_ptr.class while raw_class do if raw_class == compare_class then return true end raw_class = raw_class.super end return false end return class_type end --测试代码 function printclass(class_type) local s=\"{\" for k,v in pairs(class_type)do s=s..tostring(k)..\":\"..tostring(v)..\",\" end s=s..\"}\"..tostring(class_type) print(\"class_type::\"..s); s=\"{\" local vtbl=_class[class_type] for k,v in pairs(vtbl)do s=s..tostring(k)..\":\"..tostring(v)..\",\" end s=s..\"}\"..tostring(vtbl) print(\"vtbl::\"..s); end 这里说下，类的实现由两种，一种是纯copy所有的域，还有一种是元表访问，只有修改时才会在当前类真的添加父类的键，而不是修改父类的，这里用的是元表访问 下面来做测试代码，文件名字test.lua，需要把class.lua和test.lua放在同一个目录下，require文件需要 require\"class\" --转table成为字符串 log=function(t) local s=\"{\" for k,v in pairs(t)do s=s..tostring(k)..\":\"..tostring(v)..\",\" end s=s..\"}\" return s; end --定义一个类A A=class() --定义一个静态变量 A.static=10 function A:ctor() self.a=3; print(\"---A:ctor----\") end function A:test() print(\"---A:test----a:\"..self.a) end --定义一个类B,继承A B=class(A) function B:ctor() self.b=5; print(\"---B:ctor----\") end function B:test() print(\"---B:test----a:\"..self.a) end --构建实例 local a= A.New() a:test(); local b=B.New() b:test(); --打印 printclass(A) print(\"a::\"..log(a)) print(\"------------------------------------------------------------\") printclass(B) print(\"b::\"..log(b)) print(\"--------------------------modify static of B----------------------------------\") B.static =20; printclass(B) print(\"b::\"..log(b)) print(\"--------------------------modify static of b----------------------------------\") b.static =30; printclass(B) print(\"b::\"..log(b)) 结果：注意标红的a，是因为B实例化时执行了父类的ctor构造函数产生的，static:20和static:30,是因为 B.static=20,b.static=30代码通过__newindex实现的 ","date":"2019-12-01 21:57:40","objectID":"/lua%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:2:0","tags":["lua"],"title":"lua中类的实现","uri":"/lua%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["lua"],"content":"0X03 lua简单的类的实现 lua类的实现，==简单版本== --简单的类的实现 function class(super) local class_type={ctor=false,super=super} if super then setmetatable(class_type,{ __index = function(t,k) if k then return super[k]; else return nil end end }) end class_type.New = function(...) local obj={class = class_type} setmetatable(obj,{ __index = function(t,k) if k then return class_type[k]; else return nil end end }) local ctor_list={} local class_ptr = class_type while class_ptr do if class_ptr.ctor then table.insert(ctor_list, class_ptr) end class_ptr = class_ptr.super end for i=#ctor_list,1,-1 do ctor_list[i].ctor(obj,...) end return obj; end return class_type end --测试代码 function printclass(class_type) local s=\"{\" for k,v in pairs(class_type)do s=s..tostring(k)..\":\"..tostring(v)..\",\" end s=s..\"}\"..tostring(class_type) print(\"class_type::\"..s); end 根据第二节的测试代码test.lua执行的结果： ","date":"2019-12-01 21:57:40","objectID":"/lua%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/:3:0","tags":["lua"],"title":"lua中类的实现","uri":"/lua%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["随笔"],"content":"在显示Finder中显示用户目录 打开Finder，然后选择偏好设置 设置完成后，打开finder 在边栏看到用户目录,我的用户名为codingriver，这个文件夹是用户名的文件夹 点击用户目录，然后按Command+J打开 ","date":"2019-12-01 21:57:40","objectID":"/mac%E8%AE%BE%E7%BD%AElibrary-%E6%98%BE%E7%A4%BA/:0:1","tags":[""],"title":"mac 设置 ~/Library 显示","uri":"/mac%E8%AE%BE%E7%BD%AElibrary-%E6%98%BE%E7%A4%BA/"},{"categories":["随笔"],"content":"1.需要两个ios手机（一个测试机，一个提供网络热点的） 2.需要mac一台，可以没有以太网，可以不联网 共享热点:使mac可以上网 1.使用usb连接mac电脑 2.打开ios设置–\u003e个人热点–\u003e打开，会提示仅蓝牙和USB上网（没有提示则把wifi关闭再试，选择后也可以把wifi打开使用wifi给mac上网） 3.测试mac 上网，打开浏览器随便打开个网站，确认网络可用 创建IPV6 wifi热点 点击桌面左上角小苹果—\u003e系统偏好设置—-\u003e共享（要按住option键） **共享一下来源的连接：**这里使用USB(如果有以太网就选择以太网) **共享给电脑：**选择Wi-Fi **创建NAT64网络选项：**一定要勾上，就靠它来共享NAT64网络 wifi选项—频段 —- 我这里选择的11 勾上互联网共享就可以了 打开共享如果不按住option，则打开的共享面板没有【创建NAT64网络选项】 手机的dns就是ipv6的地址，就ok了 ","date":"2019-12-01 21:57:40","objectID":"/mac-%E5%88%9B%E5%BB%BA-ipv6-wifi%E7%83%AD%E7%82%B9%E4%B8%8D%E7%94%A8%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%8E%A5%E5%8F%A3/:0:0","tags":["IOS","Ipv6"],"title":"MAC-创建-IPv6-WIFI热点，不用以太网接口","uri":"/mac-%E5%88%9B%E5%BB%BA-ipv6-wifi%E7%83%AD%E7%82%B9%E4%B8%8D%E7%94%A8%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%8E%A5%E5%8F%A3/"},{"categories":["随笔"],"content":" 安装sourcetree 关闭sourcetree 命令终端输入defaults write com.torusknot.SourceTreeNotMAS completedWelcomeWizardVersion 3 打开sourcetree即可跳过登录 转自 https://blog.csdn.net/qq_32890891/article/details/89216954 ","date":"2019-12-01 21:57:40","objectID":"/sourcetree-mac%E5%AE%89%E8%A3%85%E8%B7%B3%E8%BF%87%E6%B3%A8%E5%86%8C%E7%99%BB%E9%99%86%E5%92%8C%E9%80%89%E6%8B%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:0","tags":[""],"title":"Sourcetree Mac安装跳过注册登陆和选择服务器","uri":"/sourcetree-mac%E5%AE%89%E8%A3%85%E8%B7%B3%E8%BF%87%E6%B3%A8%E5%86%8C%E7%99%BB%E9%99%86%E5%92%8C%E9%80%89%E6%8B%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["随笔"],"content":" sourcetree使用，给策划同学和美术同学准备的文档，只有基础功能介绍 版本：2.5.5.0（windows） ","date":"2019-12-01 21:57:40","objectID":"/sourcetree%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:0:0","tags":[""],"title":"Sourcetree基本使用教程","uri":"/sourcetree%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["随笔"],"content":"0X01 Clone项目 打开sourcetree后是这样的，如果有项目了先点击+号 1.点击Clone 2.配置克隆项目的信息 位置1处添加远程项目git路径。 程序：http://10.113.4.228:10010/r/Client.git 美术：http://10.113.4.228:10010/r/Art.git 策划：http://10.113.4.228:10010/r/Document.git 位置2处添加需要将项目保存的本地文件夹。 点击高级选项 检出分支处，根据项目情况选择 我们这里策划和美术项目不需要修改，用默认的master分支；程序项目选择develop分支 然后点击克隆 3.下载项目中 4.提示框配置邮件信息 这里邮件只是为了显示日志用，不会真的给你发邮件 5.完成 ","date":"2019-12-01 21:57:40","objectID":"/sourcetree%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:0:1","tags":[""],"title":"Sourcetree基本使用教程","uri":"/sourcetree%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["随笔"],"content":"0X02 提交和更新项目 1.更新项目，选择拉取 这里更新是整个项目更新，和svn不一样，不区分目录更新，用svn习惯的同学需要注意下 2.提交修改 第一步先暂存要提交的内容 第二步提交暂存的内容，备注提交日志，需要先勾选推送，然后点击提交，就完成了 ==注意每次提交前尽量先更新下== ","date":"2019-12-01 21:57:40","objectID":"/sourcetree%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:0:2","tags":[""],"title":"Sourcetree基本使用教程","uri":"/sourcetree%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["随笔"],"content":"0X03 解决冲突 冲突的原因是有同学修改一个文件并且提交了，你没有更新的情况下也修改了这个文件，这时候更新时提示冲突 第一种情况，提交后推送失败，更新后合并冲突 1.更新失败，提示有冲突文件 这里是cs文件 2.将冲突的文件先提交上去，会提示推送失败，不管它 3.再次拉取 4.拉取后有冲突 感叹号图标表示冲突 5.解决冲突 根据自己情况选择解决方案，选中冲突文件右键 解决冲突后，感叹号没有了 然后提交，不要做其他操作，先提交，日志是默认冲突日志，不用管（如果有其它文件需要提交，也不要管，先把冲突文件提交上去，再重新提交需要提交的文件） 解决冲突后有可能出现orig后缀文件，直接删除就行，冲突备份用的 如果还提示推送，点击推送按钮就好了 第二种情况，本地修改没提交，更新提示冲突 1.更新失败提示 2.解决方案 将自己修改的文件备份，然后黄色或者灰色图标的丢弃修改，问号图标的移除 更新完成后再覆盖，然后提交 这里注意下，文件冲突不管是不是同一行都会提示冲突，没有自动合并，应该和冲突比对工具有关，这里不做说明了，svn如果修改不是同一行自动合并 git不会去管理文件夹，unity的meta文件让这个问题很蛋疼 ","date":"2019-12-01 21:57:40","objectID":"/sourcetree%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:0:3","tags":[""],"title":"Sourcetree基本使用教程","uri":"/sourcetree%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["随笔"],"content":"0X04 基本知识 1.当前项目所在文件夹目录 点击浏览器会打开项目所在的文件夹 2.文件图标说明 新添加文件 如果删除这个文件选移除 修改的文件 放弃本地修改选择丢弃 删除的文件 放弃删除，选择丢弃，就恢复了 还有一种图标是更换目录 如果还不明白或者想要更详细的资料，这里推荐几篇文章 iOS-SourceTree的使用 (解决冲突参考) SourceTree图文示例教程（Win版） SourceTree使用方法 ","date":"2019-12-01 21:57:40","objectID":"/sourcetree%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:0:4","tags":[""],"title":"Sourcetree基本使用教程","uri":"/sourcetree%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["随笔"],"content":" 给美术同学和策划同学提供安装git管理软件教程 ","date":"2019-12-01 21:57:40","objectID":"/sourcetree%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8Bwindows/:0:0","tags":[""],"title":"Sourcetree安装教程（windows）","uri":"/sourcetree%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8Bwindows/"},{"categories":["随笔"],"content":"0X01 安装Git 这里安装的git版本是2.15.0 1.双击git 2.点击运行 3.点击Next 4.点击Next，其他选项是默认就行 5.点击Next，其他选项是默认就行 6.点击Next，其他选项是默认就行 7.点击Next，其他选项是默认就行 8.点击Next，其他选项是默认就行 9.点击Next，其他选项是默认就行 10.点击Next，其他选项是默认就行 11.点击Next，其他选项是默认就行 12.点击Finish，其他选项是默认就行 到这里git软件安装完成。 这一步是为了防止sourcetree安装后要下载git软件 ","date":"2019-12-01 21:57:40","objectID":"/sourcetree%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8Bwindows/:0:1","tags":[""],"title":"Sourcetree安装教程（windows）","uri":"/sourcetree%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8Bwindows/"},{"categories":["随笔"],"content":"0X02 安装Sourcetree ==这里安装的版本是2.5.5，不需要翻墙，不需要登陆账户== 1.双击sourceTree 2.点击运行 3.勾选我同意，点击下一步 4.点击关闭 这里不点击下一步，下一步需要登陆账户，这里绕过账户登陆 5.破解账户登陆 ==复制accounts.json文件到%LocalAppData%\\Atlassian\\SourceTree\\ 目录下,没有则新建== 在文件管理器中打开目录%LocalAppData%\\Atlassian\\SourceTree\\ 点击回车 将accounts.json文件拷贝到该目录下 在文章结尾附上acccounts.json文件 6.双击Sourcetree启动 7.选择我不想使用 8.安装Sourcetree完成 后面补充使用教程 这里附上accounts.json文件 [ { \"$id\": \"1\", \"$type\": \"SourceTree.Api.Host.Identity.Model.IdentityAccount, SourceTree.Api.Host.Identity\", \"Authenticate\": true, \"HostInstance\": { \"$id\": \"2\", \"$type\": \"SourceTree.Host.Atlassianaccount.AtlassianAccountInstance, SourceTree.Host.AtlassianAccount\", \"Host\": { \"$id\": \"3\", \"$type\": \"SourceTree.Host.Atlassianaccount.AtlassianAccountHost, SourceTree.Host.AtlassianAccount\", \"Id\": \"atlassian account\" }, \"BaseUrl\": \"https://id.atlassian.com/\" }, \"Credentials\": { \"$id\": \"4\", \"$type\": \"SourceTree.Model.BasicAuthCredentials, SourceTree.Api.Account\", \"Username\": \"\", \"Email\": null }, \"IsDefault\": false } ] 参考文章 SourceTree 破解登录 ","date":"2019-12-01 21:57:40","objectID":"/sourcetree%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8Bwindows/:0:2","tags":[""],"title":"Sourcetree安装教程（windows）","uri":"/sourcetree%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8Bwindows/"},{"categories":["随笔"],"content":" 文章：SVN trunk(主线) branch(分支) tag(标记) 用法详解和详细操作步骤 这里做一些补充: #####1.从trunk创建一个branch分支 在svn上创建branchs目录 在trunk上的Majiang上右键 To path填写分支的名字在branchs下 点击ok就创建分支完成，Tag版本也是这么操作，把branchs换成Tag就可以了 #####2.从trunk合并到branch 从分支Cache上右键 这里选择all revisions 是将从分支建立的时候到主干现在所有的修改都合并到分支上 这里选择specific range 是将选择指定的Revision号的提交合并到分支上 Test Merge 选项表示测试Merge合并，可以提前测试检查合并中是否有冲突 合并完成后所有的修改都在本地了，解决冲突然后提交就可以了，如果合并要放弃则执行 Clean Up 操作 #####3.从branch合并到trunk 同上，这里略过了 ","date":"2019-12-01 21:57:40","objectID":"/svn-trunk%E4%B8%BB%E7%BA%BF-branch%E5%88%86%E6%94%AF-%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%88%E5%B9%B6%E6%95%99%E7%A8%8B/:0:0","tags":["SVN"],"title":"SVN-trunk(主线)-branch(分支)-创建和合并教程","uri":"/svn-trunk%E4%B8%BB%E7%BA%BF-branch%E5%88%86%E6%94%AF-%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%88%E5%B9%B6%E6%95%99%E7%A8%8B/"},{"categories":["随笔"],"content":"在Global ignore pattern参数中把*.a和*.so删除就可以了 ","date":"2019-12-01 21:57:40","objectID":"/svn%E6%97%A0%E6%B3%95%E6%8F%90%E4%BA%A4--a%E5%92%8C--so%E6%96%87%E4%BB%B6/:0:0","tags":["SVN"],"title":"SVN无法提交--a和--so文件","uri":"/svn%E6%97%A0%E6%B3%95%E6%8F%90%E4%BA%A4--a%E5%92%8C--so%E6%96%87%E4%BB%B6/"},{"categories":["随笔"],"content":" https://www.cnblogs.com/ddrsql/p/5909683.html ","date":"2019-12-01 21:57:40","objectID":"/svn%E7%AE%A1%E7%90%86/:0:0","tags":["SVN"],"title":"svn管理","uri":"/svn%E7%AE%A1%E7%90%86/"},{"categories":["随笔"],"content":" tar (child): lbzip2: Cannot exec: No such file or directory 解决方法 ","date":"2019-12-01 21:57:40","objectID":"/tarchild-lbzip2-cannotexec%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/:0:0","tags":[""],"title":"tar (child): lbzip2: Cannot exec: No such file or directory 解决方法","uri":"/tarchild-lbzip2-cannotexec%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"categories":["Unity"],"content":"置灰的关键代码： //gray color.rgb = dot(color.rgb, fixed3(0.222, 0.707, 0.071)); //0.299, 0.587, 0.114 //half gray = dot(color.rgb, fixed3(0.299, 0.0587, 0.114)); //color.rgb = half3(gray, gray, gray); 这里是从官网下载对应内置shader，然后修改UI-Default 上完整的shader代码： // Unity built-in shader source. Copyright (c) 2016 Unity Technologies. MIT license (see license.txt) Shader \"Custom/UI-Gray\" { Properties { [PerRendererData] _MainTex (\"Sprite Texture\", 2D) = \"white\" {} _Color (\"Tint\", Color) = (1,1,1,1) _StencilComp (\"Stencil Comparison\", Float) = 8 _Stencil (\"Stencil ID\", Float) = 0 _StencilOp (\"Stencil Operation\", Float) = 0 _StencilWriteMask (\"Stencil Write Mask\", Float) = 255 _StencilReadMask (\"Stencil Read Mask\", Float) = 255 _ColorMask (\"Color Mask\", Float) = 15 [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip (\"Use Alpha Clip\", Float) = 0 } SubShader { Tags { \"Queue\"=\"Transparent\" \"IgnoreProjector\"=\"True\" \"RenderType\"=\"Transparent\" \"PreviewType\"=\"Plane\" \"CanUseSpriteAtlas\"=\"True\" } Stencil { Ref [_Stencil] Comp [_StencilComp] Pass [_StencilOp] ReadMask [_StencilReadMask] WriteMask [_StencilWriteMask] } Cull Off Lighting Off ZWrite Off ZTest [unity_GUIZTestMode] Blend SrcAlpha OneMinusSrcAlpha ColorMask [_ColorMask] Pass { Name \"Default\" CGPROGRAM #pragma vertex vert #pragma fragment frag #pragma target 2.0 #include \"UnityCG.cginc\" #include \"UnityUI.cginc\" #pragma multi_compile __ UNITY_UI_CLIP_RECT #pragma multi_compile __ UNITY_UI_ALPHACLIP struct appdata_t { float4 vertex : POSITION; float4 color : COLOR; float2 texcoord : TEXCOORD0; UNITY_VERTEX_INPUT_INSTANCE_ID }; struct v2f { float4 vertex : SV_POSITION; fixed4 color : COLOR; float2 texcoord : TEXCOORD0; float4 worldPosition : TEXCOORD1; UNITY_VERTEX_OUTPUT_STEREO }; sampler2D _MainTex; fixed4 _Color; fixed4 _TextureSampleAdd; float4 _ClipRect; float4 _MainTex_ST; v2f vert(appdata_t v) { v2f OUT; UNITY_SETUP_INSTANCE_ID(v); UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(OUT); OUT.worldPosition = v.vertex; OUT.vertex = UnityObjectToClipPos(OUT.worldPosition); OUT.texcoord = TRANSFORM_TEX(v.texcoord, _MainTex); OUT.color = v.color * _Color; return OUT; } fixed4 frag(v2f IN) : SV_Target { half4 color = (tex2D(_MainTex, IN.texcoord) + _TextureSampleAdd) * IN.color; #ifdef UNITY_UI_CLIP_RECT color.a *= UnityGet2DClipping(IN.worldPosition.xy, _ClipRect); #endif #ifdef UNITY_UI_ALPHACLIP clip (color.a - 0.001); #endif //gray color.rgb = dot(color.rgb, fixed3(0.222, 0.707, 0.071)); //0.299, 0.587, 0.114 //half gray = dot(color.rgb, fixed3(0.299, 0.0587, 0.114)); //color.rgb = half3(gray, gray, gray); return color; } ENDCG } } } 使用代码 //===================================================== // - FileName: UIGray.cs // - Created: codingriver //====================================================== using UnityEngine; using UnityEngine.UI; /// \u003csummary\u003e /// 图片置灰 /// \u003c/summary\u003e public static class UIGray { private static Material grayMat; /// \u003csummary\u003e /// 创建置灰材质球 /// \u003c/summary\u003e /// \u003creturns\u003e\u003c/returns\u003e private static Material GetGrayMat() { if(grayMat==null) { Shader shader = Shader.Find(\"Custom/UI-Gray\"); if(shader==null) { Debug.Log(\"null\"); return null; } Material mat = new Material(shader); grayMat = mat; } return grayMat; } /// \u003csummary\u003e /// 图片置灰 /// \u003c/summary\u003e /// \u003cparam name=\"img\"\u003e\u003c/param\u003e public static void SetUIGray(Image img) { img.material = GetGrayMat(); img.SetMaterialDirty(); } /// \u003csummary\u003e /// 图片回复 /// \u003c/summary\u003e /// \u003cparam name=\"img\"\u003e\u003c/param\u003e public static void Recovery(Image img) { img.material = null; } } 效果： ","date":"2019-12-01 21:57:40","objectID":"/ugui-image%E5%9B%BE%E7%89%87%E7%BD%AE%E7%81%B0/:0:0","tags":["Unity"],"title":"UGUI Image 图片置灰","uri":"/ugui-image%E5%9B%BE%E7%89%87%E7%BD%AE%E7%81%B0/"},{"categories":["Unity"],"content":" 首先使用工具Bitmap Font Generator生成.fnt和图集贴图,教程参考Unity3D-使用Bitmap Font Generator自定义字体 这里主要介绍根据Text格式的.fnt和贴图 在unity中自定义字体 生成字体教程 上代码（Unity版本5.6.0f3） 生成字体文件后必须重启unity才能生效，否则字体文件不能正确加载（unity bug或者我没找到方法刷新unity，知道的请指教） using UnityEngine; using UnityEditor; using System.Collections.Generic; public class BMFontEditor : EditorWindow { public TextAsset fontPosTbl; public Texture fontTexture; public Vector2 scrollPos; struct ChrRect { public int id; public int x; public int y; public int w; public int h; public int xofs; public int yofs; public int index; public float uvX; public float uvY; public float uvW; public float uvH; public float vertX; public float vertY; public float vertW; public float vertH; public float width; } // add menu [MenuItem(\"Tools/BMFontTools\")] static void Init() { EditorWindow.GetWindow(typeof(BMFontEditor)); } // layout window void OnGUI() { //EditorGUILayout.BeginScrollView(scrollPos); EditorGUILayout.BeginVertical(); // use .fnt(.txt) fontTexture = (Texture)EditorGUILayout.ObjectField(\"Font Texture\", fontTexture, typeof(Texture), false); EditorGUILayout.Space(); EditorGUILayout.LabelField(\"Use BMFont fnt File\", EditorStyles.boldLabel); EditorGUILayout.LabelField(\"(must Font Descriptor select Text)\", EditorStyles.boldLabel); fontPosTbl = (TextAsset)EditorGUILayout.ObjectField(\"BMFont fnt (.fnt)\", fontPosTbl, typeof(TextAsset), false); if (GUILayout.Button(\"Create(创建后必须重启生效)\")) { if (fontTexture == null) this.ShowNotification(new GUIContent(\"No Font Texture selected\")); else if (fontPosTbl == null) this.ShowNotification(new GUIContent(\"No Font Position Table file selected\")); else { CalcChrRect(fontPosTbl, fontTexture); } } EditorGUILayout.LabelField(\"(Must Restart unity valid!)\", EditorStyles.whiteBoldLabel); EditorGUILayout.LabelField(\"*********************************\", EditorStyles.largeLabel); EditorGUILayout.EndVertical(); //EditorGUILayout.EndScrollView(); } void OnInspectorUpdate() { this.Repaint(); } void CalcChrRect(TextAsset posTbl, Texture tex) { string fileName = AssetDatabase.GetAssetPath(fontPosTbl); string texName = AssetDatabase.GetAssetPath(tex); string fontName = System.IO.Path.GetFileNameWithoutExtension(fileName); string fontPath = fileName.Replace(\".fnt\", \".fontsettings\"); string matPath = fileName.Replace(\".fnt\", \".mat\"); float imgw = (float)tex.width; float imgh = (float)tex.height; string txt = posTbl.text; List\u003cChrRect\u003e tblList = new List\u003cChrRect\u003e(); foreach (string line in txt.Split('\\n')) { if (line.IndexOf(\"char id=\") == 0) { ChrRect d = GetChrRect(line, imgw, imgh); tblList.Add(d); } } if(tblList.Count==0) { new GUIContent(\"Failed\"); return; } ChrRect[] tbls = tblList.ToArray(); Font font = new Font(); font.name = fontName; SetCharacterInfo(tbls, font); Material mat = new Material(Shader.Find(\"Unlit/Transparent\")); mat.mainTexture = tex; mat.name = fontName; font.material = mat; Debug.Log(System.IO.Path.GetFileNameWithoutExtension(fileName)); Debug.Log(fileName); AssetDatabase.CreateAsset(mat, matPath); AssetDatabase.CreateAsset(font, fontPath); AssetDatabase.SaveAssets(); this.ShowNotification(new GUIContent(\"Complete\")); AssetDatabase.Refresh(ImportAssetOptions.ForceUpdate); } // over write custom font by new CharacterInfo void SetCharacterInfo(ChrRect[] tbls, Font fontObj) { CharacterInfo[] nci = new CharacterInfo[tbls.Length]; for (int i = 0; i \u003c tbls.Length; i++) { nci[i].index = tbls[i].index; nci[i].advance = (int)tbls[i].width; nci[i].uv.x = tbls[i].uvX; nci[i].uv.y = tbls[i].uvY; nci[i].uv.width = tbls[i].uvW; nci[i].uv.height = tbls[i].uvH; nci[i].vert.x = tbls[i].vertX; nci[i].vert.y = tbls[i].vertY; nci[i].vert.width = tbls[i].vertW; nci[i].vert.height = tbls[i].vertH; } fontObj.characterInfo = nci; } // get font table one line. ChrRect GetChrRect(string line, float imgw, float imgh) { ChrRect d = new ChrRect(); foreach (string s in line.Split(' ')) { if (s.IndexOf(\"id=\") \u003e= 0) d.id = GetParamInt(s, \"id=\"); else if (s.IndexOf(\"x=\") \u003e= 0) d.x = GetParamInt(s, \"x=\"); else i","date":"2019-12-01 21:57:40","objectID":"/ugui%E4%B8%ADcustomfontbmfont%E5%AD%97%E4%BD%93%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%88%B6%E4%BD%9C/:0:0","tags":["UGUI"],"title":"UGUI中CustomFont（BMFont）字体使用与制作","uri":"/ugui%E4%B8%ADcustomfontbmfont%E5%AD%97%E4%BD%93%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%88%B6%E4%BD%9C/"},{"categories":["Unity"],"content":" 官方说明：https://docs.unity3d.com/Manual/SupportedEvents.html 事件说明： IPointerEnterHandler - OnPointerEnter - 当指针进入对象时调用 IPointerExitHandler - OnPointerExit - 当指针退出对象时调用 IPointerDownHandler - OnPointerDown - 在对象上按下指针时调用 IPointerUpHandler - OnPointerUp - 释放指针时调用（在指针点击的GameObject上调用） IPointerClickHandler - OnPointerClick - 在同一对象上按下并释放指针时调用 IInitializePotentialDragHandler - OnInitializePotentialDrag - 在找到拖动目标时调用，可用于初始化值 IBeginDragHandler - OnBeginDrag - 在拖动即将开始时调用拖动对象 IDragHandler - OnDrag - 发生拖动时在拖动对象上调用 IEndDragHandler - OnEndDrag - 拖动完成时在拖动对象上调用 IDropHandler - OnDrop - 在拖动完成的对象上调用 IScrollHandler - OnScroll - 当鼠标滚轮滚动时调用 IUpdateSelectedHandler - OnUpdateSelected - 在每个tick上调用所选对象 ISelectHandler - OnSelect - 当对象成为选定对象时调用 IDeselectHandler - OnDeselect - 在选定对象上调用将被取消选中 IMoveHandler - OnMove - 在移动事件发生时调用（左，右，上，下等） ISubmitHandler - OnSubmit - 按下提交按钮时调用 ICancelHandler - OnCancel - 按下取消按钮时调用 测试脚本 //===================================================== // - FileName: OnInputEvent.cs // - Created: codingriver //====================================================== using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; using UnityEngine.EventSystems; using UnityEngine.Events; //https://docs.unity3d.com/Manual/SupportedEvents.html //firstSelectedGameObject：这个值可以在面板设置，如果你需要游戏在启动的时候自动选中某个对象，需要鼠标的那一下点击。 //currentSelectedGameObject：当前选中的对象，你可以通过这个值判断当前是否鼠标点击在对象上，因为也许你有拖动摄像机的功能，但是你又不喜欢点击某些对象的时候这个功能又被响应，所以通过这个变量判断是一个很好的办法。 // IsPointerOverGameObject：当前鼠标是否在事件系统可以检测的对象上。 //SetSelectedGameObject：这个接口也许你会忽略，但是它很棒。因为你点击场景对象的时候，如果不调用这个接口，你的对象是收不到OnSelect事件的，currentSelectedGameObject的值也不会被设置的，必须在点击事件里调用这个接口设置选中对象！ //EventTrigger模拟 /// \u003csummary\u003e /// /// \u003c/summary\u003e public class OnInputEvent : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerDownHandler, IPointerUpHandler, IPointerClickHandler, IInitializePotentialDragHandler, IBeginDragHandler, IDragHandler, IEndDragHandler, IDropHandler, IScrollHandler, IUpdateSelectedHandler, ISelectHandler, IDeselectHandler, IMoveHandler, ISubmitHandler, ICancelHandler, IEventSystemHandler { // Use this for initialization void Start() { //test AddListener(); //test AddListenerClick(gameObject, OnClick); } // Update is called once per frame //void Update () { //} void Init() { } #region EventTrigger //public static void AddListener(GameObject obj, EventTriggerType type,XLua.LuaFunction func,XLua.LuaTable caller) public void AddListener() { var trigger = gameObject.AddComponent\u003cEventTrigger\u003e(); EventTrigger.Entry entry = new EventTrigger.Entry(); entry.eventID = EventTriggerType.PointerClick; entry.callback.AddListener(OnPointerClick); trigger.triggers.Add(entry); } /// \u003csummary\u003e /// 当鼠标按下并抬起 /// 在同一物体上按下并释放 /// \u003c/summary\u003e /// \u003cparam name=\"eventData\"\u003e\u003c/param\u003e private void OnPointerClick(BaseEventData eventData) { Debug.Log(\"OnPoinerClick:BaseEventData:::\"); } #endregion #region event button public static void AddListenerClick(GameObject obj, UnityAction action) { if (obj == null) { return; } Button btn = obj.GetComponent\u003cButton\u003e(); if (btn == null) { return; } btn.onClick.AddListener(action); } public static void OnClick() { Debug.Log(\"OnClick\"); } #endregion #region interface /// \u003csummary\u003e /// 当开始拖拽 /// \u003c/summary\u003e /// \u003cparam name=\"eventData\"\u003e\u003c/param\u003e public void OnBeginDrag(PointerEventData eventData) { Debug.Log(\"OnBeginDrag\"); } /// \u003csummary\u003e /// 当拖拽中 /// \u003c/summary\u003e /// \u003cparam name=\"eventData\"\u003e\u003c/param\u003e public void OnDrag(PointerEventData eventData) { Debug.Log(\"OnDrag\"); } /// \u003csummary\u003e /// 当放下 /// 拖拽结束(拖拽结束后的位置(即鼠标位置)如果有物体，则那个物体调用) /// 按下的ui和抬起的ui不相同时会被调用 /// \u003c/summary\u003e /// \u003cparam name=\"eventData\"\u003e\u003c/param\u003e public void OnDrop(PointerEventData eventData) { Debug.Log(\"OnDrop\"); } /// \u003csummary\u003e /// 当结束拖拽 /// \u003c/summary\u003e /// \u003cparam name=\"eventData\"\u003e\u003c/param\u003e public void OnEndDrag(PointerEventData eventData) { Debug.Log(\"OnEndDrag\"); } /// \u003csummary\u003e /// 拖拽时的初始化，跟IPointerDownHandler差不多，在按下时调用 /// \u003c/summary\u003e /// \u003cparam name=\"eventData\"\u003e\u003c/param\u003e public void OnInitializ","date":"2019-12-01 21:57:40","objectID":"/ugui%E4%BA%8B%E4%BB%B6%E4%BB%8B%E7%BB%8D/:0:0","tags":["Unity"],"title":"UGUI事件介绍","uri":"/ugui%E4%BA%8B%E4%BB%B6%E4%BB%8B%E7%BB%8D/"},{"categories":["Unity"],"content":"OnInutEvent.cs //===================================================== // - FileName: OnInputEvent.cs // - Description: // - Author: wangguoqing // - Email: wangguoqing@hehemj.com // - Created: #CreateTime# // - UserName: #AuthorName# // - (C) Copyright 2008 - 2015, hehehuyu,Inc. // - All Rights Reserved. //====================================================== using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; using UnityEngine.EventSystems; using UnityEngine.Events; //https://docs.unity3d.com/Manual/SupportedEvents.html //firstSelectedGameObject：这个值可以在面板设置，如果你需要游戏在启动的时候自动选中某个对象，需要鼠标的那一下点击。 //currentSelectedGameObject：当前选中的对象，你可以通过这个值判断当前是否鼠标点击在对象上，因为也许你有拖动摄像机的功能，但是你又不喜欢点击某些对象的时候这个功能又被响应，所以通过这个变量判断是一个很好的办法。 // IsPointerOverGameObject：当前鼠标是否在事件系统可以检测的对象上。 //SetSelectedGameObject：这个接口也许你会忽略，但是它很棒。因为你点击场景对象的时候，如果不调用这个接口，你的对象是收不到OnSelect事件的，currentSelectedGameObject的值也不会被设置的，必须在点击事件里调用这个接口设置选中对象！ //EventTrigger模拟 /// \u003csummary\u003e /// /// \u003c/summary\u003e public class OnInputEvent : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerDownHandler, IPointerUpHandler, IPointerClickHandler, IInitializePotentialDragHandler, IBeginDragHandler, IDragHandler, IEndDragHandler, IDropHandler, IScrollHandler, IUpdateSelectedHandler, ISelectHandler, IDeselectHandler, IMoveHandler, ISubmitHandler, ICancelHandler, IEventSystemHandler { // Use this for initialization void Start () { //test AddListener(); //test AddListenerClick(gameObject, OnClick); } // Update is called once per frame //void Update () { //} void Init() { } #region EventTrigger //public static void AddListener(GameObject obj, EventTriggerType type,XLua.LuaFunction func,XLua.LuaTable caller) public void AddListener() { var trigger= gameObject.AddComponent\u003cEventTrigger\u003e(); EventTrigger.Entry entry = new EventTrigger.Entry(); entry.eventID = EventTriggerType.PointerClick; entry.callback.AddListener(OnPointerClick); trigger.triggers.Add(entry); } /// \u003csummary\u003e /// 当鼠标按下并抬起 /// 在同一物体上按下并释放 /// \u003c/summary\u003e /// \u003cparam name=\"eventData\"\u003e\u003c/param\u003e private void OnPointerClick(BaseEventData eventData) { Dg.Log(\"OnPoinerClick:BaseEventData:::\"); } #endregion #region event button public static void AddListenerClick(GameObject obj,UnityAction action) { if(obj==null) { return; } Button btn = obj.GetComponent\u003cButton\u003e(); if(btn==null) { return; } btn.onClick.AddListener(action); } public static void OnClick() { Dg.Log(\"OnClick\"); } #endregion #region interface /// \u003csummary\u003e /// 当开始拖拽 /// \u003c/summary\u003e /// \u003cparam name=\"eventData\"\u003e\u003c/param\u003e public void OnBeginDrag(PointerEventData eventData) { Dg.Log(\"OnBeginDrag\"); } /// \u003csummary\u003e /// 当拖拽中 /// \u003c/summary\u003e /// \u003cparam name=\"eventData\"\u003e\u003c/param\u003e public void OnDrag(PointerEventData eventData) { Dg.Log(\"OnDrag\"); } /// \u003csummary\u003e /// 当放下 /// 拖拽结束(拖拽结束后的位置(即鼠标位置)如果有物体，则那个物体调用) /// 按下的ui和抬起的ui不相同时会被调用 /// \u003c/summary\u003e /// \u003cparam name=\"eventData\"\u003e\u003c/param\u003e public void OnDrop(PointerEventData eventData) { Dg.Log(\"OnDrop\"); } /// \u003csummary\u003e /// 当结束拖拽 /// \u003c/summary\u003e /// \u003cparam name=\"eventData\"\u003e\u003c/param\u003e public void OnEndDrag(PointerEventData eventData) { Dg.Log(\"OnEndDrag\"); } /// \u003csummary\u003e /// 拖拽时的初始化，跟IPointerDownHandler差不多，在按下时调用 /// \u003c/summary\u003e /// \u003cparam name=\"eventData\"\u003e\u003c/param\u003e public void OnInitializePotentialDrag(PointerEventData eventData) { Dg.Log(\"OnInitializePotentialDrag\"); } /// \u003csummary\u003e /// 当移动时 /// 物体移动时(与InputManager里的Horizontal和Vertica按键相对应)，前提条件是物体被选中 /// \u003c/summary\u003e /// \u003cparam name=\"eventData\"\u003e\u003c/param\u003e public void OnMove(AxisEventData eventData) { Dg.Log(\"OnMove\"); } /// \u003csummary\u003e /// 当鼠标按下 /// /// \u003c/summary\u003e /// \u003cparam name=\"eventData\"\u003e\u003c/param\u003e public void OnPointerDown(PointerEventData eventData) { Dg.Log(\"OnPointerDown\"); } /// \u003csummary\u003e /// 当鼠标按下并抬起 /// 在同一物体上按下并释放 /// \u003c/summary\u003e /// \u003cparam name=\"eventData\"\u003e\u003c/param\u003e public void OnPointerClick(PointerEventData eventData) { Dg.Log(\"OnPointerClick\"); //EventSystem.current.SetSelectedGameObject(gameObject); } /// \u003csummary\u003e /// 当鼠标抬起 /// \u003c/summary\u003e /","date":"2019-12-01 21:57:40","objectID":"/ugui%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/:0:0","tags":["UGUI"],"title":"UGUI事件系统","uri":"/ugui%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"categories":["Unity"],"content":" 参考文章：https://www.cnblogs.com/slysky/p/4301676.html 参考文章：https://docs.unity3d.com/Manual/StyledText.html Unity Text 插入超链接 Unity Text 插入图片 名字 标签 例子 加粗 b \u003cb\u003eTestTest\u003c/b\u003e 倾斜 i \u003ci\u003eTestTest\u003c/i\u003e 大小 size \u003csize=40\u003eTestTest 颜色 color \u003ccolor=#00ffffff\u003eTestTest 材质 material \u003cmaterial=1\u003eTestTest material 这只是使用textmeshes呈现一段文本，这个材料通过所指定的参数设定。值是索引在text meshes数组中的材料，检查器inspector中的。  We are \u003cmaterial=2\u003etexturally amused quad 这只是使用文本网格并呈现图像与内联文本。它采用参数，指定material，使用的图像，图像的高度（以像素为单位）和表示要显示的图像的一个矩形区域。不同于其他标签tags，quad不会围绕着一段文字，所以没有结束标记-斜杠字符放在结尾，以指示它是\"自闭\"。 \u003cquadmaterial=1 size=20 x=0.1 y=0.1 width=0.5 height=0.5 /\u003e 这选择材料在renderer’s material数组中的位置，并将图像的高度设置为 20 像素。矩形区域的图像开始得到的 x、 y、宽度和高度值，都被赋予了作为未缩放宽度的一小部分和纹理的高度。 UGUI Text换行问题可以参考 UGUI Text换行问题 ","date":"2019-12-01 21:57:40","objectID":"/ugui%E4%BD%BF%E7%94%A8%E5%AF%8C%E6%96%87%E6%9C%ACrichtext/:0:0","tags":["UGUI"],"title":"UGUI使用富文本RichText","uri":"/ugui%E4%BD%BF%E7%94%A8%E5%AF%8C%E6%96%87%E6%9C%ACrichtext/"},{"categories":["UGUI"],"content":" 引用文章： 工具地址：http://www.angelcode.com/products/bmfont/ UGUI运用美术字体 ","date":"2019-12-01 21:57:40","objectID":"/ugui%E8%BF%90%E7%94%A8%E7%BE%8E%E6%9C%AF%E5%AD%97%E4%BD%93/:0:0","tags":["UGUI"],"title":"UGUI运用美术字体","uri":"/ugui%E8%BF%90%E7%94%A8%E7%BE%8E%E6%9C%AF%E5%AD%97%E4%BD%93/"},{"categories":["Unity"],"content":"Editor 编辑器日志 编辑器日志，可以通过Unity的控制台窗口中Open Editor Log 按钮打开。 Mac OS X ~/Library/Logs/Unity/Editor.log Windows XP * C:\\Documents and Settings\\username\\Local Settings\\Application Data\\Unity\\Editor\\Editor.log Windows Vista/7 * C:\\Users\\username\\AppData\\Local\\Unity\\Editor\\Editor.log ","date":"2019-12-01 21:57:40","objectID":"/unity-editor%E5%92%8Cplayer%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E6%94%BE/:0:1","tags":["Unity"],"title":"Unity Editor和Player日志文件的存放","uri":"/unity-editor%E5%92%8Cplayer%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E6%94%BE/"},{"categories":["Unity"],"content":"Player 运行日志 macOS ~/Library/Logs/Unity/Player.log Windows C:\\Users\\username\\AppData\\LocalLow\\CompanyName\\ProductName\\output_log.txt Linux ~/.config/unity3d/CompanyName/ProductName/Player.log 官方说明 ","date":"2019-12-01 21:57:40","objectID":"/unity-editor%E5%92%8Cplayer%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E6%94%BE/:0:2","tags":["Unity"],"title":"Unity Editor和Player日志文件的存放","uri":"/unity-editor%E5%92%8Cplayer%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E6%94%BE/"},{"categories":["Unity"],"content":" 官方说明：https://docs.unity3d.com/2018.4/Documentation/Manual/profiler-profiling-applications.html 使用usb连接 官网说明： Attach your device to your computer via cable and make sure that it shows in the adb devices list. Go to the Build Settings (menu: File \u003e Build Settings), enable the Development Buildcheckbox, and then select Build \u0026 Run When the application launches on the device, open the Profiler window in the Unity Editor (menu: Window \u003e Analysis \u003e Profiler). From the Attach to Player drop-down menu, select AndroidProfiler(ADB@127.0.0.1:34999). The entry in the drop-down menu is only visible when the selected target is Android. 翻译后： 打开手机调试模式 打开 Build Settings (menu: File \u003e Build Settings)，勾选 Development Build 打开Profiler (menu: Window \u003e Analysis \u003e Profiler). 点击Attach to Player ，选择AndroidProfiler(ADB@127.0.0.1:34999) 勾选Enable Internal Profiler (menu: File \u003e Build Settings\u003ePlayer Settings \u003eOther Settings). win系统打开cmd命令行，执行命令 adb forward tcp:34999 localabstract:Unity-{在此处插入 Bundle ID} 例如 adb forward tcp:34999 localabstract:Unity-com.test.aoc （将com.test.aoc替换成自己的Bundle ID，不是将冒号后面的替换） 执行该命令时必须打开unity且电脑连接android手机，手机处于调试模式 使用wifi连接 Disable mobile data on your Android device. Connect your Android device to your WiFi network. The Profiler uses a local WiFi network to send profiling data from your device to the Unity Editor. Attach your device to your computer via cable. Go to the Build Settings (menu: File \u003e Build Settings), enable the Development Build and Autoconnect Profiler checkboxes, then select Build \u0026 Run. When the application launches on the device, open the Profiler window in the Unity Editor (menu: Window \u003e Analysis \u003e Profiler). Build Settings 里，将 Development Build、Autoconnect Profiler、Script Debugging 打开。 查看端口占用 netstat -ano|findstr 5037 去查找5037对应的端口号的进程id 也就是pid。 tasklist |findstr 20120 查看进程名字。 用任务管理器 查看进程pid对应的进程，然后结束进程（打开任务管理器后右键勾选PID显示pid） 如果进程有守护进程，干不掉，则参考文章 https://blog.csdn.net/aLLLiyyy/article/details/86555228，最后面会说怎么结束掉 ","date":"2019-12-01 21:57:40","objectID":"/unityprofiler%E4%BD%BF%E7%94%A8android%E7%9C%9F%E6%9C%BA%E8%BF%9E%E6%8E%A5%E6%B5%8B%E8%AF%95/:0:0","tags":["Unity","Android"],"title":"Unity Profiler 使用 Android 真机连接测试","uri":"/unityprofiler%E4%BD%BF%E7%94%A8android%E7%9C%9F%E6%9C%BA%E8%BF%9E%E6%8E%A5%E6%B5%8B%E8%AF%95/"},{"categories":["Unity"],"content":" 突然发现自己忘了，尴尬 layerMask参数： Raycast (ray : Ray, out hitInfo : RaycastHit, distance : float = Mathf.Infinity, layerMask : int = kDefaultRaycastLayers) RaycastHit hit; Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); if (Physics.Raycast(ray, out hit, 1000, 1\u003c\u003cLayerMask.NameToLayer(\"Ground\"))) { Log.Debug(\" hit :\" + hit.point ); } else { Log.Debug(\"ray cast null!\"); } int layer = LayerMask.NameToLayer(“Ground”); //假设=10 LayerMask.GetMask((“Ground”); //相当于 1 « 10 其实很简单： 1 « 10 打开第10的层。 等价于【1 « LayerMask.NameToLayer(“Ground”);】 也等价于【 LayerMask.GetMask((“Ground”);】 ~(1 « 10) 打开除了第10之外的层。 ~(1 « 0) 打开所有的层。 (1 « 10) | (1 « 8) 打开第10和第8的层。等价于【 LayerMask.GetMask((“Ground”, “Wall”);】 在代码中使用时如何开启某个Layers？ LayerMask mask = 1 « 你需要开启的Layers层。 LayerMask mask = 0 « 你需要关闭的Layers层。 举几个个栗子： LayerMask mask = 1 « 2; 表示开启Layer2。 LayerMask mask = 0 « 5;表示关闭Layer5。 LayerMask mask = 1«2|1«8;表示开启Layer2和Layer8。 LayerMask mask = 0«3|0«7;表示关闭Layer3和Layer7。 上面也可以写成： LayerMask mask = ~（1«3|1«7）;表示关闭Layer3和Layer7。 LayerMask mask = 1«2|0«4;表示开启Layer2并且同时关闭Layer4. 参考文章： LayerMask小结 Unity3D中Layers和LayerMask解析 ","date":"2019-12-01 21:57:40","objectID":"/unity3d%E4%B8%AD%E7%9A%84layermask%E7%94%A8%E6%B3%95/:0:0","tags":["Unity"],"title":"unity 中的LayerMask用法","uri":"/unity3d%E4%B8%AD%E7%9A%84layermask%E7%94%A8%E6%B3%95/"},{"categories":["Unity"],"content":" 引用：Is there a way to destroy/replace a GameObject that is inside or part of a Prefab instance? Changing Transform on a Prefab instance (jiantou) is not allowed. 这里用到的需求是做ui特效时将3Dmesh 渲染到ui层，用的ugui，ugui依赖于RectTransform，所以就有这个问题 ","date":"2019-12-01 21:57:40","objectID":"/%E4%BF%AE%E6%94%B9prefab%E5%AE%9E%E4%BE%8B%E5%B0%86transform%E5%8F%98%E4%B8%BArecttransform/:0:0","tags":["Unity","Unity编辑器"],"title":"Unity 修改Prefab实例将Transform变为RectTransform","uri":"/%E4%BF%AE%E6%94%B9prefab%E5%AE%9E%E4%BE%8B%E5%B0%86transform%E5%8F%98%E4%B8%BArecttransform/"},{"categories":["Unity"],"content":"将Prefab应用的Model对象的Transform修改为RectTransform 默认Model对象导入Transform组件，但是在ui中有些组件需要RectTransform组件，所以就需要强制将Transform变为RectTransform，这里通过调整Hierarchy面板内的prefab实例并且应用到prefab中，来完成修改，当然还有一个简单方法就是直接修改prefab /// \u003csummary\u003e /// 把Prefab中的Transform替换为RectTransform /// 有个不足的地方是prefab的继承关系会丢失（Variant关系丢失） /// 如果一个prefab中引用另一个prefab，这种关系也会丢失 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003eRectTransform\u003c/typeparam\u003e /// \u003cparam name=\"obj\"\u003e\u003c/param\u003e private void AddComponentFromPrefab\u003cT\u003e(GameObject obj) where T :UnityEngine.Component { PrefabAssetType prefabType = PrefabUtility.GetPrefabAssetType(obj); //Debug.Log($\"AddComponentFromPrefab,name:{obj.name},PrefabAssetType:{prefabType}\"); switch (prefabType) { case PrefabAssetType.Regular: case PrefabAssetType.Variant: //获取prefab实例的根节点 GameObject prefabRoot = PrefabUtility.GetOutermostPrefabInstanceRoot(obj); //获取prefab资源，在project中的 GameObject prefabAsset = PrefabUtility.GetCorrespondingObjectFromSource(obj); //Object prefabAsset = PrefabUtility.GetCorrespondingObjectFromOriginalSource(obj); //获取资源的路径名字 string assetPath = AssetDatabase.GetAssetPath(prefabAsset); //Debug.Log(assetPath); //断开Model的联系，如果是Model是禁止修改RectTransform的 PrefabUtility.UnpackPrefabInstance(prefabRoot, PrefabUnpackMode.Completely, InteractionMode.AutomatedAction); //有个不足的地方是prefab的继承关系会丢失,这里是完全断开连接，非完全的方式没有测试 PrefabUtility.SaveAsPrefabAssetAndConnect(prefabRoot, assetPath, InteractionMode.AutomatedAction); //修改prefab的RectTransform，如果修改实例的RectTransfom是失败的（Model虽然断开连接，但是还是禁止直接修改prefab实例的RectTransfom） GameObject pobj = PrefabUtility.LoadPrefabContents(assetPath); var ts=pobj.GetComponentsInChildren\u003cTransform\u003e(); foreach (var t in ts) if (!(t is RectTransform)) t.gameObject.AddComponent\u003cT\u003e(); PrefabUtility.SaveAsPrefabAsset(pobj, assetPath); PrefabUtility.UnloadPrefabContents(pobj); break; case PrefabAssetType.Model: PrefabUtility.UnpackPrefabInstanceAndReturnNewOutermostRoots(obj, PrefabUnpackMode.Completely); if (!(obj.transform is T)) obj.AddComponent\u003cT\u003e(); break; default: break; } } 测试 AddComponentFromPrefab\u003cRectTransform\u003e(gameObject); 将测试代码写到Start方法中，且脚本设置[ExecuteInEditMode]标签，挂载prefab跟节点， 测试结果： 结果： 执行代码后Model引用变为prefab内的普通物体，切换修改成功RectTransform，并且prefab也已经修改成功 ","date":"2019-12-01 21:57:40","objectID":"/%E4%BF%AE%E6%94%B9prefab%E5%AE%9E%E4%BE%8B%E5%B0%86transform%E5%8F%98%E4%B8%BArecttransform/:1:0","tags":["Unity","Unity编辑器"],"title":"Unity 修改Prefab实例将Transform变为RectTransform","uri":"/%E4%BF%AE%E6%94%B9prefab%E5%AE%9E%E4%BE%8B%E5%B0%86transform%E5%8F%98%E4%B8%BArecttransform/"},{"categories":["Unity"],"content":"Prefab和GameObject的正向和逆向查找引用 转自 Unity研究院之Prefab和GameObject的正向和逆向查找引用 [MenuItem(\"Assets/Check Prefab Use ?\")] private static void OnSearchForReferences() { //确保鼠标右键选择的是一个Prefab if(Selection.gameObjects.Length != 1) { return; } //遍历所有游戏场景 foreach(EditorBuildSettingsScene scene in EditorBuildSettings.scenes) { if(scene.enabled) { //打开场景 EditorApplication.OpenScene(scene.path); //获取场景中的所有游戏对象 GameObject []gos = (GameObject[])FindObjectsOfType(typeof(GameObject)); foreach(GameObject go in gos) { //判断GameObject是否为一个Prefab的引用 if(PrefabUtility.GetPrefabType(go) == PrefabType.PrefabInstance) { UnityEngine.Object parentObject = EditorUtility.GetPrefabParent(go); string path = AssetDatabase.GetAssetPath(parentObject); //判断GameObject的Prefab是否和右键选择的Prefab是同一路径。 if(path == AssetDatabase.GetAssetPath(Selection.activeGameObject)) { //输出场景名，以及Prefab引用的路径 Debug.Log(scene.path + \" \" + GetGameObjectPath(go)); } } } } } } public static string GetGameObjectPath(GameObject obj) { string path = \"/\" + obj.name; while (obj.transform.parent != null) { obj = obj.transform.parent.gameObject; path = \"/\" + obj.name + path; } return path; } ","date":"2019-12-01 21:57:40","objectID":"/%E4%BF%AE%E6%94%B9prefab%E5%AE%9E%E4%BE%8B%E5%B0%86transform%E5%8F%98%E4%B8%BArecttransform/:2:0","tags":["Unity","Unity编辑器"],"title":"Unity 修改Prefab实例将Transform变为RectTransform","uri":"/%E4%BF%AE%E6%94%B9prefab%E5%AE%9E%E4%BE%8B%E5%B0%86transform%E5%8F%98%E4%B8%BArecttransform/"},{"categories":["Unity"],"content":"Unity2018.4的Prefab Variant(Prefab变种)功能 转自[Unity]Unity2018.4的Prefab Variant(Prefab变种)功能 Unity 2018.4中送了一个新的功能: Prefab Variant 思路是, Prefab Variant 继承于一个父Prefab, 父Prefab属性修改后: (1)如果子Prefab的某些属性不动, 则父Prefab的属性影响子Prefab的属性, 此为 [属性继承] (2)如果对子Prefab的某些属性进行修改/覆盖, 则父Prefab的属性无法影响, 此为 [属性定制] 创建Prefab Variant的方法为: 把Prefab从Hierarchy再次拉到Project中,选择 Prefab Variant 用处举例: 比如做一个UGUI窗体模板, 上面有标题文字和关闭按钮 邮件窗体继承于此窗体模板,制作成为一个PrefabVariant, 但是标题文字定制修改为”邮件” 这时,可以通过修改窗体模板中的关闭按钮,对所有派生的窗体按钮进行修改 附:以下为官方对PrefabAssetType的解释: public enum PrefabAssetType { // // 摘要: // The object being queried is not part of a Prefab at all. NotAPrefab = 0, // 不是Prefab // // 摘要: // The object being queried is part of a regular Prefab. Regular = 1, // 常规的Prefab // // 摘要: // The object being queried is part of a Model Prefab. Model = 2, // 模型(例如:FBX) // // 摘要: // The object being queried is part of a Prefab Variant. // A Variant Prefab is a Prefab that is derived from another Prefab, // that be could be a Regular, Model or even Variant Prefab. Variant = 3, // Prefab变种 // // 摘要: // The object being queried is part of a Prefab instance, but because the asset // it missing the actual type of Prefab can’t be determined. MissingAsset = 4 // Prefab实例化出来的对象,但是Prefab被删了(红色) } ","date":"2019-12-01 21:57:40","objectID":"/%E4%BF%AE%E6%94%B9prefab%E5%AE%9E%E4%BE%8B%E5%B0%86transform%E5%8F%98%E4%B8%BArecttransform/:3:0","tags":["Unity","Unity编辑器"],"title":"Unity 修改Prefab实例将Transform变为RectTransform","uri":"/%E4%BF%AE%E6%94%B9prefab%E5%AE%9E%E4%BE%8B%E5%B0%86transform%E5%8F%98%E4%B8%BArecttransform/"},{"categories":["Unity"],"content":"平台 #define 指令 属性 功能 UNITY_EDITOR 用于从游戏代码中调用 Unity Editor 脚本的 #define 指令。 UNITY_EDITOR_WIN 用于 Windows 上的 Editor 代码的 #define 指令。 UNITY_EDITOR_OSX 用于 Mac OS X 上的 Editor 代码的 #define 指令。 UNITY_STANDALONE_OSX 用于专门为 Mac OS X（包括 Universal、PPC 和 Intel 架构）编译/执行代码的 #define 指令。 UNITY_STANDALONE_WIN 用于专门为 Windows 独立平台应用程序编译/执行代码的 #define 指令。 UNITY_STANDALONE_LINUX 用于专门为 Linux 独立平台应用程序编译/执行代码的 #define 指令。 UNITY_STANDALONE 用于为任何独立平台（Mac OS X、Windows 或 Linux）编译/执行代码的 #define 指令。 UNITY_WII 用于为 Wii 游戏主机编译/执行代码的 #define 指令。 UNITY_IOS 用于为 iOS 平台编译/执行代码的 #define 指令。 UNITY_IPHONE 已弃用。改用 UNITY_IOS。 UNITY_ANDROID 用于 Android 平台的 #define 指令。 UNITY_PS4 用于运行 PlayStation 4 代码的 #define 指令。 UNITY_XBOXONE 用于执行 Xbox One 代码的 #define 指令。 UNITY_TIZEN 用于 Tizen 平台的 #define 指令。 UNITY_TVOS 用于 Apple TV 平台的 #define 指令。 UNITY_WSA 用于通用 Windows 平台的 #define 指令。此外，根据 .NET Core 和使用 .NET 脚本后端来编译 C# 文件时会定义 NETFX_CORE。 UNITY_WSA_10_0 用于通用 Windows 平台的 #define 指令。此外，根据 .NET Core 来编译 C# 文件时会定义 WINDOWS_UWP。 UNITY_WINRT 与 UNITY_WSA 相同。 UNITY_WINRT_10_0 等效于 UNITY_WSA_10_0 UNITY_WEBGL 用于 WebGL 的 #define 指令。 UNITY_FACEBOOK 用于 Facebook 平台（WebGL 或 Windows 独立平台）的 #define 指令。 UNITY_ADS 用于从游戏代码中调用 Unity Ads 方法的 #define 指令。5.2 及更高版本。 UNITY_ANALYTICS 用于从游戏代码中调用 Unity Analytics 方法的 #define 指令。5.2 及更高版本。 UNITY_ASSERTIONS 用于断言控制过程的 #define 指令。 DEVELOPMENT_BUILD Development模式 测试预编译宏定义： #if UNITY_EDITOR Debug.Log(\"Unity Editor\"); #endif 完整测试案例： using UnityEngine; using System.Collections; public class PlatformDefines : MonoBehaviour { void Start () { #if UNITY_EDITOR Debug.Log(\"Unity Editor\"); #endif #if UNITY_EDITOR_WIN Debug.Log(\"UNITY_EDITOR_WIN\"); #endif #if UNITY_EDITOR_OSX Debug.Log(\"UNITY_EDITOR_OSX\"); #endif #if UNITY_IOS Debug.Log(\"Iphone\"); #endif #if UNITY_ANDROID Debug.Log(\"UNITY_ANDROID\"); #endif #if UNITY_STANDALONE_OSX Debug.Log(\"Stand Alone OSX\"); #endif #if UNITY_STANDALONE_WIN Debug.Log(\"Stand Alone Windows\"); #endif } } ","date":"2019-12-01 21:57:40","objectID":"/unity%E5%B9%B3%E5%8F%B0%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%B8%B8%E7%94%A8%E8%AF%B4%E6%98%8E/:1:0","tags":["Unity"],"title":"Unity 平台宏定义常用说明","uri":"/unity%E5%B9%B3%E5%8F%B0%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%B8%B8%E7%94%A8%E8%AF%B4%E6%98%8E/"},{"categories":["Unity"],"content":"平台自定义 #define 指令 您也可以向内置的 #define 指令集合中添加您自己的指令。打开 Player Settings 的 Other Settings 面板，并导航到 Scripting Define Symbols 文本框。 输入要为该特定平台定义的符号名称，以分号分隔。随后可以将这些符号用作 #if 指令中的条件，就像内置条件一样。 ","date":"2019-12-01 21:57:40","objectID":"/unity%E5%B9%B3%E5%8F%B0%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%B8%B8%E7%94%A8%E8%AF%B4%E6%98%8E/:2:0","tags":["Unity"],"title":"Unity 平台宏定义常用说明","uri":"/unity%E5%B9%B3%E5%8F%B0%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%B8%B8%E7%94%A8%E8%AF%B4%E6%98%8E/"},{"categories":["Unity"],"content":"全局自定义 #define 指令 您可以定义自己的预处理器指令来控制在编译时包含的代码。为此，必须将包含额外指令的文本文件添加到 Assets 文件夹。文件名取决于您使用的语言。扩展名为 .rsp： C#（播放器和 Editor 脚本） \u003c项目路径\u003e/Assets/mcs.rsp 举例来说，如果在 mcs.rsp 文件中包含单行 -define:UNITY_DEBUG，则 #define 指令 UNITY_DEBUG 将作为 C# 脚本的全局 #define 指令存在，但 Editor 脚本除外。 每次对 .rsp 文件进行更改时，都需要重新编译才能使更改生效。可通过更新或重新导入单个脚本（.js 或 .cs）文件来完成此操作。 注意 如果只想修改全局 #define 指令，请使用 Player 设置中的 Scripting Define Symbols__，因为此选项涵盖了所有编译器。如果选择 .rsp__ 文件，则需要为 Unity 使用的每个编译器提供一个文件。 包含在 Editor 安装文件夹中的 mcs 应用程序的“Help”部分中描述了 .rsp 文件的使用方法。可通过运行 mcs -help 获取更多信息。 请注意，.rsp 文件需要与正在调用的编译器匹配。例如： 当针对 .NET 3.5 Equivalent（已弃用）脚本运行时版本时，mcs 与 mcs.rsp 一起使用， 当针对 .NET 4.x Eqivalent 脚本运行时版本编译器时，csc 与 csc.rsp 一起使用。 引用自：Unity官方说明 ","date":"2019-12-01 21:57:40","objectID":"/unity%E5%B9%B3%E5%8F%B0%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%B8%B8%E7%94%A8%E8%AF%B4%E6%98%8E/:3:0","tags":["Unity"],"title":"Unity 平台宏定义常用说明","uri":"/unity%E5%B9%B3%E5%8F%B0%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%B8%B8%E7%94%A8%E8%AF%B4%E6%98%8E/"},{"categories":["Math"],"content":" 这里参考 《unity shader 入门精要》冯乐乐的这本书 深入探索透视投影变换 https://github.com/candycat1992/Unity_Shaders_Book https://blog.csdn.net/lzhq1982/article/details/73612170 ","date":"2019-12-01 21:57:40","objectID":"/unity%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%BB%8E%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E5%88%B0%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/:0:0","tags":["Math"],"title":"unity 矩阵变换从模型空间到屏幕空间的转换","uri":"/unity%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%BB%8E%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E5%88%B0%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"categories":["Math"],"content":"0X01 变换 变换这里粗略的讲解下，为了后面的空间转换做铺垫，不是重点，如果看不 明白则看考其他文章 这里讲解的变换有三种：平移变换，缩放变换，旋转变换 说变换就要用到矩阵，这里用4x4矩阵来进行这三种变换 M3*3用于表示旋转和缩放，t3*1用于表示平移，01*3是零矩阵 ","date":"2019-12-01 21:57:40","objectID":"/unity%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%BB%8E%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E5%88%B0%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/:1:0","tags":["Math"],"title":"unity 矩阵变换从模型空间到屏幕空间的转换","uri":"/unity%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%BB%8E%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E5%88%B0%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"categories":["Math"],"content":"平移变换 将点（x,y,z）在空间中平移（tx ,ty ,tz）,用矩阵表示为 ","date":"2019-12-01 21:57:40","objectID":"/unity%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%BB%8E%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E5%88%B0%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/:1:1","tags":["Math"],"title":"unity 矩阵变换从模型空间到屏幕空间的转换","uri":"/unity%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%BB%8E%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E5%88%B0%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"categories":["Math"],"content":"缩放变换 对模型沿着x轴y轴和z轴进行缩放 ","date":"2019-12-01 21:57:40","objectID":"/unity%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%BB%8E%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E5%88%B0%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/:1:2","tags":["Math"],"title":"unity 矩阵变换从模型空间到屏幕空间的转换","uri":"/unity%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%BB%8E%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E5%88%B0%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"categories":["Math"],"content":"旋转变换 这里着重讲下这个，吐槽下好多博客将旋转连旋转正方向都没有说 ，看的云里雾里 关于旋转的正方向，OpenGL与多数图形学书籍规定的正方向为逆时针方向（沿着坐标轴负方向向原点看） 参考这篇文章旋转变换（一）旋转矩阵 绕着z轴旋转θ度的 矩阵 绕着y轴旋转θ度的 矩阵 绕着x轴旋转θ度的 矩阵 unity中旋转的顺序是首先绕Z轴进行旋转，然后绕X轴进行旋转，最后绕Y轴进行旋转。 ","date":"2019-12-01 21:57:40","objectID":"/unity%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%BB%8E%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E5%88%B0%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/:1:3","tags":["Math"],"title":"unity 矩阵变换从模型空间到屏幕空间的转换","uri":"/unity%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%BB%8E%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E5%88%B0%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"categories":["Math"],"content":"复合变换 现在可以把平移、旋转和缩放组合 顺序是先缩放变换，在进行旋转变换，最后进行平移变换，不同的顺序变换结果是不一样的 Unity使用的是列矩阵，因此阅读顺序是从右往左读的; 需要注意变换结果是依赖于变换顺序的，因为矩阵乘法不满足交换律,不同的变换顺序得到的结果可能不一样 大多数情况下，约定变换顺序是先缩放，再旋转，最后平移 如果分别绕x轴、y轴和z轴旋转的变换矩阵，要小心旋转变换顺序。在Unity中，旋转顺序是 zxy 当变换顺序不同时得到的结果是不一样的，例如： 假如小王先向前一步然后左转，记住此时的位置，然后回到原位，这次先左转再向前走一步，得到的位置和上一次是不一样的 所以我们约定变换顺序是先缩放，再旋转，最后平移 Unity中的旋转顺序是ZXY,假设给定的旋转角度是： 组合后的旋转变换矩阵是： 注意下矩阵的顺序 这里有两种坐标系可以选择： 1、 绕坐标系E 下的 z轴旋转 θz 绕坐标系E 下的 y轴旋转 θy 绕坐标系E 下的 x轴旋转 θx 即进行一次旋转的时候，不会一起旋转当前的坐标系（Unity的旋转顺序） 2、 绕坐标系E 下的z轴旋转 θz 在坐标系E 下绕z轴旋转 θz后的 新坐标系E1 下的y轴旋转 θy 在坐标系E1 下绕y轴旋转 θy后的 新坐标系E2 下的x轴旋转 θx 即 在旋转时，坐标系一起转动  在第一种情况下，按照 zxy顺序旋转 和 在第二种情况下按照 yxz顺序 旋转是一样的。 不同的旋转顺序得到的结果也可能是不一样的。 ","date":"2019-12-01 21:57:40","objectID":"/unity%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%BB%8E%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E5%88%B0%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/:1:4","tags":["Math"],"title":"unity 矩阵变换从模型空间到屏幕空间的转换","uri":"/unity%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%BB%8E%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E5%88%B0%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"categories":["Math"],"content":"0X02 坐标空间变换 已知子坐标空间C的三个坐标轴在父坐标空间P下的表示xc、yc、zc，以及其原点位置Oc，当给定一个子坐标空间中的点Ac=(a,b,c)，求A点用父坐标空间的表示Ap xc设为(xcx,xcy,xcz),yc设为(ycx,ycy,ycz),zc设为(zcx,zcy,zcz),Oc设为(ocx,ocy,ocz) 这里写结论不写推导过程了 所以点从子坐标空间到父坐标空间的变换矩阵Mc-\u003ep为( | 表示是按列展开的) 矢量（不需要平移）从子坐标空间到父坐标空间的变换矩阵Mc-\u003ep为( | 表示是按列展开的) 矢量（不需要平移）从父坐标空间到子坐标空间的变换矩阵Mp-\u003ec为( - 表示是按行展开的) ","date":"2019-12-01 21:57:40","objectID":"/unity%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%BB%8E%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E5%88%B0%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/:2:0","tags":["Math"],"title":"unity 矩阵变换从模型空间到屏幕空间的转换","uri":"/unity%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%BB%8E%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E5%88%B0%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"categories":["Math"],"content":"0X03 空间变换过程 空间变换经历这几个过程：模型空间(model space)—\u003e世界空间(world space)–\u003e观察空间(view space)（右手坐标系）–\u003e裁剪空间(clip space)–\u003e屏幕空间(screen space) 除了观察空间是右手坐标系外其他的全是左手坐标系 屏幕空间 的转换需要经过NDC变换 然后视口坐标变换（只关注x,y；z不关注）再到屏幕坐标 这里用的是 透视相机 没有用正交相机 在文章最下面提供了TransformationMatrixUtil.cs脚本 ","date":"2019-12-01 21:57:40","objectID":"/unity%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%BB%8E%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E5%88%B0%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/:3:0","tags":["Math"],"title":"unity 矩阵变换从模型空间到屏幕空间的转换","uri":"/unity%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%BB%8E%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E5%88%B0%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"categories":["Math"],"content":"模型空间到世界空间 根据世界空间对模型空间的平移、旋转、缩放来建立一个变换矩阵，变换矩阵根据上面提到的基础矩阵相乘得到 建立一个 测试脚本TestMatrix.cs 来测试变换坐标 using System.Collections; using System.Collections.Generic; using UnityEngine; public class TestMatrix : MonoBehaviour { // Use this for initialization Camera cam; /// \u003csummary\u003e /// 模型空间的物体，localPosition作为模型空间的坐标 /// 父物体的Transform作为世界空间对模型空间的变换 /// \u003c/summary\u003e public Transform trans1; void Start() { cam = Camera.main; TestModelSpaceToWorldSpace(); } /// \u003csummary\u003e /// 模型空间转世界空间的坐标 /// \u003c/summary\u003e void TestModelSpaceToWorldSpace() { Transform _parent = trans1.parent; //模型空间转世界空间 Vector3 p = TransformationMatrixUtil.MToWPosition(_parent.localScale, _parent.localEulerAngles, _parent.localPosition, trans1.localPosition); Debug.Log(\"模型空间转世界空间的坐标：\" + p); Debug.Log(\"物体的世界坐标\" + trans1.position); //模型空间转世界空间 Matrix4x4 matrix = TransformationMatrixUtil.MToWMatrix(_parent.localScale, _parent.localEulerAngles, _parent.localPosition); Debug.LogFormat(\"matrix:\\n{0}\\n\\nlocalToWorldMatrix:\\n{1}\\n\\n是否相等：{2}\", matrix, _parent.localToWorldMatrix, matrix == _parent.localToWorldMatrix); } } 场景中配置两个物体 Root，Cube；Root的Transform代表世界空间对Cube模型空间的变换 测试代码的结果：说明变换后的坐标和物体本身世界坐标相同 来看世界空间到模型空间 继续增加测试代码 /// \u003csummary\u003e /// 世界空间到模型空间变换对比 /// 这里直接对比变换矩阵是否相同 /// \u003c/summary\u003e void TestWorldSpaceToModelSpace() { //检查世界空间到模型空间 Transform _parent = trans1.parent; //模型空间转世界空间 Matrix4x4 matrix = TransformationMatrixUtil.MToWMatrix(_parent.localScale, _parent.localEulerAngles, _parent.localPosition); //世界空间转模型空间；就是matrix的逆矩阵 matrix = matrix.inverse; Debug.LogFormat(\"matrix:\\n{0}\\n\\nworldToLocalMatrix:\\n{1}\\n\\n是否相等：{2}\", matrix, _parent.worldToLocalMatrix, matrix== _parent.worldToLocalMatrix); } 在Start方法中调用后的结果： ","date":"2019-12-01 21:57:40","objectID":"/unity%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%BB%8E%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E5%88%B0%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/:3:1","tags":["Math"],"title":"unity 矩阵变换从模型空间到屏幕空间的转换","uri":"/unity%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%BB%8E%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E5%88%B0%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"categories":["Math"],"content":"模型空间到观察空间 继续增加测试代码 /// \u003csummary\u003e /// 世界空间到观察空间变换对比 /// 这里是透视相机，没有做正交相机的 /// \u003c/summary\u003e void TestWorldSpaceToViewSpace() { //注意这里是透视相机，没有做正交相机变换矩阵 cam = Camera.main; //世界空间坐标到观察空间坐标 Vector3 viewPos = TransformationMatrixUtil.WToVPosition(trans1.position); //结果是z轴相反，因为世界空间是左手坐标系，而观察空间是右手坐标系 Debug.LogFormat(\"世界空间:{0},观察空间:{1}\", trans1.position, viewPos); //世界空间到观察空间 Matrix4x4 matrix = TransformationMatrixUtil.WToVMatrix(); Debug.LogFormat(\"matrix:\\n{0}\\n\\n worldToCameraMatrix:\\n{1}\\n\\n是否相等：{2}\", matrix, cam.worldToCameraMatrix, matrix == cam.worldToCameraMatrix); } 在Start方法中调用后的结果： ","date":"2019-12-01 21:57:40","objectID":"/unity%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%BB%8E%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E5%88%B0%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/:4:0","tags":["Math"],"title":"unity 矩阵变换从模型空间到屏幕空间的转换","uri":"/unity%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%BB%8E%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E5%88%B0%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"categories":["Math"],"content":"观察空间到裁剪空间 继续增加测试代码 /// \u003csummary\u003e /// 测试观察空间到裁剪空间的变换矩阵 /// \u003c/summary\u003e void TestViewSpaceToClipSpace() { //观察空间到裁剪空间矩阵，注意这里是透视相机，没有做正交相机变换矩阵 Matrix4x4 matrix = TransformationMatrixUtil.VToPMatrix(); Debug.LogFormat(\"matrix:\\n{0}\\n\\n projectionMatrix:\\n{1}\\n\\n是否相等：{2}\", matrix, cam.projectionMatrix, matrix == cam.projectionMatrix); } 在Start方法中调用后的结果： ","date":"2019-12-01 21:57:40","objectID":"/unity%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%BB%8E%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E5%88%B0%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/:5:0","tags":["Math"],"title":"unity 矩阵变换从模型空间到屏幕空间的转换","uri":"/unity%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%BB%8E%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E5%88%B0%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"categories":["Math"],"content":"模型空间到屏幕空间 这里直接测试从模型空间到世界空间到观察空间到屏幕空间变换 /// \u003csummary\u003e /// 测试模型空间到屏幕空间的变换 /// 只验证 屏幕坐标xy，不验证zw /// 注意这里是透视相机，没有做正交相机变换矩阵 /// \u003c/summary\u003e void TestModelSpaceToScreenSpace() { Transform _parent = trans1.parent; //模型空间转世界空间 Vector3 worldPos = TransformationMatrixUtil.MToWPosition(_parent.localScale, _parent.localEulerAngles, _parent.localPosition, trans1.localPosition); //世界空间转观察空间 Vector3 viewPos = TransformationMatrixUtil.WToVPosition(worldPos); //观察空间转透视裁剪空间 Vector4 clipPos = TransformationMatrixUtil.VToPPosition(viewPos); //裁剪空间到屏幕空间变换 Vector4 screenPos = TransformationMatrixUtil.PToScreenPosition(clipPos); Vector4 screenPos1 = cam.WorldToScreenPoint(trans1.position); //Vector4 viewportPos = cam.WorldToViewportPoint(trans1.position); Debug.LogFormat(\" worldPos:{0},trans1.positon:{1}\\n viewPos:{2}\\n clipPos:{3}\\n screenPos:{4},screenPos1:{5}\",worldPos,trans1.position,viewPos,clipPos,screenPos,screenPos1); } 在Start方法中调用后的结果：（如果想要一样的结果则需要设置分辨率为1280*720，并且相机配置一样） 这里只验证屏幕坐标x和y，z值是世界坐标的z值，没有变换的，w值没有研究 脚本 TransformationMatrixUtil.cs //===================================================== // - FileName: TransformationMatrixUtil.cs // - Created: wangguoqing // - UserName: 2018/09/03 17:18:56 // - Email: wangguoqing@hehegames.cn // - Description: // - (C) Copyright 2008 - 2015, codingriver,Inc. // - All Rights Reserved. //====================================================== using System.Collections; using System.Collections.Generic; using UnityEngine; public class TransformationMatrixUtil { /// \u003csummary\u003e /// 模型空间的坐标转世界空间坐标 /// \u003c/summary\u003e /// \u003cparam name=\"scale\"\u003e世界空间对模型的缩放\u003c/param\u003e /// \u003cparam name=\"rotation\"\u003e世界空间对模型的旋转\u003c/param\u003e /// \u003cparam name=\"translate\"\u003e世界空间对模型的平移\u003c/param\u003e /// \u003cparam name=\"currentPos\"\u003e模型空间的坐标\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static Vector3 MToWPosition(Vector3 scale, Vector3 rotation, Vector3 translate, Vector3 currentPos) { Matrix4x4 convertMatrix = MToWMatrix(scale, rotation, translate); Vector3 pos= convertMatrix.MultiplyPoint(currentPos); return pos; } /// \u003csummary\u003e /// 世界空间的坐标转模型空间坐标 /// \u003c/summary\u003e /// \u003cparam name=\"scale\"\u003e世界空间对模型的缩放\u003c/param\u003e /// \u003cparam name=\"rotation\"\u003e世界空间对模型的旋转\u003c/param\u003e /// \u003cparam name=\"translate\"\u003e世界空间对模型的平移\u003c/param\u003e /// \u003cparam name=\"currentPos\"\u003e世界空间的坐标\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static Vector3 WToMPosition(Vector3 scale, Vector3 rotation, Vector3 translate, Vector3 currentPos) { Matrix4x4 convertMatrix = MToWMatrix(scale, rotation, translate); Vector3 pos = convertMatrix.inverse.MultiplyPoint(currentPos); return pos; } /// \u003csummary\u003e /// 模型空间到世界空间的变换矩阵 /// \u003c/summary\u003e /// \u003cparam name=\"scale\"\u003e世界空间对模型空间的缩放\u003c/param\u003e /// \u003cparam name=\"rotation\"\u003e世界空间对模型空间的旋转\u003c/param\u003e /// \u003cparam name=\"translate\"\u003e世界空间对模型空间的平移\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static Matrix4x4 MToWMatrix(Vector3 scale, Vector3 rotation, Vector3 translate) { Matrix4x4 scaleMatrix = new Matrix4x4(); scaleMatrix.SetRow(0, new Vector4(scale.x, 0, 0, 0)); scaleMatrix.SetRow(1, new Vector4(0, scale.y, 0, 0)); scaleMatrix.SetRow(2, new Vector4(0, 0, scale.z, 0)); scaleMatrix.SetRow(3, new Vector4(0, 0, 0, 1)); rotation *= Mathf.Deg2Rad; Matrix4x4 rotateMatrixZ = new Matrix4x4(); rotateMatrixZ.SetRow(0, new Vector4(Mathf.Cos(rotation.z), -Mathf.Sin(rotation.z), 0, 0)); rotateMatrixZ.SetRow(1, new Vector4(Mathf.Sin(rotation.z), Mathf.Cos(rotation.z), 0, 0)); rotateMatrixZ.SetRow(2, new Vector4(0, 0, 1, 0)); rotateMatrixZ.SetRow(3, new Vector4(0, 0, 0, 1)); Matrix4x4 rotateMatrixY = new Matrix4x4(); rotateMatrixY.SetRow(0, new Vector4(Mathf.Cos(rotation.y), 0, Mathf.Sin(rotation.y), 0)); rotateMatrixY.SetRow(1, new Vector4(0, 1, 0, 0)); rotateMatrixY.SetRow(2, new Vector4(-Mathf.Sin(rotation.y), 0, Mathf.Cos(rotation.y), 0)); rotateMatrixY.SetRow(3, new Vector4(0, 0, 0, 1)); Matrix4x4 rotateMatrixX = new Matrix4x4(); rotateMatrixX.SetRow(0, new Vector4(1, 0, 0, 0)); rotateMatrixX.SetRow(1, new Vector4(0, Mathf.Cos(rotation.x), -Mathf.Sin(rotation.x), 0)); rotateMatrixX.SetRow(2, new Vector4(0, Mathf.Sin(rotation.x), Mathf.Cos(rotation","date":"2019-12-01 21:57:40","objectID":"/unity%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%BB%8E%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E5%88%B0%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/:6:0","tags":["Math"],"title":"unity 矩阵变换从模型空间到屏幕空间的转换","uri":"/unity%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%BB%8E%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E5%88%B0%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"categories":["Unity"],"content":" import android.net.wifi.WifiInfo; import android.net.wifi.WifiManager; import android.os.BatteryManager; //*******************************部分代码******************************************** TelephonyManager phoneManager=null; WifiManager wifiManager=null; WifiInfo wifiInfo = null; //获得的Wifi信息 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); phoneManager = (TelephonyManager) this.getSystemService(TELEPHONY_SERVICE); // 获得WifiManager wifiManager = (WifiManager) getSystemService(WIFI_SERVICE); } //********************************Battery 电量************************************************* private IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED); public float GetBatterySignal() { Intent batteryStatus = this.registerReceiver(null, ifilter); //当前剩余电量 int level = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1); //电量最大值 int scale = batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -1); //电量百分比 float batteryPct = level / (float)scale; Log.i(\"unity\", \"GetBatterySignal:::\"+batteryPct); return batteryPct; } //********************************wifi 网络信号 ************************************************* public int GetWifiSignal() { wifiInfo = wifiManager.getConnectionInfo(); //获得信号强度值 int level = wifiInfo.getRssi(); int signal=0; //根据获得的信号强度发送信息 if (level \u003c= 0 \u0026\u0026 level \u003e= -50) { signal=5; } else if (level \u003c -50 \u0026\u0026 level \u003e= -70) { signal=4; } else if (level \u003c -70 \u0026\u0026 level \u003e= -80) { signal=3; } else if (level \u003c -80 \u0026\u0026 level \u003e= -100) { signal=2; } else { signal=1; } Log.i(\"unity\", \"GetWifiSignal:::\"+signal); return signal; } ","date":"2019-12-01 21:57:40","objectID":"/unity--android%E8%8E%B7%E5%8F%96%E7%94%B5%E9%87%8F%E5%92%8Cwifi%E4%BF%A1%E5%8F%B7%E5%BC%BA%E5%BA%A6/:0:0","tags":["Android","Unity"],"title":"unity--android获取电量和wifi信号强度","uri":"/unity--android%E8%8E%B7%E5%8F%96%E7%94%B5%E9%87%8F%E5%92%8Cwifi%E4%BF%A1%E5%8F%B7%E5%BC%BA%E5%BA%A6/"},{"categories":["Unity"],"content":" unity的3D相机默认是根据高度适配的（保持3D相机的高度视野范围不变），这里调整成根据宽度适配（就是保持3D相机宽度的视野范围不变）。 直接上脚本，将脚本挂在Camera的物体上 //===================================================== // - FileName: CameraAdjust.cs // - Description: // - Author: wangguoqing // - Email: wangguoqing@hehemj.com // - Created: #CreateTime# // - UserName: #AuthorName# // - (C) Copyright 2008 - 2015, hehehuyu,Inc. // - All Rights Reserved. //====================================================== using System; using System.Collections; using System.Collections.Generic; using UnityEngine; /// \u003csummary\u003e /// 3D相机根据宽度适配，默认的相机是根据高度适配的 /// 将该脚本挂在Camera的物体上 /// \u003c/summary\u003e public class CameraAdjust : MonoBehaviour { void Start () { int ManualWidth = 1280; //首先记录下你想要的屏幕分辨率的宽 int ManualHeight = 720; //记录下你想要的屏幕分辨率的高 //普通安卓的都是 1280*720的分辨率 int manualHeight; //然后得到当前屏幕的高宽比 和 你自定义需求的高宽比。通过判断他们的大小，来不同赋值 //*其中Convert.ToSingle（）和 Convert.ToFloat() 来取得一个int类型的单精度浮点数（C#中没有 Convert.ToFloat() ）； if (Convert.ToSingle(Screen.height) / Screen.width \u003e Convert.ToSingle(ManualHeight) / ManualWidth) { //如果屏幕的高宽比大于自定义的高宽比 。则通过公式 ManualWidth * manualHeight = Screen.width * Screen.height； //来求得适应的 manualHeight ，用它待求出 实际高度与理想高度的比率 scale manualHeight = Mathf.RoundToInt(Convert.ToSingle(ManualWidth) / Screen.width * Screen.height); } else { //否则 直接给manualHeight 自定义的 ManualHeight的值，那么相机的fieldOfView就会原封不动 manualHeight = ManualHeight; } Camera camera = GetComponent\u003cCamera\u003e(); float scale = Convert.ToSingle(manualHeight*1.0f / ManualHeight); camera.fieldOfView *= scale; //Camera.fieldOfView 视野: 这是垂直视野：水平FOV取决于视口的宽高比，当相机是正交时fieldofView被忽略 //把实际高度与理想高度的比率 scale乘加给Camera.fieldOfView。 //这样就能达到，屏幕自动调节分辨率的效果 } } ","date":"2019-12-01 21:57:40","objectID":"/unity-3dcamera%E6%A0%B9%E6%8D%AE%E5%AE%BD%E5%BA%A6%E9%80%82%E9%85%8D3d%E7%9B%B8%E6%9C%BA%E9%80%82%E9%85%8D/:0:0","tags":["Unity"],"title":"unity-3DCamera根据宽度适配(3D相机适配)","uri":"/unity-3dcamera%E6%A0%B9%E6%8D%AE%E5%AE%BD%E5%BA%A6%E9%80%82%E9%85%8D3d%E7%9B%B8%E6%9C%BA%E9%80%82%E9%85%8D/"},{"categories":["Unity"],"content":" #####font贴图纹理中，同一个字符的两个size会在纹理中绘制两份，在font纹理中使用的字符数量很少后，纹理大小会释放，最小的font纹理256*256 //===================================================== // - FileName: FontTest.cs // - Created: wangguoqing // - UserName: 2018/03/10 14:13:08 // - Email: wangguoqing@hehegames.cn // - Description: // - (C) Copyright 2008 - 2015, hehehuyu,Inc. // - All Rights Reserved. //====================================================== using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; using System.IO; public class FontTest : MonoBehaviour { // Use this for initialization public Text text; public RawImage img; public MeshRenderer renderer; void Awake () { Font.textureRebuilt += FontTextureRebuild; text.font.material = renderer.sharedMaterial; } void Start() { FontInfo(text.font); img.material.mainTexture = text.font.material.mainTexture; //StartCoroutine(CreateCharacters()); } // Update is called once per frame void Update () { } /// \u003csummary\u003e /// 文字生成器 /// \u003c/summary\u003e /// \u003creturns\u003e\u003c/returns\u003e IEnumerator CreateCharacters() { if(text==null) { yield break; } int unicodeMin = 0X4E00; int unicodeMax = 0X9FA5; int count = 0; for (int i = unicodeMin; i \u003c 0X8FA5; i++) { text.text += System.Convert.ToChar(i); count++; if(count\u003e=100) { count = 0; yield return new WaitForSeconds(0.1f); } } yield break; } void FontInfo(Font font) { Texture tex = font.material.mainTexture; Dg.LogFormat(\"font name({0}),fontSize({1}),textureId({2}),tex width({3}),tex height({4})\",font.name,font.fontSize,tex.GetInstanceID(),tex.width,tex.height); //Texture2D tex2d = tex as Texture2D; //byte[] data = tex2d.EncodeToPNG(); //System.IO.File.WriteAllBytes(\"./+\" + font.name + \"_font.png\", data); } void FontTextureRebuild(Font font) { Dg.Log(\"FontTextureRebuild:::\" + font.name); FontInfo(font); } } ","date":"2019-12-01 21:57:40","objectID":"/unity-font-test%E6%B5%8B%E8%AF%95/:0:0","tags":["Unity"],"title":"unity-Font-Test测试","uri":"/unity-font-test%E6%B5%8B%E8%AF%95/"},{"categories":["Unity"],"content":" 直接上测试结果，方便后面使用: #####GameObject被销毁时当前帧可以继续使用属性（gameObject,parent,transform等等）。 #####GameObject被销毁的下一帧判定null是相等的但是物体类型还是GameObject。 #####特别注意GameObject被销毁时当前帧 根据它的Parent获取childCount时是包含销毁的GameObject，所以这里计数不是想象的那样，如果使用childCount则在Destory前将父子关系解除 场景内未运行截图 Test.cs代码 //===================================================== // - FileName: Test // - Description: // - Author: wangguoqing // - Email: wangguoqing@hehemj.com // - Created: 2017/12/13 17:12:17 // - CLR version: 4.0.30319.42000 // - UserName: Wang // - (C) Copyright 2008 - 2015, hehehuyu,Inc. // - All Rights Reserved. //====================================================== using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; using System.Text; using UnityEngine.Events; using UnityEngine.EventSystems; public class Test : MonoBehaviour { public GameObject obj; void Start() { StartCoroutine(DestroyObj(obj)); } IEnumerator DestroyObj(GameObject go) { Debug.Log(\"StartCoroutine\"); Destroy(go); Debug.Log(\"go:::\" + go); Debug.Log(\"go transform::1:::\" + go.transform); Debug.Log(\"type::1::\"+ go.GetType().FullName); //go = null; yield return new WaitForEndOfFrame(); if (go == null) { Debug.Log(\"null===1\"); } if(go is GameObject) { Debug.Log(\"type::2::\" + go.GetType().FullName); } Destroy(go); if (go == null) { Debug.Log(\"null===2\"); } Debug.Log(\"go transform::2:::\" + go.transform);//这里是77行 Destroy(go); yield break; } } 运行结果 将go=null这行代码注释放开后的运行结果： 根据结果说明： 1. gameObject在第一次Destroy后名没有立即被删除，当前帧可以继续使用；相关属性例如transform还可以用；在获取它Parent的所有物体时是能读到该gameObject属性的，并且Parent读取childCount是包含该gameObject计数的. 2. gameObject在第一次Destroy后的下一帧再使用时属性读取失败，应为Destroy的那一帧最终gameObject被销毁，然后go变量为null(这里的null并不是C#真正的null，因为go.transform报错信息有说明)，但是Destroy(go)是不报错的, ","date":"2019-12-01 21:57:40","objectID":"/unity-gameobject-%E9%94%80%E6%AF%81destroy%E5%90%8E%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81/:0:0","tags":["Unity"],"title":"Unity-GameObject-销毁（Destroy）后的几种状态","uri":"/unity-gameobject-%E9%94%80%E6%AF%81destroy%E5%90%8E%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81/"},{"categories":["Unity"],"content":" 两种方案 简单版本：需要用域名 IPAddress[] address = null; try { //string HostName = Dns.GetHostName(); //得到主机名 //www.***.com自己的域名 address = Dns.GetHostAddresses(\"www.***.com\"); //本机ip不行，有bug // address= Dns.GetHostAddresses(ip); } catch (Exception ex) { Dg.LogError(\"Dns.GetHostAddresses::Error:\", ex.ToString()); } if(address!=null) { foreach (var item in address) { Dg.Log(\"address:::::::::\", item.ToString()); } } if (address != null \u0026\u0026 address.Length\u003e0\u0026\u0026address[0].AddressFamily == AddressFamily.InterNetworkV6) { Dg.Log(\"网络类型:::InterNetworkV6\"); client = new TcpClient(AddressFamily.InterNetworkV6); } else { Dg.Log(\"网络类型:::InterNetwork\"); client = new TcpClient(AddressFamily.InterNetwork); } //connect时用adress 复杂版本：可以用ipv4的ip地址 c#部分 #if UNITY_IPHONE \u0026\u0026 !UNITY_EDITOR [DllImport(\"__Internal\")] private static extern string getIPv6(string mHost, string mPort); #endif //\"192.168.1.1\u0026\u0026ipv4\" public static string GetIPv6(string mHost, string mPort) { #if UNITY_IPHONE \u0026\u0026 !UNITY_EDITOR string mIPv6 = getIPv6(mHost, mPort); return mIPv6; #else return mHost + \"\u0026\u0026ipv4\"; #endif } void getIPType(String serverIp, String serverPorts, out String newServerIp, out AddressFamily mIPType) { mIPType = AddressFamily.InterNetwork; newServerIp = serverIp; try { string mIPv6 = GetIPv6(serverIp, serverPorts); if (!string.IsNullOrEmpty(mIPv6)) { string[] m_StrTemp = System.Text.RegularExpressions.Regex.Split(mIPv6, \"\u0026\u0026\"); if (m_StrTemp != null \u0026\u0026 m_StrTemp.Length \u003e= 2) { string IPType = m_StrTemp[1]; if (IPType == \"ipv6\") { newServerIp = m_StrTemp[0]; mIPType = AddressFamily.InterNetworkV6; } } } } catch (Exception e) { Dg.LogError(\"GetIPv6 error:\" + e.ToString()); } } public TcpClient CreateTcpClient(String serverIp, String serverPorts,out String newServerIP) { String newServerIp = \"\"; AddressFamily newAddressFamily = AddressFamily.InterNetwork; #if UNITY_IPHONE \u0026\u0026 !UNITY_EDITOR getIPType(serverIp, serverPorts, out newServerIp, out newAddressFamily); if (!string.IsNullOrEmpty(newServerIp)) { serverIp = newServerIp; } #endif TcpClient client = new TcpClient(newAddressFamily); Dg.Log(\"网络类型 AddressFamily :\" + newAddressFamily.ToString() + \" ServerIp:\" + serverIp); newServerIP = serverIp; return client; } private TcpClient client; //ip ：ipv4地址， public void Connect(string ip, int port,int connectTimeout) { string newIp=ip; client = ProviderService.Instance.CreateTcpClient(ip, port.ToString(),out newIp); client.BeginConnect(newIp, port, ConnectCallBack, client); } private void ConnectCallBack(IAsyncResult ar) { Dg.Log(\"ConnectCallBack\"); try { if (client == null) return; client.EndConnect(ar); Dg.Log(\"ConnectCallBack1111\"); //连接成功了 } catch (SocketException e) { Dg.LogError(\"SOCKET::ERROR:\", e.ToString()); } } object-c //#import \"BundleId.h\" #include \u003csys/socket.h\u003e #include \u003cnetdb.h\u003e #include \u003carpa/inet.h\u003e #include \u003cerr.h\u003e #define MakeStringCopy( _x_ ) ( _x_ != NULL \u0026\u0026 [_x_ isKindOfClass:[NSString class]] ) ? strdup( [_x_ UTF8String] ) : NULL const char* getIPv6(const char *mHost,const char *mPort) { if( nil == mHost ) return NULL; const char *newChar = \"No\"; const char *cause = NULL; struct addrinfo* res0; struct addrinfo hints; struct addrinfo* res; int n, s; memset(\u0026hints, 0, sizeof(hints)); hints.ai_flags = AI_DEFAULT; hints.ai_family = PF_UNSPEC; hints.ai_socktype = SOCK_STREAM; //IOS9.2及以后的版本才支持IPv6 if((n=getaddrinfo(mHost, \"http\", \u0026hints, \u0026res0))!=0) { printf(\"getaddrinfo error: %s\\n\",gai_strerror(n)); return NULL; } struct sockaddr_in6* addr6; struct sockaddr_in* addr; NSString * NewStr = NULL; char ipbuf[32]; s = -1; for(res = res0; res; res = res-\u003eai_next) { if (res-\u003eai_family == AF_INET6) { addr6 =( struct sockaddr_in6*)res-\u003eai_addr; newChar = inet_ntop(AF_INET6, \u0026addr6-\u003esin6_addr, ipbuf, sizeof(ipbuf)); NSString * TempA = [[NSString alloc] initWithCString:(const char*)newChar encoding:NSASCIIStringEncoding]; NSString * TempB = [NSString stringWithUTF8String:\"\u0026\u0026ipv6\"]; NewStr = [TempA stringByAppendingString: TempB]; printf(\"%s\\n\", newChar); } else { addr =( struct ","date":"2019-12-01 21:57:40","objectID":"/unity-ios%E5%AE%A1%E6%A0%B8ipv6/:0:0","tags":["Unity","IOS","Ipv6"],"title":"unity-ios审核ipv6","uri":"/unity-ios%E5%AE%A1%E6%A0%B8ipv6/"},{"categories":["Unity"],"content":"java代码 ImageView bgView=null; //显示启动图 void ShowSplash() { try { //对应unity目录： InputStream is = getAssets().open(\"bin/Data/splash.png\"); Bitmap splashBitmap = null; BitmapFactory.Options options = new BitmapFactory.Options(); options.inPreferredConfig = Bitmap.Config.ARGB_8888; splashBitmap = BitmapFactory.decodeStream(is, null, options); is.close(); bgView = new ImageView(this); bgView.setImageBitmap(splashBitmap); bgView.setScaleType(ImageView.ScaleType.CENTER_CROP); // Resources r = mUnityPlayer.currentActivity.getResources(); mUnityPlayer.addView(bgView); // mUnityPlayer.addView(bgView, r.getDisplayMetrics().widthPixels, r.getDisplayMetrics().heightPixels); } catch (Exception e) { Log.v(\"unity\", \"Exception while load splash:\" + e.toString()); } } //关闭启动图 void HideSplash() { this.runOnUiThread(new Runnable() { @Override public void run() { mUnityPlayer.removeView(bgView); bgView = null; } }); } splash.png文件放在unity工程中的目录为： 该文件不用放到android的插件工程中，直接放在unity中就可以了 这里有个bug:splash在加载第0个场景时会被隐藏或者销毁掉没有仔细测试，然后加载场景过程中是黑屏 ","date":"2019-12-01 21:57:40","objectID":"/unity-%E4%BD%BF%E7%94%A8android-splash/:0:0","tags":["Android","Unity"],"title":"Unity-使用Android-Splash","uri":"/unity-%E4%BD%BF%E7%94%A8android-splash/"},{"categories":["Unity"],"content":" android 通过java层重载返回键事件onBackPressed有bug，有时候不响应！！！ @Override public void onBackPressed(){ Log.v(\"life\",\"onBackPressed\"); super.onBackPressed(); UnityPlayer.UnitySendMessage(GameObjectName, OnBackMethodName,\"back\"); } 解决方案：在unity中获取KeyCode.Escape点击事件，android返回键就是KeyCode.Escape点击事件,这个没有问题 using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.SceneManagement; public class GameApp : MonoBehaviour { void Update () { //Debug.Log(\"Update^^^^^^^^^^^^^\"); _luaMgr.Update(); if (Input.GetKeyDown(KeyCode.Escape)) { Dg.Log(\"Input.GetKeyDown:::KeyCode.Escape\"); } } } ","date":"2019-12-01 21:57:40","objectID":"/unity-%E5%93%8D%E5%BA%94android%E8%BF%94%E5%9B%9E%E9%94%AE/:0:0","tags":["Android","Unity"],"title":"unity-响应Android返回键","uri":"/unity-%E5%93%8D%E5%BA%94android%E8%BF%94%E5%9B%9E%E9%94%AE/"},{"categories":["Unity"],"content":" 参考文章:http://blog.csdn.net/qingyang8513/article/details/52544122 打包Android报错CommandInvokationFailure: Unable to convert classes into dex format. PARSE ERROR: unsupported class file version 52.0 ...while parsing com/hehe/game/AppActivity.class 1 error; aborting 上面的错误说明是编辑器版本不兼容 untiy版本：5.6.0f3 将编译器的版本改成1.7就可以了 完整错误: CommandInvokationFailure: Unable to convert classes into dex format. C:\\Program Files\\Java\\jdk1.8.0_121\\bin\\java.exe -Xmx2048M -Dcom.android.sdkmanager.toolsdir=\"C:/AndroidSDK/AndroidSDK\\tools\" -Dfile.encoding=UTF8 -jar \"C:\\Program Files\\Unity\\Editor\\Data\\PlaybackEngines\\AndroidPlayer/Tools\\sdktools.jar\" - stderr[ PARSE ERROR: unsupported class file version 52.0 ...while parsing com/hehe/game/AppActivity.class 1 error; aborting ] stdout[ processing archive bin\\classes.jar... processing bitter/jnibridge/JNIBridge.class... processing bitter/jnibridge/JNIBridge$a.class... processing com/unity3d/player/NativeLoader.class... processing com/unity3d/player/ReflectionHelper.class... processing com/unity3d/player/ReflectionHelper$1.class... processing com/unity3d/player/ReflectionHelper$a.class... processing com/unity3d/player/UnityPlayer.class... processing com/unity3d/player/UnityPlayer$1.class... processing com/unity3d/player/UnityPlayer$10.class... processing com/unity3d/player/UnityPlayer$1$1.class... processing com/unity3d/player/UnityPlayer$11.class... processing com/unity3d/player/UnityPlayer$12.class... processing com/unity3d/player/UnityPlayer$12$1.class... processing com/unity3d/player/UnityPlayer$13.class... processing com/unity3d/player/UnityPlayer$14.class... processing com/unity3d/player/UnityPlayer$15.class... processing com/unity3d/player/UnityPlayer$16.class... processing com/unity3d/player/UnityPlayer$17.class... processing com/unity3d/player/UnityPlayer$18.class... processing com/unity3d/player/UnityPlayer$19.class... processing com/unity3d/player/UnityPlayer$2.class... processing com/unity3d/player/UnityPlayer$20.class... processing com/unity3d/player/UnityPlayer$21.class... processing com/unity3d/player/UnityPlayer$3.class... processing com/unity3d/player/UnityPlayer$4.class... processing com/unity3d/player/UnityPlayer$5.class... processing com/unity3d/player/UnityPlayer$6.class... processing com/unity3d/player/UnityPlayer$7.class... processing com/unity3d/player/UnityPlayer$8.class... processing com/unity3d/player/UnityPlayer$9.class... processing com/unity3d/player/UnityPlayer$a.class... processing com/unity3d/player/UnityPlayer$b.class... processing com/unity3d/player/UnityPlayer$c.class... processing com/unity3d/player/UnityPlayer$c$1.class... processing com/unity3d/player/UnityPlayer$d.class... processing com/unity3d/player/UnityPlayerActivity.class... processing com/unity3d/player/UnityPlayerNativeActivity.class... processing com/unity3d/player/UnityPlayerProxyActivity.class... processing com/unity3d/player/UnityWebRequest.class... processing com/unity3d/player/WWW.class... processing com/unity3d/player/a.class... processing com/unity3d/player/a$a.class... processing com/unity3d/player/b.class... processing com/unity3d/player/b$1.class... processing com/unity3d/player/b$2.class... processing com/unity3d/player/b$3.class... processing com/unity3d/player/b$4.class... processing com/unity3d/player/c.class... processing com/unity3d/player/d.class... processing com/unity3d/player/e.class... processing com/unity3d/player/f.class... processing com/unity3d/player/f$1.class... processing com/unity3d/player/g.class... processing com/unity3d/player/h.class... processing com/unity3d/player/h$1.class... processing com/unity3d/player/h$2.class... processing com/unity3d/player/h$3.class... processing com/unity3d/player/i.class... processing com/unity3d/player/i$1.class... processing com/unity3d/player/i$a.class... processing com/unity3d/player/j.class... processing com/unity3d/player/k.class... processing com/unity3d/player/l.class... processing com/unity3d/player/l$a.class... processing com/unity3d/player/m.cla","date":"2019-12-01 21:57:40","objectID":"/unity-%E6%89%93%E5%8C%85android%E6%8A%A5%E9%94%99commandinvokationfailure--unable-to-convert-classes-i/:0:0","tags":["Android","Unity"],"title":"unity-打包Android报错CommandInvokationFailure--Unable-to-convert-classes-i","uri":"/unity-%E6%89%93%E5%8C%85android%E6%8A%A5%E9%94%99commandinvokationfailure--unable-to-convert-classes-i/"},{"categories":["Unity"],"content":" 参考文章：https://blog.csdn.net/cbbbc/article/details/49275867 Editor 编辑器 Editor log can be brought up through the Open Editor Log button in Unity’s Console window. 编辑器日志，可以通过Unity的控制台窗口中Open Editor Log 按钮打开。 Mac OS X ~/Library/Logs/Unity/Editor.log Windows XP * C:\\Documents and Settings\\username\\Local Settings\\Application Data\\Unity\\Editor\\Editor.log Windows Vista/7 * C:\\Users\\username\\AppData\\Local\\Unity\\Editor\\Editor.log ","date":"2019-12-01 21:57:40","objectID":"/unity-%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E6%94%BE/:0:0","tags":["Unity"],"title":"Unity-日志文件的存放","uri":"/unity-%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E6%94%BE/"},{"categories":["Unity"],"content":"没有开抗锯齿的时候 开了抗锯齿的时候 抗锯齿选项 这里Allow MSAA选项忘了，尴尬了，这里记录下 在ios和android平台一般不要开抗锯齿，好的设备可以开2倍抗锯齿，这里没有测试 ","date":"2019-12-01 21:57:40","objectID":"/unity-%E6%A8%A1%E5%9E%8B%E6%98%BE%E7%A4%BA%E9%94%AF%E9%BD%BF%E9%97%AE%E9%A2%98/:0:0","tags":["Unity"],"title":"unity-模型显示锯齿问题","uri":"/unity-%E6%A8%A1%E5%9E%8B%E6%98%BE%E7%A4%BA%E9%94%AF%E9%BD%BF%E9%97%AE%E9%A2%98/"},{"categories":["Unity"],"content":"unity现在的版本所有资源可以手动配置AssetBundle 的Name和Variant，这里用脚本设置下 [MenuItem(\"Tools/Test1\")] public static void SetBundleName() { AssetImporter importer = AssetImporter.GetAtPath(\"assets/test.prefab\"); Debug.Log(\"assetPath:\" + importer.assetPath); Debug.Log(\"name:\" + importer.name); string bundleName = importer.assetPath.Split('.')[0].Replace(\"assets/\",string.Empty); Debug.Log(\"bundleName:\" + bundleName); importer.assetBundleName = bundleName + \".unity3d\"; importer.assetBundleVariant = \"v1\"; AssetDatabase.SaveAssets(); AssetDatabase.Refresh(); } ","date":"2019-12-01 21:57:40","objectID":"/unity-%E8%84%9A%E6%9C%AC%E8%AE%BE%E7%BD%AEassetbundlename%E5%92%8Cvariant/:0:0","tags":["Unity"],"title":"unity3d 脚本设置AssetBundle Name和Variant","uri":"/unity-%E8%84%9A%E6%9C%AC%E8%AE%BE%E7%BD%AEassetbundlename%E5%92%8Cvariant/"},{"categories":["Unity"],"content":" using UnityEditor.iOS.Xcode; 这行代码报错 UnityEditor.iOS.Xcode iOS namespace doesn’t exist 将平台切到iOS平台后就没有问题了 ","date":"2019-12-01 21:57:40","objectID":"/unityeditor-ios-xcode%E6%8A%A5%E9%94%99/:0:0","tags":["Unity","IOS","Xcode"],"title":"UnityEditor-iOS-Xcode报错","uri":"/unityeditor-ios-xcode%E6%8A%A5%E9%94%99/"},{"categories":["Unity"],"content":" 参考文章: Unity中字体名对依赖关系的影响 第一种方法是修改fontName,这种可以,亲测（导出要选择【版本重新生成】否则无效）且必须重启unity 方法一：用FontCreator修改FontName 使用了FontCreator（9.1）修改FontName，步骤如下： 1）用FontCreator打开PKCommonFont.ttf文件后，通过【字体】【属性】打开属性面板。 2）切换到【扩展】页签，修改【字体族】为“PKCommonFont（【识别】的【字体族】也可以）”。 3）导出：【文件】【导出字体为】选择TrueType字体，字体名称选择【版本重新生成】，导出 PKCommonFont2.ttf。 如果是替换字体文件则需要将meta文件中的【fontName】和【fontNames】都修改掉 这里是将字体文件对应的meta文件中的 fallbackFontReferences对应的数据改为空（这种方法有时候无效） ","date":"2019-12-01 21:57:40","objectID":"/unity%E4%B8%AD%E8%8E%B7%E5%8F%96%E4%BE%9D%E8%B5%96%E4%BF%A1%E6%81%AF%E5%87%BA%E7%8E%B0%E5%85%B6%E4%BB%96%E6%9C%AA%E5%BC%95%E7%94%A8%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98/:0:0","tags":["Unity"],"title":"Unity中获取依赖信息出现其他未引用字体问题","uri":"/unity%E4%B8%AD%E8%8E%B7%E5%8F%96%E4%BE%9D%E8%B5%96%E4%BF%A1%E6%81%AF%E5%87%BA%E7%8E%B0%E5%85%B6%E4%BB%96%E6%9C%AA%E5%BC%95%E7%94%A8%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98/"},{"categories":["Unity"],"content":"正常进: OnApplicationFocus, isFocus=True 正常退: OnApplicationQuit Home出： OnApplicationPause, isPause=True OnApplicationFocus, isFocus=False Home进： OnApplicationPause, isPause=False OnApplicationFocus, _isFocus=True Kill进程： 当前应用双击Home，然后Kill： OnApplicationQuit (IOS 有回调，android 没回调) 跳出当前应用，然后Kill： OnApplicationQuit (IOS和Android都没回调) using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.SceneManagement; public class GameApp : MonoBehaviour { void Awake() { //Debug.Log(\"awake:::::::::\"); } // Use this for initialization void Start () { } // Update is called once per frame void Update () { if (Input.GetKeyDown(KeyCode.Escape)) { Dg.Log(\"Input.GetKeyDown:::KeyCode.Escape\"); //Application.Quit(); //ProviderService.Instance.OnBackPressedE(\"KeyCode.Escape\"); } } void LateUpdate() { //Debug.Log(\"LateUpdate^^^^^^^^^^^^^\"); } void FixedUpdate() { //Debug.Log(\"FixedUpdate^^^^^^^^^^^^^\"); } void OnDestroy() { } void OnApplicationFocus(bool hasFocus) { //Dg.Log(\"OnApplicationFocus,hasFocus:\", hasFocus); } void OnApplicationPause(bool pauseStatus) { Dg.Log(\"OnApplicationPause,pauseStatus:\", pauseStatus); } void OnApplicationQuit() { Dg.Log(\"OnApplicationQuit\"); } } ","date":"2019-12-01 21:57:40","objectID":"/unity%E5%88%87%E5%85%A5%E5%90%8E%E5%8F%B0%E5%88%87%E5%85%A5%E5%89%8D%E5%8F%B0%E8%8E%B7%E5%8F%96%E7%84%A6%E7%82%B9%E5%A4%B1%E5%8E%BB%E7%84%A6%E7%82%B9%E7%AD%89/:0:0","tags":["Unity"],"title":"Unity切入后台，切入前台，获取焦点，失去焦点等","uri":"/unity%E5%88%87%E5%85%A5%E5%90%8E%E5%8F%B0%E5%88%87%E5%85%A5%E5%89%8D%E5%8F%B0%E8%8E%B7%E5%8F%96%E7%84%A6%E7%82%B9%E5%A4%B1%E5%8E%BB%E7%84%A6%E7%82%B9%E7%AD%89/"},{"categories":["Unity"],"content":" ####1.修改81-C# Script-NewBehaviourScript.cs.txt文件 打开unity安装目录对应.\\Unity\\Editor\\Data\\Resources\\ScriptTemplates\\81-C# Script-NewBehaviourScript.cs.txt文件 我的目录：C:\\Program Files\\Unity\\Editor\\Data\\Resources\\ScriptTemplates\\81-C# Script-NewBehaviourScript.cs.txt 我的文件修改如下： //===================================================== // - FileName: #SCRIPTNAME#.cs // - Created: #AuthorName# // - UserName: #CreateTime# // - Email: #AuthorEmail# // - Description: // - (C) Copyright 2008 - 2015, hehehuyu,Inc. // - All Rights Reserved. //====================================================== using System.Collections; using System.Collections.Generic; using UnityEngine; public class #SCRIPTNAME# : MonoBehaviour { // Use this for initialization void Start () { #NOTRIM# } // Update is called once per frame void Update () { #NOTRIM# } } ####2.添加脚本Copyright.cs 在工程中的Editor目录下添加脚本Copyright.cs //===================================================== // - FileName: #SCRIPTNAME#.cs // - Created: #AuthorName# // - UserName: #CreateTime# // - Email: #AuthorEmail# // - Description: // - (C) Copyright 2008 - 2015, hehehuyu,Inc. // - All Rights Reserved. //====================================================== using UnityEngine; using System.Collections; using System.IO; public class Copyright: UnityEditor.AssetModificationProcessor { private const string AuthorName=\"wangguoqing\"; private const string AuthorEmail = \"wangguoqing@hehegames.cn\"; private const string DateFormat = \"yyyy/MM/dd HH:mm:ss\"; private static void OnWillCreateAsset(string path) { path = path.Replace(\".meta\", \"\"); if (path.EndsWith(\".cs\")) { string allText = File.ReadAllText(path); allText = allText.Replace(\"#AuthorName#\", AuthorName); allText = allText.Replace(\"#AuthorEmail#\", AuthorEmail); allText = allText.Replace(\"#CreateTime#\", System.DateTime.Now.ToString(DateFormat)); File.WriteAllText(path, allText); UnityEditor.AssetDatabase.Refresh(); } } } 效果如下 参考文章：http://blog.csdn.net/u013108312/article/details/54174757 ","date":"2019-12-01 21:57:40","objectID":"/unity%E5%88%9B%E5%BB%BA%E6%96%B0%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6%E5%90%8D%E4%BD%9C%E8%80%85%E5%88%9B%E5%BB%BA%E6%97%B6%E9%97%B4%E7%AD%89/:0:0","tags":["Unity"],"title":"unity创建新脚本自动添加版权声明，文件名，作者，创建时间等","uri":"/unity%E5%88%9B%E5%BB%BA%E6%96%B0%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6%E5%90%8D%E4%BD%9C%E8%80%85%E5%88%9B%E5%BB%BA%E6%97%B6%E9%97%B4%E7%AD%89/"},{"categories":["Unity"],"content":"原生iOS常用的判断方法 iOS中判断机型的方式通常是利用屏幕分辨率，导航栏尺寸，是否支持某些功能特性等进行判断。 例如获取屏幕宽高： CGFloat screenWidth = [UIScreen mainScreen].bounds.size.width; CGFloat screenHeight = [UIScreen mainScreen].bounds.size.height; ","date":"2019-12-01 21:57:40","objectID":"/unity%E5%88%A4%E6%96%AD%E6%9C%BA%E5%9E%8B%E6%98%AF%E5%90%A6%E4%B8%BAiphonex%E7%AD%89/:1:0","tags":["Unity"],"title":"Unity判断机型是否为iPhoneX，iPhoneXS，iPhoneXR，以及iPhoneXS Max","uri":"/unity%E5%88%A4%E6%96%AD%E6%9C%BA%E5%9E%8B%E6%98%AF%E5%90%A6%E4%B8%BAiphonex%E7%AD%89/"},{"categories":["Unity"],"content":"Unity中通过device model判断 unity中通常获取iPhone设备的device model来进行机型判断，iPhoneX以后的设备判断方法如下： bool IsIphoneXDevice = false; string modelStr = SystemInfo.deviceModel; #if UNITY_IOS // iPhoneX:\"iPhone10,3\",\"iPhone10,6\" iPhoneXR:\"iPhone11,8\" iPhoneXS:\"iPhone11,2\" iPhoneXS Max:\"iPhone11,6\" IsIphoneXDevice = modelStr.Equals(\"iPhone10,3\") || modelStr.Equals(\"iPhone10,6\") || modelStr.Equals(\"iPhone11,8\") || modelStr.Equals(\"iPhone11,2\") || modelStr.Equals(\"iPhone11,6\"); #endif ","date":"2019-12-01 21:57:40","objectID":"/unity%E5%88%A4%E6%96%AD%E6%9C%BA%E5%9E%8B%E6%98%AF%E5%90%A6%E4%B8%BAiphonex%E7%AD%89/:2:0","tags":["Unity"],"title":"Unity判断机型是否为iPhoneX，iPhoneXS，iPhoneXR，以及iPhoneXS Max","uri":"/unity%E5%88%A4%E6%96%AD%E6%9C%BA%E5%9E%8B%E6%98%AF%E5%90%A6%E4%B8%BAiphonex%E7%AD%89/"},{"categories":["Unity"],"content":"不同机型对应的model如下： iPhoneX: “iPhone10,3”, “iPhone10,6” iPhoneXR: “iPhone11,8” iPhoneXS: “iPhone11,2” iPhoneXS Max: “iPhone11,6” 维基百科中有最新的iPhone设备model表可查看： https://www.theiphonewiki.com/wiki/Models 参考文章： 原文：https://blog.csdn.net/cordova/article/details/82945154 ","date":"2019-12-01 21:57:40","objectID":"/unity%E5%88%A4%E6%96%AD%E6%9C%BA%E5%9E%8B%E6%98%AF%E5%90%A6%E4%B8%BAiphonex%E7%AD%89/:2:1","tags":["Unity"],"title":"Unity判断机型是否为iPhoneX，iPhoneXS，iPhoneXR，以及iPhoneXS Max","uri":"/unity%E5%88%A4%E6%96%AD%E6%9C%BA%E5%9E%8B%E6%98%AF%E5%90%A6%E4%B8%BAiphonex%E7%AD%89/"},{"categories":["Unity"],"content":" 加载场景需要引入UnityEngine.SceneManagement这个命名空间，使用类SceneManager. 这里说明下基本的代码加载机制，正常是要在场景加载完成后的Awake或者Start等方法去执行场景业务初始化。 //异步加载场景 public static AsyncOperation LoadSceneAsync(string sceneName, LoadSceneMode mode); 异步加载后执行后面代码时，是在执行完场景中所有Awake方法且没有执行Start的时候 //同步加载场景 public static void LoadScene(string sceneName, LoadSceneMode mode); 同步加载后执行后面代码时，是在场景中所有Awake方法没有执行的时候调用的，且使用GameObject.Find(“Game”)方法是找不到场景中该物体的，但是场景中本身有该物体 脚本： using UnityEngine; using System.Collections; using System.Collections.Generic; #if UNITY_EDITOR using UnityEditor; #endif using System; using System.IO; using System.Text; using Object = UnityEngine.Object; using UnityEngine.SceneManagement; public class AssetLoader : MonoBehaviour { public static AssetLoader Instance { get; private set; } void Awake() { Instance=this; } /// \u003csummary\u003e /// 同步加载场景 /// 说明：执行该方法后在后面直接使用GameObject.Find(\"Game\"),是找不到对应物体的，需要加载完场景后场景的Awake执行后才能Find到物体 /// \u003c/summary\u003e /// \u003cparam name=\"sceneName\"\u003e场景名\u003c/param\u003e /// \u003cparam name=\"isAdditive\"\u003e是否叠加场景\u003c/param\u003e public static void LoadSceneSync(string sceneName,bool isAdditive=false) { SceneManager.LoadScene(sceneName); } /// \u003csummary\u003e /// 异步加载场景 /// action调用的时候是在场景加载完成且场景所有的Awake执行完后调用（Start还没有执行的时候） /// \u003c/summary\u003e /// \u003cparam name=\"sceneName\"\u003e场景名\u003c/param\u003e /// \u003cparam name=\"action\"\u003e加载完成回调\u003c/param\u003e /// \u003cparam name=\"isAdditive\"\u003e是否叠加场景\u003c/param\u003e public static void LoadSceneAsync(string sceneName,Action action,bool isAdditive=false) { Instance.InnerLoadSceneAsync(sceneName, action, isAdditive); } private void InnerLoadSceneAsync(string sceneName, Action action, bool isAdditive) { StartCoroutine(LoadLeveAsync(sceneName, action, isAdditive)); } private IEnumerator LoadLeveAsync(string sceneName, Action action, bool isAdditive) { LoadSceneMode mode = isAdditive ? LoadSceneMode.Additive : LoadSceneMode.Single; yield return SceneManager.LoadSceneAsync(sceneName, mode); if (!isAdditive) GC.Collect(); action(); } } ","date":"2019-12-01 21:57:40","objectID":"/unity%E5%8A%A0%E8%BD%BD%E5%9C%BA%E6%99%AF/:0:0","tags":["Unity"],"title":"Unity加载场景","uri":"/unity%E5%8A%A0%E8%BD%BD%E5%9C%BA%E6%99%AF/"},{"categories":["Unity"],"content":"发布android包时 armeabi文件夹下的so静态库打包不进去（unity版本：unity5.6.0f3） 检查so文件对应的meta文件 fileFormatVersion: 2 guid: 4df0d61d0843d4914a5dcd11225fdd84 timeCreated: 1513074069 licenseType: Pro PluginImporter: serializedVersion: 2 iconMap: {} executionOrder: {} isPreloaded: 0 isOverridable: 0 platformData: data: first: Android: Android second: enabled: 0 settings: {} data: first: Any: second: enabled: 0 settings: {} data: first: Editor: Editor second: enabled: 0 settings: DefaultValueInitialized: true userData: assetBundleName: assetBundleVariant: 能打包so静态库到包里面的meta文件配置 fileFormatVersion: 2 guid: d942bd3bc664af74a902489cf22548ed timeCreated: 1513426642 licenseType: Pro PluginImporter: serializedVersion: 2 iconMap: {} executionOrder: {} isPreloaded: 0 isOverridable: 0 platformData: data: first: Android: Android second: enabled: 1 settings: CPU: ARMv7 data: first: Any: second: enabled: 0 settings: {} data: first: Editor: Editor second: enabled: 0 settings: DefaultValueInitialized: true userData: assetBundleName: assetBundleVariant: 在CPU选项选择ARMv7后我的meta文件的CPU对应数据是空的(上面的数据是对的，可以和自己的对比下)，但是界面显示 所以有时候unity 的meta文件和unity工程打开的显示不一样，打包的时候以meta信息为主。 应该是unity的bug ","date":"2019-12-01 21:57:40","objectID":"/unity%E5%8F%91%E5%B8%83android%E7%89%88%E6%9C%AC-so%E9%9D%99%E6%80%81%E5%BA%93%E6%89%93%E4%B8%8D%E8%BF%9B%E5%8E%BB/:0:0","tags":["Unity","Android"],"title":"unity发布android版本-so静态库打不进去","uri":"/unity%E5%8F%91%E5%B8%83android%E7%89%88%E6%9C%AC-so%E9%9D%99%E6%80%81%E5%BA%93%E6%89%93%E4%B8%8D%E8%BF%9B%E5%8E%BB/"},{"categories":["Unity"],"content":" public String ApplinkUrl=null; public void BroadcastApplinkUrl(String linkUrl) { Log.i(AppPackName,\"BroadcastApplinkUrl::linkUrl:\"+linkUrl); //linkUrl 不能传null，否则崩溃 UnityPlayer.UnitySendMessage(GameObjectName, ApplinkMethodName, linkUrl); } @Override protected void onNewIntent(Intent intent) { super.onNewIntent(intent); setIntent(intent); Uri uri = getIntent().getData(); if(uri!=null) { BroadcastApplinkUrl(uri.toString()); } else { BroadcastApplinkUrl(\"\"); } } UnityPlayer.UnitySendMessage(GameObjectName, ApplinkMethodName, linkUrl); 在linkUrl这个参数传null的情况下，直接崩溃,这里做下记录 ","date":"2019-12-01 21:57:40","objectID":"/unity%E5%92%8Candroid%E4%BA%A4%E4%BA%92bug/:0:0","tags":["Unity","Android"],"title":"unity和android交互bug","uri":"/unity%E5%92%8Candroid%E4%BA%A4%E4%BA%92bug/"},{"categories":["Unity"],"content":"修复方法 id不能直接返回，必须分配内存 #import \"IosTools.h\" #if defined (__cplusplus) extern \"C\" { #endif //char*分配内存 char* StringCopy (const char* string) { if (string == NULL) return NULL; char* res = (char*)malloc(strlen(string) + 1); strcpy(res, string); return res; } //获取imei，id不能直接返回，必须分配内存 char* GetImei () { NSLog(@\"GetImei\"); NSString *uuid = [[[UIDevice currentDevice] identifierForVendor] UUIDString]; char* id=[uuid UTF8String]; NSLog(@\"GetImei1111\"); return StringCopy(id); } #if defined (__cplusplus) } #endif ","date":"2019-12-01 21:57:40","objectID":"/unity%E5%92%8Cios%E4%BA%A4%E4%BA%92char-%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%80%BC%E5%88%B0csharp%E4%B8%ADbug/:0:0","tags":["Unity","IOS"],"title":"Unity和IOS交互char-作为方法返回值到C#中bug","uri":"/unity%E5%92%8Cios%E4%BA%A4%E4%BA%92char-%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%80%BC%E5%88%B0csharp%E4%B8%ADbug/"},{"categories":["Unity","笔记"],"content":" 接口interface 继承测试，使用struct或者class继承interface，struct是否会出现装箱问题 ","date":"2019-12-01 21:57:40","objectID":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:0:0","tags":["Unity"],"title":"unity性能优化笔记","uri":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","笔记"],"content":"基本优化 控制帧率，在非操作和没有特效播放时可以降低帧率（有效控制部分发热） 降低分辨率 缓存池的应用（资源缓存和class对象缓存），使用引用计数，定期调用 UnloadUnusedAssets 原生层和热更层互相调用应该减少在update中每一帧调用 ","date":"2019-12-01 21:57:40","objectID":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:0:1","tags":["Unity"],"title":"unity性能优化笔记","uri":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","笔记"],"content":"一、内存的优化： Unity中的内存种类 实际上Unity游戏使用的内存一共有三种：程序代码、托管堆（Managed Heap）以及本机堆（Native Heap）。 优化程序代码的内存占用 API兼容性级别选择.net2.0子集（不需要Unity将全部.NET的Api包含进去） 剥离级别选择剥离字符集（示从build的库中剥离的力度，每一个剥离选项都将从打包好的库中去掉一部分） 托管堆优化 参照程序代码优化 本机堆的优化 纹理 使用png格式 关闭纹理资源的read/write功能（增加1倍） ui不适用mipmap（增加1/3） 非二次幂的纹理（不压缩 ，ui图集，可以是非正方形） Ui的背景可以适当选用1024 Android平台贴图压缩用etc2 8bit，占用原来的1/4内存（etc 8bit注意下） Ios平台贴图压缩用astc 4x4 block(也可用astc6x6) 占用原来的1/4内存（不要求正方形也不要求2的幂次方，建议2的幂次方）（全部opengl es 3.1支持astc ios和android）（ 如果是pvrtc 则还得必须是正方形 1/8）,法线需要更高的精度，要避免压缩纹理导致的失真。 压缩贴图的话贴图本身必须是二次幂的 光照贴图和shadowmask图的压缩纹理选项。ios下可以统一使用astc6x6。android下shadowmask图使用rgb16，否则阴影会有明显的模糊或者锯齿。lightmap图倒是没有太大限制，尽量使用压缩纹理即可。 音频 背景音乐使用压缩的ogg或者mp3，像攻击音效等使用wav 背景音乐等长的音频使用在内存中压缩(Compressed in memory，Streaming)的加载类型 攻击音效等短的音频使用加载时解压(Decompress on load)的加载类型 加载时解压是在内存中压缩的10倍内存 网格 模型资源不要开启read/write 使用 Mesh Compression 压缩网格（在个别特殊情况，mesh压缩和动画压缩后可能出现动画抖动的情况，这个时候不能压缩了） 不要使用自带的球体网格，面数太多 动画（animator） 动画压缩 一个角色有多个动画的情况下，单独导出一份角色的骨骼，角色导出的多个动画不用带骨骼 其他 导出的配置的格式是数组结构，不是key value结构。通过给每个条目设置metatable，业务层同样可以用key来访问对应的数据。这样可以节省一半以上的内存。 将配置存为二进制文件，文本文件占用空间大 注意Shader变体的数量，Shader Lab内存； 游戏中大量的数据导出配置尽量使用untiy内置的Asset管理，效率很高 ","date":"2019-12-01 21:57:40","objectID":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:0:2","tags":["Unity"],"title":"unity性能优化笔记","uri":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","笔记"],"content":"二、CPU的方面的优化： Drawcall： Drawcall是啥？其实就是对底层图形程序（比如：OpenGL ES)接口的调用，以在屏幕上画出东西。 DrawCall如何优化： 使用Draw Call Batching，也就是描绘调用批处理。Unity在运行时可以将一些物体进行合并，从而用一个描绘调用来渲染他们。 静态批处理Static Batching，只要是静态不动的物体且具有相同材质的话就可以使用静态批处理来降低描绘调用（注：shader不同则会增加纹理的拼合降低渲染效率） 要勾选StaticBatch，但是不能滥用。有color、uv3的，顶点超过4000个以上的，数量超多，但是同屏显示不多的模型。这些都不应该勾选StaticBatch。否则会导致包体积明显增大。因为StaticBatch会把模型都build到场景的ab包内。 动态批处理Dynamic Batching：动态批处理是引擎自动进行，无需设置，当物体共享相同的材质，则引擎就会自动对Drawcall进行优化，也就是动态批处理（如实例化预制件）。动态批处理存在约束，稍有不慎就会增加Drawcall 动态批处理的约束： 1、批处理动态物体需要在每个顶点上进行一定的开销，所以动态批处理仅支持小于900顶点的网格物体。 2、如果你的着色器使用顶点位置，法线和UV值三种属性，那么你只能批处理300顶点以下的物体；如果你的着色器需要使用顶点位置，法线，UV0，UV1和切向量，那你只能批处理180顶点以下的物体。 3、不要使用缩放。分别拥有缩放大小(1,1,1) 和(2,2,2)的两个物体将不会进行批处理。 4、统一缩放的物体不会与非统一缩放的物体进行批处理。 5、使用缩放尺度(1,1,1) 和 (1,2,1)的两个物体将不会进行批处理，但是使用缩放尺度(1,2,1) 和(1,3,1)的两个物体将可以进行批处理。 6、使用不同材质的实例化物体（instance）将会导致批处理失败。 7、拥有lightmap的物体含有额外（隐藏）的材质属性，比如：lightmap的偏移和缩放系数等。所以，拥有lightmap的物体将不会进行批处理（除非他们指向lightmap的同一部分）。 8、多通道的shader会妨碍批处理操作。比如，几乎unity中所有的着色器在前向渲染中都支持多个光源，并为它们有效地开辟多个通道。 9、预设体的实例会自动地使用相同的网格模型和材质。 所以尽量使用静态批处理。 打包图集 使用共享材质 保持材质的数目尽可能少，更大程度的批处理 使用光照贴图(lightmap)而非实时灯光 使用LOD，好处就是对那些离得远，看不清的物体的细节可以忽略。 遮挡剔除（Occlusion culling） 利用网格的顶点数据（两个模型用了同一个材质为了不同但是之前用的两个材质多少有点不同，例如两棵树的颜色不同） 尽量少的使用反光啦，阴影啦之类的，因为那会使物体多次渲染 脚本动态合并mesh 尽量使用GPU Instanc URP使用SRPBatcher 物理组件： 1）设置较大的Fixed timestep，减少物理计算次数，提高游戏性能。 2）设置fps在60帧左右（Application.targetFrameRate = 60;），关闭垂直同步 ，设置帧率及使用相关帧率优化方案，在玩家不操作时降低帧率，操作时恢复帧率 优点：1.省电，减少手机发热的情况；2.能都稳定游戏FPS，减少出现卡顿的情况。 3）尽量不用MeshCollider 4）粒子组件，屏幕上最大粒子数量建议小于200个，粒子应尽可能的小，关闭粒子的碰撞功能。 5）真实物理（刚体）很消耗，不要轻易使用，尽量使用自己的代码模拟 6）对于投射物不要使用真实物理碰撞和刚体，自己模拟 ","date":"2019-12-01 21:57:40","objectID":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:0:3","tags":["Unity"],"title":"unity性能优化笔记","uri":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","笔记"],"content":"三、GPU的优化 顶点优化（减少顶点数量） 优化几何体 使用模型lod（Level of Detail）技术（unity中使用LOD Group组件） 使用遮挡剔除（Occlusion Culling）技术 使用mesh压缩 片元优化（减少片元数量）（减少overdraw，overdraw指的就是一个像素被绘制了多次。透明物体） overdraw的视图 控制绘制顺序 2.1 在Unity中，那些Shader中被设置为“Geometry” 队列的对象总是从前往后绘制的，而其他固定队列（如“Transparent”“Overla”等）的物体，则都是从后往前绘制的。这意味这，我们可以尽量把物体的队列设置为“Geometry” 。而且，我们还可以充分利用Unity的队列来控制绘制顺序。例如，对于天空盒子来说，它几乎覆盖了所有的像素，而且我们知道它永远会在所有物体的后面，因此它的队列可以设置为“Geometry+1”。这样，就可以保证不会因为它而造成overdraws。 时刻警惕透明物体 3.1 因此，如果场景中大面积的透明对象，或者有很多层覆盖的多层透明对象（即便它们每个的面积可以都不大），或者是透明的粒子效果，在移动设备上也会造成大量的overdraws。这是应该尽量避免的 减少实时光照和阴影 4.1 实时光照对于移动平台是个非常昂贵的操作。如果只有一个平行光还好，但如果场景中包含了太多光源并且使用了很多多Passes的shader，那么很有可能会造成性能下降。而且在有些机器上，还要面临shader失效的风险。例如，一个场景里如果包含了三个逐像素的点光源，而且使用了逐像素的shader，那么很有可能将Draw Calls提高了三倍，同时也会增加overdraws。这是因为，对于逐像素的光源来说，被这些光源照亮的物体要被再渲染一次。更糟糕的是，无论是动态批处理还是动态批处理（其实文档中只提到了对动态批处理的影响，但不知道为什么实验结果对静态批处理也没有用），对于这种逐像素的pass都无法进行批处理，也就是说，它们会中断批处理。 4.2 使用Lightmaps和light probe（光照探针） 减少使用法线贴图（或者在角色身上使用），静态物体尽量不要用，而是将法线渲染到贴图上 尽量不使用fog雾效，或者使用简单的后处理雾效或者渐变的面片（参考shadow gun） 尽量减少alpha test的使用 减少计算复杂度 使用Shader的LOD技术 设置Shader.maximumLDO或者Shader.globalMaximumLOD来允许最大的LOD Shader代码优化 把高斯模糊和边缘计算计算放到顶点shader中 float存储顶点坐标等变量，half存储一些标量和纹理坐标等信息，fixed适用于大多数颜色变量和归一化的方向矢量 减少pow，sin，cos等函数使用 后处理时，降低分辨率采样 其他优化 使用Mobile版本的shader。比如Particle/Additive中有ColorMask，这个在移动平台比较耗。 避免使用昂贵的数学函数。比如 pow exp log cos sin tan 等 尽可能减少纹理采样数目。 比如roughness和metal贴图合并成一张贴图 如果有一些计算比较复杂，可以使用查找纹理（lut） 优先使用低精度的数字格式。优先使用half。在现代gpu上fixed等同于half。 部分对精度有特殊需求的情况下才使用float。个别情况下，尤其是与法线相关的时候，使用half容易因为精度不足导致渲染结果错误，这个时候还是应该使用float。 ","date":"2019-12-01 21:57:40","objectID":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:0:4","tags":["Unity"],"title":"unity性能优化笔记","uri":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","笔记"],"content":"优化内存带宽： 1 减少纹理大小（压缩纹理，使用mipmap，mipmap图片渲染的质量比压缩要好）） 2 使用mipmap。 Mipmap中每一个层级的小图都是主图的一个特定比例的缩小细节的复制品。因为存了主图和它的那些缩小的复制品，所以内存占用会比之前大。但是为何又优化了显存带宽呢？因为可以根据实际情况，选择适合的小图来渲染。所以，虽然会消耗一些内存，但是为了图片渲染的质量（比压缩要好），这种方式也是推荐的。 3 纹理压缩（ETC2 8bit，ASTC 4x4 block，PVRTC） 4 降低分辨率尤其是在android平台上，有效缓解GPU压力（实际分辨率*0.85左右）,Screen.SetResolution 5 关闭图片ReadWrite 6 尽量提高GPU缓存命中率 ","date":"2019-12-01 21:57:40","objectID":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:0:5","tags":["Unity"],"title":"unity性能优化笔记","uri":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","笔记"],"content":"UI优化 主要思想：动静分离；降低drawcall fillcenter 动静网格分离（通过增加canvas） 修改image的color会造成canvas.rebuildbatch 如果是颜色动画可以但是单独创建一个material 直接修改color，不会rebuild（动静网格分离） EventSystem.Update（）消耗大 ，raycasttarget 关掉，分离canvas，需要的挂上GraphicRaycaster 图片如果是左右对称和上下对称可以使用mirrorImage类似的自定义Image组件，使用原始Sprite图片的四分之或者二分之一即可 图集尽量根据业务去划分 玩家头顶血条的HUD要使用3D的，而不是UGUI。否则同屏玩家数量很多的时候Mesh合并开销很大（大概率没帧刷新）。 UI上使用TextMeshPro。可以很大程度上缓解UI打开卡顿的问题。描边、阴影开销很低（如果是多语言支持的话可能比较麻烦，需要提前将字体库制作成TextMeshPro内置的库，不便通用）。 使用TextMeshPro。减少GC，减少字体生成的开销。字体放大缩小依然保持锐利清晰。 写一个UICollider而不是透明的Image，可以减少overdraw 小地图用shader实现指定位置的图片渲染，而不是RectMask2D，可以减少overdraw。因为RectMask2D是使用alpha=0来实现裁剪的。 血条的减少动画之前是Image和DOTween来实现的。后面修改为shader实现。(坐标计算) 战斗飘字，原先是DOTween来实现的，后面修改为直接在Update里面计算坐标。目的是减少DOTween动画初始化的GC开销。自己实现简化版的动画，性能也更好一些；终极优化是在shader中实现且飘字使用GPU Instance（自动计算mesh且调用DrawMesh接口绘制）。 使用SimpleAnimationComponent 来做UI动画，而不直接使用Animator。因为Animator在动画播放完毕之后，依然会Update。这会导致两个问题，一个是性能隐患，另外一个是被动画控制的控件无法再通过代码设置位置。在动画播放完毕之后再禁用动画组件，实现起来比较复杂。相比而言，直接使用SimpleAnimationComponent就要简单干净很多，也更加高效。 禁用不必要的raycastTarget。 实现一个UICircleImage来替代用Mask实现的圆形遮罩裁剪。一般64个点就可以形成圆形。外部再罩一个边框图，就可以消除边缘锯齿。 ","date":"2019-12-01 21:57:40","objectID":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:0:6","tags":["Unity"],"title":"unity性能优化笔记","uri":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","笔记"],"content":"程序代码优化 删除空的脚本和不需要的默认方法（例如Update，Start） 避免使用OnGUI 同一脚本中频繁使用的变量建议声明全局变量 数组，集合类元素优先使用Array，其次是Queue/Stack,再次是List 合理的设置容器的初始化Capacity 应尽量为类或函数声明为sealed，变虚函数为直接函数调用 尽量减少闭包的使用 减少装箱和拆箱操作 减少Dictionary冗余操作 脚本在不使用时禁用，使用时启用 应减少不必要的Transform.position/rotation等访问 减少除法运算，例如a/5f,可以写成a*0.2f； 尽量直接声明脚本变量，而不是用Getcomponent来获取脚本组件 使用各种类的对象池和物体实例化池 减少使用sin，cos，pow等三角函数，如果使用量大则建议使用查表法来优化三角函数的计算量 尽量不要在Update中做复杂的计算，如果有需要在隔几帧计算一次 不要动态的生产字符串，例如使用Debug.Log（“a”+“b”），尽量预先创建好字符串资源，还有一个打印变量时不要用+号去链接也不要用$符去格式化，而是用Debug.logFormat去输出，这样关闭Debug时就能关闭和Debug输出相关的动态字符串 应使用支持[Conditional(“DEBUG”)]的日志输出机制，支持log关闭 不要直接访问gameobject的tag属性(可以用if (go.CompareTag (“human”))， 因为访问物体的tag属性会在堆上额外的分配空间) String拼接时尽量使用System.Text.StringBuilder代替 避免频繁调用GameObject.SetActive 减少material频繁的set参数，如果量大，则使用字符串key获取唯一id 使用同一的CoroutineManager而不是直接用MonoBehaviour的StartCoroutine，可以提高性能。 在每帧执行的代码中，尽可能避免闭包。减少匿名方法。这些可能会产生GCAlloc 避免使用枚举作为字典的key。会有装箱操作。原因是enum为值类型，Dictionary实现会调用Object.getHashCode获取key的哈希代码，这里期望的是引用类型。（可以考虑强制转换为int即可。或者实现一个 IEqualityComparer。） 慎用 mesh.vertices 等接口。它每次调用都会生成一个新的内存副本。同理 Input.touches类似。 foreach与for相比还是有性能差距。所以在调用不频繁的地方，可以使用foreach以提高可读性。频繁调用的地方还是推荐直接用for进行遍历。 C#的string是不可变的，任何SubSting等操作都会产生新的副本。 按ID寻址属性。比如 Animator、Shader都有对应的接口。Animator.StringToHash。Shader.PropertyToID。 使用非分配物理API。替换Physics.RaycastAll为Physics.RaycastNonAlloc等,当然能不用Raycast最好（例如地面时平的想知道点击屏幕位置对应的地面位置，则可以通过线与面相交计算出位置）。 尽可能减少 Camera.,main 的调用。它内部会调用 Object.FindObjectWithTag。在Start中进行缓存。 不要用 type[x, y] 这样的多维数组。性能很低。 合理使用C#的委托。每次添加或者删除回调的时候，C#的委托都会执行回调列表的完整拷贝。所以不要在Update中进行委托的添加或者删除回调的操作。如果有频繁添加的需求，可以考虑使用List维护回调数组而不是委托。 手工编码的 String.StartsWithFast 会比内置方法快 10~100倍。 Vector3.zero 会返回一个新的Vector3对象。虽然因为其是值类型，远比引用类型性能要高。但是频繁调用的地方还是应该维护一个const的对象用来进行比对或者赋值。 更新材质属性的时候，使用MaterialPropertyBlock。性能更好。且可以避免实例化一份新的材质对象。而且GPU Instance支持使用MaterialPropertyBlock AlphaBlend会比AlphaTest性能要好一些。因为移动平台的GPU会有EarlyZ的优化，而AlphaTest会使EarlyZ无效。 使用SimpleAnimationComponent来替代Unity的Animator来做UI动画。主要是Animator会一直更新，即便动画已经播放完毕了。这个一方面会有性能问题，另外一方面被动画驱动的控件无法再通过脚本移动。 ","date":"2019-12-01 21:57:40","objectID":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:0:7","tags":["Unity"],"title":"unity性能优化笔记","uri":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","笔记"],"content":"资源规范： 建筑升级的资源是拼接的（节省内存） 模型角色高模 6000+面，低模 3000面。顶点数不定，因为顶点存在共用的情况，所以顶点数量可能是面数的两倍，也可能比面数低。纹理使用1024大小的贴图。低模纹理大小减半。主角因为有高低模，所以不开mipmap。个别精度比较高的npc（有UI显示需求）需要开mipmap，否则场景中会有明显的闪烁。 不使用大的prefab 增加io的负担（多棵草做一个prefab） 每个模型只使用一个skinned mesh renderer 每个mesh不要超过2个material 骨骼数量不要超过30 场景的面数在100k~300k之间都是合理的数值（手游一般是100k同屏）。 ","date":"2019-12-01 21:57:40","objectID":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:0:8","tags":["Unity"],"title":"unity性能优化笔记","uri":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","笔记"],"content":"打包和资源加载 BuildPipeline.BuildPlayer(BuildConfig.scenes, outputPath, target, buildOptions); BuildPipeline.BuildAssetBundles(rABPath, rOptions, (BuildTarget)CurBuildPlatform); (BuildAssetBundleOptions.DeterministicAssetBundle | BuildAssetBundleOptions. ChunkBasedCompression) UnityEditor.U2D.SpriteAtlasUtility.PackAllAtlases(EditorUserBuildSettings. activeBuildTarget); 打包使用LZ4格式压缩，压缩比1:3;LZMA 压缩比1:4。 ","date":"2019-12-01 21:57:40","objectID":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:0:9","tags":["Unity"],"title":"unity性能优化笔记","uri":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","笔记"],"content":"模型方面 合并使用同贴图的材质球，合并使用相同材质球的Mesh； 角色的贴图和材质球只要一个，若必须多个则将模型离分离为多个部分； 骨骼系统不要使用太多，骨骼数量不要超过30； 当使用多角色时，将动画单独分离出来；如果角色有多个动画，则将骨骼分离出来，导出动画不要带骨骼； 使用层距离来控制模型的显示距离； 阴影其实包含两方面阴暗和影子，建议使用实时影子时把阴暗效果烘焙出来，不要使用灯光来调节光线阴暗。 少用像素灯和使用像素灯的Shader； 如果硬阴影可以解决问题就不要用软阴影，并且使用不影响效果的低分辨率阴影； 实时阴影很耗性能，尽量减小产生阴影的距离； 允许的话在大场景中使用线性雾，这样可以使远距离对象或阴影不易察觉，因此可以通过减小相机和阴影距离来提高性能； 使用圆滑组来尽量减少模型的面数； 项目中如果没有灯光或对象在移动那么就不要使用实时灯光； 水面、镜子等实时反射/折射的效果单独放在Water图层中，并且根据其实时反射/折射的范围来调整； 碰撞对效率的影响很小，但碰撞还是建议使用Box、Sphere碰撞体； 建材质球时尽量考虑使用Substance； 尽量将所有的实时反射/折射（如水面、镜子、地板等等）都集合成一个面； 假反射/折射没有必要使用过大分辨率，一般6464就可以，不建议超过256256； 需要更改的材质球，建议实例化一个，而不是使用公共的材质球； 将不须射线或碰撞事件的对象置于IgnoreRaycast图层； 将水面或类似效果置于Water图层 将透明通道的对象置于TransparentFX图层； 养成良好的标签（Tags）、层次（Hieratchy）和图层（Layer）的条理化习惯，将不同的对象置于不同的标签或图层，三者有效的结合将很方便的按名称、类别和属性来查找； 通过Stats和Profile查看对效率影响最大的方面或对象，或者使用禁用部分模型的方式查看问题到底在哪儿； 使用遮挡剔除（Occlusion Culling）处理大场景，一种较原生的类LOD技术，并且能够“分割”作为整体的一个模型。 ","date":"2019-12-01 21:57:40","objectID":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:0:10","tags":["Unity"],"title":"unity性能优化笔记","uri":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","笔记"],"content":"Unity优化工具 MAT（Memory Analyzer Tool） 需要导入HPROF文件再分析 只能查看java层的内存情况，看不到native堆的详情 Xcode Instrument工具 只能用于Mac,iOS 只能查看C++ 或 object C 的情况，看不到mono堆的详情 Unity自带Profiler 需要单独编译develop版本 在PC上执行，没法捕获真机数据 内存数据跟实际真机的数据差异很大、多的时候有几十M差距 只能看到最近一段时间的数据，看不到总体的详情（Unity的Profiler不会跟踪主线程之外的GCAlloc分配。如果在子线程需要进行分析，可以考虑把子线程切换的主线程进行调试，或者使用功能BeginThreadProfiling API）。 官方开源Memory Profiler （使用IL2CPP，构建时开启Development Build） UWA WeTest PerfDog 性能狗 RenderDoc Snapdragon Profiler 骁龙分析工具 Snapdragon Profiler工具简介 Download Snapdragon Profiler snapdragon和renderdoc Intel GPA Download Intel GPA 使用Intel GPA在PC上分析Android游戏的渲染流程 Miku-LuaProfiler 端游游戏，考虑使用的工具有NSight，Intel GPA，RenderDoc 手机真机分析可以根据不同厂商的GPU SDK选择对应的软件。比如高通骁龙手机可以选用SnapDragon Debugger，Mali手机可以选用Mali.Graphic Debugger，NVIDA Tegra的手机可以选用Tegra Debugger等等。如果都没有，那么RenderDoc. 加载类型(Load Type)： 运行时Unity加载音频的方法。 加载时解压缩(Decompress on load): 加载后解压缩声音。使用于较小的压缩声音，以避免运行时解压缩的性能开销。(将使用比在它们在内存中压缩的多10倍或更多内存，因此大文件不要使用这个。) 在内存中压缩(Compressed in memory): 保持声音在内存中（压缩的）在播放时解压缩。这有轻微的性能开销（尤其是OGG / Vorbis格式的压缩文件），因此大文件使用这个。 从磁盘流(Stream from disc): 直接从磁盘流读取音频数据。这只使用了原始声音占内存大小的很小一部分。使用这个用于很长的音乐。取决于硬件，一般建议1-2线程同时流。 Audio Source 优化 Short Clips – Native Longer (or looping) clips – compressed in memory Music – Stream from disc Files which consistently cause CPU spikes – Decompress on load Ui动画：帧动画、Animation、脚本动画 参考： https://zhuanlan.zhihu.com/p/157877557 https://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html https://docs.unity3d.com/353/Documentation/Manual/iphone-Optimizing-Scripts.html ","date":"2019-12-01 21:57:40","objectID":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:0:11","tags":["Unity"],"title":"unity性能优化笔记","uri":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","笔记"],"content":"具体性能优化 https://docs.unity3d.com/cn/2021.1/Manual/BestPracticeUnderstandingPerformanceInUnity.html Unity版本：Unity2021.2.16f1c1 ","date":"2019-12-01 21:57:40","objectID":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:1:0","tags":["Unity"],"title":"unity性能优化笔记","uri":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","笔记"],"content":"默认新建对象操作的Unity API 使用public static Touch GetTouch(int index) 这些属性在get的时候 Unity API会返回一个新的对象，每次调用都会返回新的对象，造成GC ","date":"2019-12-01 21:57:40","objectID":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:1:1","tags":["Unity"],"title":"unity性能优化笔记","uri":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","笔记"],"content":"enum枚举作为Dictionary的键时，产生装箱 https://docs.unity3d.com/cn/2021.1/Manual/BestPracticeUnderstandingPerformanceInUnity4-1.html ","date":"2019-12-01 21:57:40","objectID":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:1:2","tags":["Unity"],"title":"unity性能优化笔记","uri":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","笔记"],"content":"闭包和匿名方法 ","date":"2019-12-01 21:57:40","objectID":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:1:3","tags":["Unity"],"title":"unity性能优化笔记","uri":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","笔记"],"content":"集合和数组重用 使用 C# 的集合类或数组时，尽可能考虑重用或汇集已分配的集合或数组。集合类开放了一个 Clear 方法，该方法会消除集合内的值，但不会释放分配给集合的内存。 ","date":"2019-12-01 21:57:40","objectID":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:1:4","tags":["Unity"],"title":"unity性能优化笔记","uri":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","笔记"],"content":"方便可变参数（params） 可变参数的数组会有GC开销 测试代码 GCTest.cs const string str1 = \"anyvalue=1\"; const string str2 = \"anyvalue=2\"; const string str3 = \"anyvalue=3\"; // Update is called once per frame void Update() { UnityEngine.Profiling.Profiler.BeginSample(str1); anyValue(); UnityEngine.Profiling.Profiler.EndSample(); UnityEngine.Profiling.Profiler.BeginSample(str2); anyValue(1,1,2,3,4,5); UnityEngine.Profiling.Profiler.EndSample(); UnityEngine.Profiling.Profiler.BeginSample(str3); anyValue1(1, 1, 2, 3, 4, 5); UnityEngine.Profiling.Profiler.EndSample(); } void anyValue(params int[] arr){} void anyValue1(int a,int b,int c,int d,int e,int f){} ","date":"2019-12-01 21:57:40","objectID":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:1:5","tags":["Unity"],"title":"unity性能优化笔记","uri":"/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity"],"content":" IEnumerator CoroutineScreenShot(System.Action action) { //ReadPixels was called to read pixels from system frame buffer, while not inside drawing frame. yield return new WaitForEndOfFrame(); byte[] data = CaptureScreenshot(); CacheUtil.WriteSync(ScreenshotPath,data); if(action!=null) action(); yield break; } /// \u003csummary\u003e /// 截图 /// \u003c/summary\u003e public void SahreCaptureScreenshot() { Dg.Log(\"SaveCaptureScreenshot:\", ScreenshotPath); StartCoroutine(CoroutineScreenShot(() =\u003e { })); } 屏幕截图时需要在协程中执行，且必须有yield return new WaitForEndOfFrame();，否则报错:ReadPixels was called to read pixels from system frame buffer, while not inside drawing frame. ","date":"2019-12-01 21:57:40","objectID":"/unity%E6%88%AA%E5%B1%8F/:0:0","tags":["Unity"],"title":"Unity截屏","uri":"/unity%E6%88%AA%E5%B1%8F/"},{"categories":["other"],"content":"渲染更新每帧纹理后，unity不重新绘制，暂时用每帧移动物体来屏蔽 //===================================================== // - FileName: AgoraDraw // - Description: // - Author: wangguoqing // - Email: wangguoqing@hehemj.com // - Created: 2018/1/4 11:30:06 // - CLR version: 4.0.30319.42000 // - UserName: Wang // - (C) Copyright 2008 - 2015, hehehuyu,Inc. // - All Rights Reserved. //====================================================== //using System; using UnityEngine; using UnityEngine.UI; using System.Collections.Generic; using System.Text; using agora_gaming_rtc; public class AgoraDraw : MonoBehaviour { public delegate void AdjustTransfromDelegate(uint uid, string objName, ref Transform transform); public AdjustTransfromDelegate mAdjustTransfrom = null; private uint mUid = 0; private bool mEnable = false; // if disabled, then no rendering happens private Image image; private Sprite sprite; private IRtcEngineForGaming engine; public void SetForUser(uint uid) { mUid = uid; Debug.Log(\"Set uid \" + uid + \" for \" + gameObject.name); } public void SetEnable(bool enable) { mEnable = enable; } // Use this for initialization void Start() { mEnable = true; image = GetComponent\u003cImage\u003e(); engine = agora_gaming_rtc.IRtcEngineForGaming.QueryEngine(); //Dg.Log(\"engine:::\", engine,\" image:\",image,\" sprite:\",image.sprite); mAdjustTransfrom = AgoraController.onTransformDelegate; } // Update is called once per frame void Update() { // process engine messages (TODO: put in some other place) agora_gaming_rtc.IRtcEngineForGaming engine = agora_gaming_rtc.IRtcEngineForGaming.QueryEngine(); if (engine == null) return; while (engine.GetMessageCount() \u003e 0) engine.Poll(); #if UNITY_IOS || UNITY_ANDROID uint uid = mUid; //Dg.Log(\"uid:::\" + uid + \" enable:\", mEnable,\" name:\",gameObject.name); if (mEnable) { if (image.sprite==null) { //Debug.Log(\"Texture2D.CreateExternalTexture:::\"); System.IntPtr texPtr = (System.IntPtr)engine.GenerateNativeTexture(); Texture2D tex = Texture2D.CreateExternalTexture(640, 360, TextureFormat.ARGB32, false, false, texPtr); // FIXME! texture size is subject to change Sprite spt = Sprite.Create(tex, new Rect(0, 0, 640, 360), new Vector2(0.5f, 0.5f)); this.sprite = spt; image.sprite = spt; //Debug.Log(\"Texture2D.CreateExternalTexture:::texPtr:\"+texPtr+\" size:\"+ tex.texelSize); } // update texture if (sprite != null) { int texId = (int)sprite.texture.GetNativeTexturePtr(); // update texture (possible size changing) uint texWidth = 0; uint texHeight = 0; if (engine.UpdateTexture(texId, uid, ref texWidth, ref texHeight) == 0) { // TODO: process texture then render } //image.SetAllDirty(); } } else if (sprite != null) { int texId = (int)sprite.texture.GetNativeTexturePtr(); image.sprite = null; engine.DeleteTexture(texId); } #endif if (mAdjustTransfrom != null) { var trans = transform; mAdjustTransfrom(mUid, gameObject.name, ref trans); } } } //===================================================== // - FileName: AgoraController // - Description: // - Author: wangguoqing // - Email: wangguoqing@hehemj.com // - Created: 2018/1/4 11:48:38 // - CLR version: 4.0.30319.42000 // - UserName: Wang // - (C) Copyright 2008 - 2015, hehehuyu,Inc. // - All Rights Reserved. //====================================================== using UnityEngine; using UnityEngine.UI; using System.Collections.Generic; using System.Text; using agora_gaming_rtc; class AgoraController { public IRtcEngineForGaming mRtcEngine; public static string appId = \"657d422025b44a7793ef3a94a59cae0c\"; private XLua.LuaFunction func; public static void onTransformDelegate(uint uid, string objName, ref Transform transform) { var pos = transform.position; transform.position = new Vector3(pos.x, pos.y + 0.00000000001f, pos.z); //if (uid == 0) { // //transform.position = new Vector3 (0f, 2f, 0f); // //transform.localScale = new Vector3 (2.0f, 2.0f, 1.0f); // //transform.Rotate (0f, 1f, 0f); //} else { // //transform.Rotate (0.0f, 1.0f, 0.0f); //} } } ","date":"2019-12-01 21:57:40","objectID":"/unity%E6%8E%A5%E5%85%A5%E5%A3%B0%E7%BD%91sdk%E8%A7%86%E9%A2%91bug/:0:0","tags":["SDK"],"title":"unity接入声网sdk视频bug","uri":"/unity%E6%8E%A5%E5%85%A5%E5%A3%B0%E7%BD%91sdk%E8%A7%86%E9%A2%91bug/"},{"categories":["Unity"],"content":"Unity中的渲染顺序有三层： 第一层：Camera的depth，值越大渲染越在前面 第二层：Sorting Layer，配置SortingLayer面板（越在下面的layer渲染越在前面），然后在Canvas上设置或者在Renderer组件上设置 第三层:SortingOrder,值越大越在前面渲染，然后在Canvas上设置或者在Renderer组件上设置 决定渲染顺序:第一层\u003e第二层和第三层 render1.png ","date":"2019-12-01 21:57:40","objectID":"/unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F/:0:0","tags":["Unity"],"title":"Unity渲染顺序","uri":"/unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F/"},{"categories":["Unity"],"content":"相机渲染顺序 　相机的渲染顺序，由Camera的Depth参数控制 ","date":"2019-12-01 21:57:40","objectID":"/unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F/:1:0","tags":["Unity"],"title":"Unity渲染顺序","uri":"/unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F/"},{"categories":["Unity"],"content":"RenderQueue 　Queue分为五个队列： 　Background，天空盒，天生用来被覆盖的（1000） 　Geometry，不透明物渲染队列（2000） 　AlphaTest，通道测试的几何体使用这个队列，这些物体的渲染有点介于Opaue与Transparent之间（2450） 　Geometrylast，特殊的点，定义了透明与不透明的分界点（2500），属于不透明队列 　Transparent，不写深度的物体，一般是透明物或粒子效果（3000） 　Overlay，最后渲染的内容，天生覆盖别人的，如UI（4000） ","date":"2019-12-01 21:57:40","objectID":"/unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F/:2:0","tags":["Unity"],"title":"Unity渲染顺序","uri":"/unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F/"},{"categories":["Unity"],"content":"RenderQueue与SortingLayer与Order之间的关系 Queue \u003e 2500 的物体绝对会在 Queue \u003c= 2500 之后渲染，这时Layer、Order将完全不起作用 Queue 位于1中的同一侧时，Layer低的先渲染，无视Queue与Order值 Queue 位于1中的同一侧时，Layer 相同，Order 低的先渲染，无视 Queue Layer与Order都一样时，Queue 低的先渲染 ","date":"2019-12-01 21:57:40","objectID":"/unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F/:3:0","tags":["Unity"],"title":"Unity渲染顺序","uri":"/unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F/"},{"categories":["Unity"],"content":"Opaque调整SortingLayer，SortingOrder为什么没作用？ 　因为不透明物体是打开ZWrite的，即使改了SortingLayer与Order，让一个本来在后边（Z值大）的物体先渲染了，但是另一个物体渲染时 　由于Z值小，写深度以后，立马把前边的物体覆盖了，结果总是一样的；透明物渲染时，关闭了ZWrite，渲染的结果不是替换的，是 　混合的，所以先渲染后渲染，结果就可能会不同（与混合的方式有关） ","date":"2019-12-01 21:57:40","objectID":"/unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F/:4:0","tags":["Unity"],"title":"Unity渲染顺序","uri":"/unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F/"},{"categories":["Unity"],"content":"总结 Geometry不透明队列是RenderQueue\u003c=2500的 Transparent透明队列是RenderQueue\u003e2500的 如果两个物体分别属于 Geometry不透明队列 和 Transparent透明队列，则Sorting Layer 和 Order in Layer 怎么设置都是不起作用的 (Z值是最后决定前后关系的) 如果两个物体都在Geometry不透明队列 或者都属于 Transparent透明队列，则 在Sorting Layer高的绝对会在Sorting Layer前面，无视RenderQueue跟Order in Layer，只有在Sorting Layer相同的前提下，Order in Layer高的会在Order in Layer低的前面，无视RenderQueue。当Sorting Layer跟Order in Layer相同时，才看RenderQueue的高低，高的在前面。（假设ZWrite和ZTest关闭） 简要概括：物体属于同一队列则Layer比Queue优先 如果要测试，则使用Transparent透明队列测试，且把shader的深度写入和深度测试关闭 参考： https://www.cnblogs.com/hiker-online/p/12489252.html ","date":"2019-12-01 21:57:40","objectID":"/unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F/:5:0","tags":["Unity"],"title":"Unity渲染顺序","uri":"/unity%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F/"},{"categories":["Unity"],"content":" Screen.sleepTimeout = SleepTimeout.NeverSleep; ","date":"2019-12-01 21:57:40","objectID":"/unity%E7%A6%81%E6%AD%A2%E5%B1%8F%E5%B9%95%E4%BC%91%E7%9C%A0/:0:0","tags":["Unity"],"title":"unity禁止屏幕休眠","uri":"/unity%E7%A6%81%E6%AD%A2%E5%B1%8F%E5%B9%95%E4%BC%91%E7%9C%A0/"},{"categories":["Unity"],"content":"Editor下缩放脚本(非运行情况下)（Unity5.3.6） //This script will only work in editor mode. You cannot adjust the scale dynamically in-game! using UnityEngine; using System.Collections; #if UNITY_EDITOR using UnityEditor; #endif [ExecuteInEditMode] public class ParticleScaler : MonoBehaviour { public float particleScale = 1.0f; public bool alsoScaleGameobject = true; float prevScale; void Start() { prevScale = particleScale; } void Update () { #if UNITY_EDITOR //check if we need to update if (prevScale != particleScale \u0026\u0026 particleScale \u003e 0) { if (alsoScaleGameobject) transform.localScale = new Vector3(particleScale, particleScale, particleScale); float scaleFactor = particleScale / prevScale; //scale legacy particle systems ScaleLegacySystems(scaleFactor); //scale shuriken particle systems ScaleShurikenSystems(scaleFactor); //scale trail renders ScaleTrailRenderers(scaleFactor); prevScale = particleScale; } #endif } void ScaleShurikenSystems(float scaleFactor) { #if UNITY_EDITOR //get all shuriken systems we need to do scaling on ParticleSystem[] systems = GetComponentsInChildren\u003cParticleSystem\u003e(); foreach (ParticleSystem system in systems) { system.startSpeed *= scaleFactor; system.startSize *= scaleFactor; system.gravityModifier *= scaleFactor; //some variables cannot be accessed through regular script, we will acces them through a serialized object SerializedObject so = new SerializedObject(system); //unity 4.0 and onwards will already do this one for us #if UNITY_3_5 //so.FindProperty(\"ShapeModule.radius\").floatValue *= scaleFactor; //so.FindProperty(\"ShapeModule.boxX\").floatValue *= scaleFactor; //so.FindProperty(\"ShapeModule.boxY\").floatValue *= scaleFactor; //so.FindProperty(\"ShapeModule.boxZ\").floatValue *= scaleFactor; #endif /*so.FindProperty(\"VelocityModule.x.scalar\").floatValue *= scaleFactor; so.FindProperty(\"VelocityModule.y.scalar\").floatValue *= scaleFactor; so.FindProperty(\"VelocityModule.z.scalar\").floatValue *= scaleFactor; so.FindProperty(\"ClampVelocityModule.magnitude.scalar\").floatValue *= scaleFactor; so.FindProperty(\"ClampVelocityModule.x.scalar\").floatValue *= scaleFactor; so.FindProperty(\"ClampVelocityModule.y.scalar\").floatValue *= scaleFactor; so.FindProperty(\"ClampVelocityModule.z.scalar\").floatValue *= scaleFactor; so.FindProperty(\"ForceModule.x.scalar\").floatValue *= scaleFactor; so.FindProperty(\"ForceModule.y.scalar\").floatValue *= scaleFactor; so.FindProperty(\"ForceModule.z.scalar\").floatValue *= scaleFactor; so.FindProperty(\"ColorBySpeedModule.range\").vector2Value *= scaleFactor; so.FindProperty(\"SizeBySpeedModule.range\").vector2Value *= scaleFactor; so.FindProperty(\"RotationBySpeedModule.range\").vector2Value *= scaleFactor; so.ApplyModifiedProperties();*/ } #endif } void ScaleLegacySystems(float scaleFactor) { #if UNITY_EDITOR //get all emitters we need to do scaling on ParticleEmitter[] emitters = GetComponentsInChildren\u003cParticleEmitter\u003e(); //get all animators we need to do scaling on ParticleAnimator[] animators = GetComponentsInChildren\u003cParticleAnimator\u003e(); //apply scaling to emitters foreach (ParticleEmitter emitter in emitters) { emitter.minSize *= scaleFactor; emitter.maxSize *= scaleFactor; emitter.worldVelocity *= scaleFactor; emitter.localVelocity *= scaleFactor; emitter.rndVelocity *= scaleFactor; //some variables cannot be accessed through regular script, we will acces them through a serialized object /*SerializedObject so = new SerializedObject(emitter); so.FindProperty(\"m_Ellipsoid\").vector3Value *= scaleFactor; so.FindProperty(\"tangentVelocity\").vector3Value *= scaleFactor; so.ApplyModifiedProperties();*/ } //apply scaling to animators foreach (ParticleAnimator animator in animators) { animator.force *= scaleFactor; animator.rndForce *= scaleFactor; } #endif } void ScaleTrailRenderers(float scaleFactor) { //get all animators we need to do scaling on TrailRenderer[] trails = GetComponentsInChildren\u003cTrailRenderer\u003e(); //apply scaling to animators foreach (TrailRenderer trail in trails) { trail.st","date":"2019-12-01 21:57:40","objectID":"/unity%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88%E7%BC%A9%E6%94%BE/:0:0","tags":["Unity"],"title":"Unity粒子特效缩放","uri":"/unity%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88%E7%BC%A9%E6%94%BE/"},{"categories":["Unity"],"content":" 基础的MonoBehaviour默认方法执行顺序参考上篇文章Unity脚本执行顺序 测试结果： ######1.通过Instantiate加载Prefab时Awake和OnEnable会先后执行，并且在Instantiate执行过程中执行的； ######2.通过SceneManager.LoadScene加载场景时是在当前代码块执行完成后并且执行Ondestroy后开始执行所加载场景test1内的代码的，所以在当前代码块调用完LoadScene后用GameObject.Find去获取场景内的物体时是获取不到的 ######3.在Awake中执行SceneManager.LoadScene，当前的Start方法是不会执行的 ######4.在执行gameObject.AddComponent().Init();时会先执行TestPrefab中的Awake和OnEnable后才执行Init 这里先上工程截图 这里在TestPrefab上只挂TestPrefab一个脚本 这里在TestPrefab2上只挂TestPrefab2一个脚本 测试是在test2场景中运行，脚本加载切换到test1场景 这里放上所有的脚本 //===================================================== // - FileName: Test.cs // - Created: wangguoqing // - UserName: 2018/03/02 14:04:52 // - Email: wangguoqing@hehegames.cn // - Description: // - (C) Copyright 2008 - 2015, hehehuyu,Inc. // - All Rights Reserved. //====================================================== using System.Collections; using System.Collections.Generic; using UnityEngine; public class TestLoading : MonoBehaviour { #region Method Call Order void Awake() { Debug.LogWarning(\"TestLoading:::Awake^^^Begin^^^^^^^^^^\"); //LoadPrefab(); //LoadScene(); Debug.LogWarning(\"TestLoading:::Awake^^^End^^^^^^^^^^\"); } void OnEnable() { Debug.LogWarning(\"TestLoading:::OnEnable^^^^^^^^^^^^^\"); } // Use this for initialization void Start() { Debug.LogWarning(\"TestLoading:::Start^^^^^^^^Begin^^^^^\"); LoadPrefab(); LoadScene(); Debug.LogWarning(\"TestLoading:::Start^^^^^^^^End^^^^^\"); } void LoadPrefab() { GameObject asset = Resources.Load\u003cGameObject\u003e(\"TestPrefab\"); GameObject obj = GameObject.Instantiate(asset); } void LoadScene() { UnityEngine.SceneManagement.SceneManager.LoadScene(\"test1\"); } void FixedUpdate() { //Debug.LogWarning(\"TestLoading:::FixedUpdate^^^^^^^^^^^^^\"); } // Update is called once per frame void Update() { //Debug.LogWarning(\"TestLoading:::Update^^^^^^^^^^^^^\"); } void LateUpdate() { //Debug.LogWarning(\"TestLoading:::LateUpdate^^^^^^^^^^^^^\"); } void OnGUI() { //Debug.LogWarning(\"TestLoading:::OnGUI^^^^^^^^^^^^^\"); } void Reset() { Debug.LogWarning(\"TestLoading:::Reset^^^^^^^^^^^^^\"); } void OnDisable() { Debug.LogWarning(\"TestLoading:::OnDisable^^^^^^^^^^^^^\"); } void OnDestroy() { Debug.LogWarning(\"TestLoading:::OnDestroy^^^^^^^^^^^^^\"); } #endregion } //===================================================== // - FileName: TestScene.cs // - Created: wangguoqing // - UserName: 2018/03/02 14:08:53 // - Email: wangguoqing@hehegames.cn // - Description: // - (C) Copyright 2008 - 2015, hehehuyu,Inc. // - All Rights Reserved. //====================================================== using System.Collections; using System.Collections.Generic; using UnityEngine; public class TestScene : MonoBehaviour { #region Method Call Order void Awake() { Debug.Log(\"TestScene:::Awake^^^Begin^^^^^^^^^^\"); LoadPrefab(); Debug.Log(\"TestScene:::Awake^^^End^^^^^^^^^^\"); } void OnEnable() { Debug.Log(\"TestScene:::OnEnable^^^^^^^^^^^^^\"); } // Use this for initialization void Start() { Debug.Log(\"TestScene:::Start^^^^^^^^^^^^^\"); } void LoadPrefab() { GameObject asset = Resources.Load\u003cGameObject\u003e(\"TestPrefab2\"); GameObject obj = GameObject.Instantiate(asset); } void FixedUpdate() { //Debug.Log(\"TestScene:::FixedUpdate^^^^^^^^^^^^^\"); } // Update is called once per frame void Update() { //Debug.Log(\"TestScene:::Update^^^^^^^^^^^^^\"); } void LateUpdate() { //Debug.Log(\"TestScene:::LateUpdate^^^^^^^^^^^^^\"); } void OnGUI() { //Debug.Log(\"TestScene:::OnGUI^^^^^^^^^^^^^\"); } void Reset() { Debug.Log(\"TestScene:::Reset^^^^^^^^^^^^^\"); } void OnDisable() { Debug.Log(\"TestScene:::OnDisable^^^^^^^^^^^^^\"); } void OnDestroy() { Debug.Log(\"TestScene:::OnDestroy^^^^^^^^^^^^^\"); } #endregion } //===================================================== // - FileName: TestScene1.cs // - Created: wangguoqing // - UserName: 2018/03/02 14:08:53 // - Email: wangguoqing@hehegames.cn // - Description: // - (C) Copyright 2008 - 2015, hehehuyu,Inc. // - All Rights Reserved. //====================================================== using System.Collec","date":"2019-12-01 21:57:40","objectID":"/unity%E8%84%9A%E6%9C%ACmonobehaviour%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%B5%8B%E8%AF%95/:0:0","tags":["Unity"],"title":"unity脚本MonoBehaviour默认方法执行顺序测试","uri":"/unity%E8%84%9A%E6%9C%ACmonobehaviour%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%B5%8B%E8%AF%95/"},{"categories":["Unity"],"content":" 进阶测试参考[unity脚本MonoBehaviour默认方法执行顺序测试 ](http://www.jianshu.com/p/574910aa3f52) 将脚本挂到空物体上执行 using System.Collections; using System.Collections.Generic; using UnityEngine; /// \u003csummary\u003e /// Unity脚本执行顺序 测试 /// \u003c/summary\u003e public class TestCallSequence : MonoBehaviour { void Awake() { Debug.Log(\"Awake^^^^^^^^^^^^^\"); } void OnEnable() { Debug.Log(\"OnEnable^^^^^^^^^^^^^\"); } // Use this for initialization void Start() { Debug.Log(\"Start^^^^^^^^^^^^^\"); } void FixedUpdate() { Debug.Log(\"FixedUpdate^^^^^^^^^^^^^\"); } // Update is called once per frame void Update() { Debug.Log(\"Update^^^^^^^^^^^^^\"); } void LateUpdate() { Debug.Log(\"LateUpdate^^^^^^^^^^^^^\"); } void OnGUI() { Debug.Log(\"OnGUI^^^^^^^^^^^^^\"); } void Reset() { Debug.Log(\"Reset^^^^^^^^^^^^^\"); } void OnDisable() { Debug.Log(\"OnDisable^^^^^^^^^^^^^\"); } void OnDestroy() { Debug.Log(\"OnDestroy^^^^^^^^^^^^^\"); } } 执行结果 先运行脚本然后将将脚本组件改为非激活状态（active=false），然后停止运行。 上面的执行结果说明方法的调用顺序一部分是不固定的（FixedUpdate）。 　Unity脚本从唤醒到销毁都有着一套比较完善的生命周期，添加任何脚本都要遵守生命周期法则！　接下来介绍几种系统自调用的重要方法。首先要我们先来说明一下它们的执行顺序：　Awake –\u003e Start –\u003e Update –\u003e FixedUpdate –\u003e LateUpdate –\u003eOnGUI –\u003eReset –\u003e OnDisable –\u003eOnDestroy　下面我们针对每一个方法进行详细的说明：　1.Awake：用于在游戏开始之前初始化变量或游戏状态。在脚本整个生命周期内它仅被调用一次.Awake在所有对象被初始化之后调用，所以你可以安全的与其他对象对话或用诸如GameObject.FindWithTag()这样的函数搜索它们。每个游戏物体上的Awake以随机的顺序被调用。因此，你应该用Awake来设置脚本间的引用，并用Start来传递信息Awake总是在Start之前被调用。它不能用来执行协同程序。　2.Start：仅在Update函数第一次被调用前调用。Start在behaviour的生命周期中只被调用一次。它和Awake的不同是Start只在脚本实例被启用时调用。你可以按需调整延迟初始化代码。Awake总是在Start之前执行。这允许你协调初始化顺序。在所有脚本实例中，Start函数总是在Awake函数之后调用。　3.Update：正常帧更新，用于更新逻辑。每一帧都执行，处理Rigidbody时，需要用FixedUpdate代替Update。例如:给刚体加一个作用力时，你必须应用作用力在FixedUpdate里的固定帧，而不是Update中的帧。(两者帧长不同)FixedUpdate，每固定帧绘制时执行一次，和update不同的是FixedUpdate是渲染帧执行，如果你的渲染效率低下的时候FixedUpdate调用次数就会跟着下降。FixedUpdate比较适用于物理引擎的计算，因为是跟每帧渲染有关。Update就比较适合做控制。　4.FixedUpdate：固定帧更新，在Unity导航菜单栏中，点击“Edit”–\u003e“Project Setting”–\u003e“Time”菜单项后，右侧的Inspector视图将弹出时间管理器，其中“Fixed Timestep”选项用于设置FixedUpdate()的更新频率，更新频率默认为0.02s。　5.LateUpdate：在所有Update函数调用后被调用，和fixedupdate一样都是每一帧都被调用执行，这可用于调整脚本执行顺序。例如:当物体在Update里移动时，跟随物体的相机可以在LateUpdate里实现。LateUpdate,在每帧Update执行完毕调用，他是在所有update结束后才调用，比较适合用于命令脚本的执行。官网上例子是摄像机的跟随，都是在所有update操作完才跟进摄像机，不然就有可能出现摄像机已经推进了，但是视角里还未有角色的空帧出现。　6.OnGUI：在渲染和处理GUI事件时调用。比如：你画一个button或label时常常用到它。这意味着OnGUI也是每帧执行一次。　7.Reset：在用户点击检视面板的Reset按钮或者首次添加该组件时被调用。此函数只在编辑模式下被调用。Reset最常用于在检视面板中给定一个默认值。　8.OnDisable：当物体被销毁时 OnDisable将被调用，并且可用于任意清理代码。脚本被卸载时，OnDisable将被调用，OnEnable在脚本被载入后调用。注意： OnDisable不能用于协同程序。　9.OnDestroy：当MonoBehaviour将被销毁时，这个函数被调用。OnDestroy只会在预先已经被激活的游戏物体上被调用。注意：OnDestroy也不能用于协同程序。　备注：　协同程序，即在主程序运行时同时开启另一段逻辑处理，来协同当前程序的执行。换句话说，开启协同程序就是开启一个线程。 协同程序，即在主程序运行时同时开启另一段逻辑处理，来协同当前程序的执行。换句话说，开启协同程序就是开启一个线程。在中，使用MonoBehaviour.StartCoroutine方法即可开启一个协同程序，也就是说该方法必须在MonoBehaviour或继承于MonoBehaviour的类中调用。 unity的生命周期;unity中画线;unity3d使用ondestroy;unity生命周期函数;unity onenable start;unity awake onenable;unity 生命周期;在unity画线;unity画线;unity3d ondestroy;unity 函数生命周期;unity start onenable;unity onenable awake 引用文章: http://www.manew.com/thread-14461-1-1.html ; 引用文章: http://www.jianshu.com/p/1d93ece664e2 #####如果在其他脚本里面实例化物体，且物体上挂有该脚本： 脚本会在实例化时（Instantiate）Awake直接同步执行，执行完后才执行Instantiate后面的代码 ","date":"2019-12-01 21:57:40","objectID":"/unity%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/:0:0","tags":["Unity"],"title":"Unity脚本执行顺序","uri":"/unity%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"},{"categories":["Unity"],"content":" Screen.SetResolution(128 * 6, 72 * 6, false); ","date":"2019-12-01 21:57:40","objectID":"/unity%E8%AE%BE%E7%BD%AE%E5%B1%8F%E5%B9%95%E5%88%86%E8%BE%A8%E7%8E%87/:0:0","tags":["Unity"],"title":"unity设置屏幕分辨率","uri":"/unity%E8%AE%BE%E7%BD%AE%E5%B1%8F%E5%B9%95%E5%88%86%E8%BE%A8%E7%8E%87/"},{"categories":["Unity"],"content":"因为StreamingAssets目录对于Android来说是在apk里面的，所以File读取不到里面的内容信息，必须通过Android的api读取加载。 C#代码 //===================================================== // - FileName: ProviderService // - Description: // - Author: wangguoqing // - Email: wangguoqing@hehemj.com // - Created: 2017/12/13 17:12:17 // - CLR version: 4.0.30319.42000 // - UserName: Wang // - (C) Copyright 2008 - 2015, hehehuyu,Inc. // - All Rights Reserved. //====================================================== using System.Collections; using System.Collections.Generic; using System.Runtime.InteropServices; using UnityEngine; /// \u003csummary\u003e /// 和平台层交互必须通过unity主线程调用 /// \u003c/summary\u003e public class ProviderService :MonoBehaviour { public static ProviderService Instance; #if UNITY_ANDROID private AndroidJavaClass jc; private AndroidJavaObject jo; #endif void Awake() { Instance = this; } void Start() { #if UNITY_ANDROID \u0026\u0026!UNITY_EDITOR jc = new AndroidJavaClass(\"com.test.game.AppActivity\"); jo = jc.CallStatic\u003cAndroidJavaObject\u003e(\"GetActivity\"); #endif } /// \u003csummary\u003e /// 读取StreamingAsset 下的文件 /// 必须在unity主线程调用，否则JNI调用不过去 /// \u003c/summary\u003e /// \u003creturns\u003e\u003c/returns\u003e public byte[] ReadBytes(string fileName) { byte[] data = null; #if UNITY_ANDROID \u0026\u0026!UNITY_EDITOR data = jo.Call\u003cbyte[]\u003e(\"ReadBytes\", fileName); #endif return data; } } Android代码 package com.test.game; import com.unity3d.player.UnityPlayerActivity; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import com.unity3d.player.UnityPlayer; import android.app.AlertDialog; import android.content.BroadcastReceiver; import android.content.ClipData; import android.content.ClipboardManager; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.content.res.AssetManager; import android.content.res.Resources; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.net.ConnectivityManager; import android.net.NetworkInfo; import android.net.Uri; import android.net.wifi.WifiInfo; import android.net.wifi.WifiManager; import android.os.BatteryManager; import android.os.Bundle; import android.os.Environment; import android.telephony.TelephonyManager; import android.util.Log; import android.widget.ImageView; import android.widget.Toast; public class AppActivity extends UnityPlayerActivity { public static final String GameObjectName=\"Service\"; public static final String ApplinkMethodName=\"BroadcastApplinkUrl\"; public static final String BatteryChangedMethodName=\"BroadcastBatteryChanged\"; public static final String AppPackName = \"com.hehegames.majiangone\"; public static AppActivity activity=null; TelephonyManager phoneManager=null; WifiManager wifiManager=null; WifiInfo wifiInfo = null; //获得的Wifi信息 @Override protected void onCreate(Bundle savedInstanceState) { Log.v(\"life\",\"onCreate\"); super.onCreate(savedInstanceState); activity=this; //显示splash ShowSplash(); phoneManager = (TelephonyManager) this.getSystemService(TELEPHONY_SERVICE); // 获得WifiManager wifiManager = (WifiManager) getSystemService(WIFI_SERVICE); assetManager = getAssets(); //applink Uri uri = getIntent().getData(); if(uri!=null) { ApplinkUrl=uri.toString(); } else { ApplinkUrl=null; } } public static AppActivity GetActivity() { return activity; } //********************************read StreamingAsset file************************************************* protected AssetManager assetManager; private byte[] ReadBytesByStream(InputStream inputStream) { ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); //长度这里暂时先写成1024 byte buf[] = new byte [2048]; int len; try { while ((len = inputStream.read(buf)) != -1) { outputStream.write(buf, 0, len); } outputStream.close(); inputStream.close(); } catch (IOException e) { return null; } return outputStream.toByteArray(); } //load StreamingAsset file by byte array public byte[] ReadBytes(String path) { InputStream inputStream = null ; try { inputStream = assetManager.open(path); } catch (IOException e) { Log.v (","date":"2019-12-01 21:57:40","objectID":"/unity%E8%AF%BB%E5%8F%96streamingassets%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6/:0:0","tags":["Unity"],"title":"unity读取StreamingAssets文本文件","uri":"/unity%E8%AF%BB%E5%8F%96streamingassets%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6/"},{"categories":["Unity"],"content":"渲染错误 渲染正确 原因是图片压缩了 将图片压缩改成RGBA32bit就好了 ","date":"2019-12-01 21:57:40","objectID":"/untiy-ios%E9%80%8F%E6%98%8Eui-%E7%9A%84%E9%80%8F%E6%98%8E%E5%8C%BA%E5%9F%9F%E6%B8%B2%E6%9F%93%E9%94%99%E8%AF%AF/:0:0","tags":["Unity","IOS"],"title":"untiy-ios透明ui-的透明区域渲染错误","uri":"/untiy-ios%E9%80%8F%E6%98%8Eui-%E7%9A%84%E9%80%8F%E6%98%8E%E5%8C%BA%E5%9F%9F%E6%B8%B2%E6%9F%93%E9%94%99%E8%AF%AF/"},{"categories":["other"],"content":"这里做个记录，没有测试 引用文章： http://blog.csdn.net/loongsking/article/details/44316579 ","date":"2019-12-01 21:57:40","objectID":"/vs2013-lua%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/:0:0","tags":["lua"],"title":"VS2013+LUA代码高亮配置教程","uri":"/vs2013-lua%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"},{"categories":["other"],"content":"打开VS2013所在路径 打开指定目录.\\Microsoft Visual Studio 12.0\\Common7\\IDE\\ItemTemplates\\CSharp\\Code\\2052 我的目录：C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\Common7\\IDE\\ItemTemplates\\CSharp\\Code\\2052\\ 修改Class目录下的Class.cs文件和Interface目录下的Interface.cs文件 我的Class.cs修改为 //===================================================== // - FileName: $itemname$ // - Description: // - Author: wangguoqing // - Email: wangguoqing@hehemj.com // - Created: $time$ // - CLR version: $clrversion$ // - UserName: $username$ // - (C) Copyright 2008 - 2015, hehehuyu,Inc. // - All Rights Reserved. //====================================================== using System; using System.Collections.Generic; $if$ ($targetframeworkversion$ \u003e= 3.5)using System.Linq; $endif$using System.Text; $if$ ($targetframeworkversion$ \u003e= 4.5)using System.Threading.Tasks; $endif$ namespace $rootnamespace$ { class $safeitemrootname$ { } } 代码中的\"$“符号之间的字符是模版的变量，具体变量含义请参照： $time$ 日期 $year$ 年份 $clrversion$ CLR版本 $GUID$ 用于替换项目文件中的项目 GUID 的 GUID。最多可以指定 10 个唯一的 GUID（例如，guid1)）。 $itemname$ 用户在对话框中提供的名称。 $machinename$ 当前的计算机名称（例如，Computer01）。 $projectname$ 用户在对话框中提供的名称。 $rootnamespace$ 当前项目的根命名空间。此参数用于替换正向项目中添加的项中的命名空间。 $safeitemname$ 用户在“添加新项”对话框中提供的名称，名称中移除了所有不安全的字符和空格。 $safeprojectname$ 用户在“新建项目”对话框中提供的名称，名称中移除了所有不安全的字符和空格。 $time$ 以 DD/MM/YYYY 00:00:00 格式表示的当前时间。 $userdomain$ 当前的用户域。 $username$ 当前的用户名。 ","date":"2019-12-01 21:57:40","objectID":"/vs2013%E5%88%9B%E5%BB%BA%E6%96%B0%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6%E5%90%8D%E4%BD%9C%E8%80%85%E5%88%9B%E5%BB%BA%E6%97%B6%E9%97%B4%E7%AD%89/:0:0","tags":[""],"title":"VS2013创建新脚本自动添加版权声明，文件名，作者，创建时间等","uri":"/vs2013%E5%88%9B%E5%BB%BA%E6%96%B0%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6%E5%90%8D%E4%BD%9C%E8%80%85%E5%88%9B%E5%BB%BA%E6%97%B6%E9%97%B4%E7%AD%89/"},{"categories":["随笔"],"content":" 亲测可以 使用IIS配置Http win10下使用IIS搭建外网可访问的网站 ","date":"2019-12-01 21:57:40","objectID":"/win10-iis-http%E5%BB%BA%E7%AB%99/:0:0","tags":[""],"title":"win10 iis http建站","uri":"/win10-iis-http%E5%BB%BA%E7%AB%99/"},{"categories":["随笔"],"content":"一开始安装vs2017时失败了，然后安装vs2015和vs2013的时候各种错误，安装不上； 是因为安装缓存（C:\\ProgramData\\Package Cache）的存在，指向之前的版本了，我这是一开始的vs2017的缓存，我安装vs2015时，目录存在则直接使用了，没有重新创建，所以缓存错了， vs安装完成后 C:\\ProgramData\\Package Cache 下的缓存不会清理，在安装vs前先删除这个目录就好了 参考文章 分享一个安装Vs2015失败的解决方案，报错为系统找不到指定路径 ","date":"2019-12-01 21:57:40","objectID":"/win7%E5%AE%89%E8%A3%85vs2015%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%AE%89%E8%A3%85vs%E5%A4%9A%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98/:0:0","tags":[""],"title":"win7安装Vs2015失败的解决方案(安装vs多个版本的问题)","uri":"/win7%E5%AE%89%E8%A3%85vs2015%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%AE%89%E8%A3%85vs%E5%A4%9A%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["随笔"],"content":"windows如何创建以点开头的文件或者文件夹，则会提示“必须键入文件名”，下面介绍一下怎么创建开头带“.”的文件和文件夹 创建.开头的文件夹 用cmd命令行 mkdir .t1或者md .t2 创建.开头的文件 用cmd命令行 echo\u003e .gitignore ","date":"2019-12-01 21:57:40","objectID":"/windows%E5%88%9B%E5%BB%BA%E7%82%B9%E5%BC%80%E5%A4%B4%E7%9A%84%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85%E7%82%B9%E5%BC%80%E5%A4%B4%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9/:0:0","tags":[""],"title":"Windows创建.开头的文件或者.开头的文件夹","uri":"/windows%E5%88%9B%E5%BB%BA%E7%82%B9%E5%BC%80%E5%A4%B4%E7%9A%84%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85%E7%82%B9%E5%BC%80%E5%A4%B4%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9/"},{"categories":["IOS"],"content":"0X01导出Xcode工程 #####1.检查热更新配置 project_base.json等所有以project_开头的文件的配置信息； 这里的url最后的版本文件要和ios在线的版本一致，不一致则先修改 #####2.导出Xcode工程 检查资源版本号和线上的是否相同 如果是发布版本则点击Publish Packer，如果是热更新资源则点击Publish Bundle 如果选择Publish Packer 发布版本: 检查界面显示的版本是否为当前线上的版本 所有版本号加1，然后点击Publish Bundle; 然后导出Xcode工程 如果选择Publish Bundler 热更新版本: 检查界面显示的版本是否为当前线上的版本 清理缓存 版本号加1，然后点击Publish Bundle; 然后导出Xcode工程 #####3.对Xcode工程进行配置 1.打开Capabilities面板 打开Push Notifications选项 打开Background Modes选项，勾选Remote notifications 2.配置打开Notifications后会添加该文件 这样工程配置完成了，然后开始打包 ","date":"2019-12-01 21:57:40","objectID":"/xcode%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE/:1:0","tags":["IOS","Xcode"],"title":"Xcode工程配置","uri":"/xcode%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE/"},{"categories":["IOS"],"content":"unity 导出xcode后接环信libHyphenateSDK时build报错Undefined symbols for architecture armv7: 也有Undefined symbols for architecture arm64: Undefined symbols for architecture armv7: \"_CGImageDestinationCreateWithURL\", referenced from: -[EMVideoMessageBody initWithLocalPath:displayName:] in libHyphenateSDK.a(EMVideoMessageBody.o) \"_CGImageDestinationAddImage\", referenced from: -[EMVideoMessageBody initWithLocalPath:displayName:] in libHyphenateSDK.a(EMVideoMessageBody.o) \"_CGImageDestinationFinalize\", referenced from: -[EMVideoMessageBody initWithLocalPath:displayName:] in libHyphenateSDK.a(EMVideoMessageBody.o) ld: symbol(s) not found for architecture armv7 clang: error: linker command failed with exit code 1 (use -v to see invocation) 这个错误以为sdk或者framework不支持armv7或者arm64，我这实际上是缺少framework 这个错误是工程里面没有引用 ImageIO.framework造成的， 环信的libHyphenateSDK.a库依赖ImageIO.framework，结果报错让人无语 ","date":"2019-12-01 21:57:40","objectID":"/xcode%E6%8E%A5sdk%E6%97%B6%E6%8A%A5%E9%94%99undefined-symbols-for-architecture-arm64-/:0:0","tags":["IOS","Xcode"],"title":"xcode接sdk时报错（环信SDK接入ios报错）","uri":"/xcode%E6%8E%A5sdk%E6%97%B6%E6%8A%A5%E9%94%99undefined-symbols-for-architecture-arm64-/"},{"categories":["IOS"],"content":"1.连接你的设备，在Xcode下点击 Window —\u003e Device（cmd + shift + 2） 弹出窗口，选择你的设备，找到你已安装的APP，选中你想要查看沙盒的APP。 2.点击底部有个类似设置的按钮，出现几个选项，选择Download Container ，下载文件到本地，将会看到一个后缀为xcappdata的文件，选择这个文件并显示包内容查看对应的沙盒文件。 *下载失败或者Show Container没有内容 解决方案： 卸载app，重启手机设备，安装app就好了 ","date":"2019-12-01 21:57:40","objectID":"/xcode%E6%9F%A5%E7%9C%8B%E7%9C%9F%E6%9C%BAapp%E6%B2%99%E7%9B%92%E5%86%85%E5%AE%B9%E6%9F%A5%E7%9C%8Bapp%E7%BC%93%E5%AD%98cache%E6%96%87%E4%BB%B6/:0:0","tags":["IOS","Xcode"],"title":"Xcode查看真机app沙盒内容，查看app缓存（Cache）文件","uri":"/xcode%E6%9F%A5%E7%9C%8B%E7%9C%9F%E6%9C%BAapp%E6%B2%99%E7%9B%92%E5%86%85%E5%AE%B9%E6%9F%A5%E7%9C%8Bapp%E7%BC%93%E5%AD%98cache%E6%96%87%E4%BB%B6/"},{"categories":["IOS"],"content":" 原文：Xcode项目发布App Store商品审核 ios配置开发者证书及添加AppID 参考https://www.jianshu.com/p/ee83dc090b20 ios 配置ItunesConnect添加应用 参考https://www.jianshu.com/p/12ccfa566ae2 这里使用Xcode的版本为Version 9.2 (9C40b) ","date":"2019-12-01 21:57:40","objectID":"/xcode%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83app-store%E5%95%86%E5%93%81%E5%AE%A1%E6%A0%B8/:0:0","tags":["IOS","Xcode"],"title":"Xcode项目发布App-Store商品审核","uri":"/xcode%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83app-store%E5%95%86%E5%93%81%E5%AE%A1%E6%A0%B8/"},{"categories":["IOS"],"content":"0X01构建版本 点击Product –\u003e Archive，然后等待构建完成。 构建完成会打开window==\u003eOrganizer对应的界面 ","date":"2019-12-01 21:57:40","objectID":"/xcode%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83app-store%E5%95%86%E5%93%81%E5%AE%A1%E6%A0%B8/:0:1","tags":["IOS","Xcode"],"title":"Xcode项目发布App-Store商品审核","uri":"/xcode%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83app-store%E5%95%86%E5%93%81%E5%AE%A1%E6%A0%B8/"},{"categories":["IOS"],"content":"0X02导出Appstore的ipa包 点击右边的Export==\u003e选择Appstore版本，点击Next 将勾选去掉，不Upload，点击Next 选择自动签名，点击Next（如果出现不一样的界面并且左下角有Reset按钮，则点击Reset重试） 检查信息，点击Export 选择ipa导出存储路径，点击Export，然后导出ipa完成 ","date":"2019-12-01 21:57:40","objectID":"/xcode%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83app-store%E5%95%86%E5%93%81%E5%AE%A1%E6%A0%B8/:0:2","tags":["IOS","Xcode"],"title":"Xcode项目发布App-Store商品审核","uri":"/xcode%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83app-store%E5%95%86%E5%93%81%E5%AE%A1%E6%A0%B8/"},{"categories":["IOS"],"content":"0X03上传ipa包到iTunesConnect上，通过ApplicationLoader 打开Application Loader 配置账户===\u003e点击选取 选择上面导出的ipa包，点击打开 点击下一步 等待上传完成 然后在iTunesConnect上选择刚上传的包 ","date":"2019-12-01 21:57:40","objectID":"/xcode%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83app-store%E5%95%86%E5%93%81%E5%AE%A1%E6%A0%B8/:0:3","tags":["IOS","Xcode"],"title":"Xcode项目发布App-Store商品审核","uri":"/xcode%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83app-store%E5%95%86%E5%93%81%E5%AE%A1%E6%A0%B8/"},{"categories":["IOS"],"content":"0X04导出ipa包用hoc模式（替换上面的第二节0X02） 点击右边的Export==\u003e选择Ad Hoc版本，点击Next 选择Next 选择自动签名，点击Next（如果出现不一样的界面并且左下角有Reset按钮，则点击Reset重试） 检查信息，点击Export 选择ipa导出存储路径，点击Export，然后导出ipa完成 hoc模式不是上传appstore的，是给自己测试用的 ","date":"2019-12-01 21:57:40","objectID":"/xcode%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83app-store%E5%95%86%E5%93%81%E5%AE%A1%E6%A0%B8/:0:4","tags":["IOS","Xcode"],"title":"Xcode项目发布App-Store商品审核","uri":"/xcode%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83app-store%E5%95%86%E5%93%81%E5%AE%A1%E6%A0%B8/"},{"categories":["Unity"],"content":"unity 使用xLua插件，这两天增加lua-protobuf插件，所以需要重新编译XLua 这里编译Win平台和Android平台，因为手头上没有mac电脑所以没有编译ios和mac平台库 这里只做简单的记录 ","date":"2019-12-01 21:57:40","objectID":"/xlua-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%89%A9%E5%B1%95%E7%9A%84%E6%B7%BB%E5%8A%A0%E5%92%8C%E7%BC%96%E8%AF%91/:0:0","tags":["Unity"],"title":"xLua - 第三方扩展的添加和编译","uri":"/xlua-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%89%A9%E5%B1%95%E7%9A%84%E6%B7%BB%E5%8A%A0%E5%92%8C%E7%BC%96%E8%AF%91/"},{"categories":["Unity"],"content":"Windows平台 参考文章 xLua - 第三方扩展的添加和编译 需要工具： VS (我这里用的是vs2013，完全安装的，推荐的是vs2015) cmake（官网下载最新的3.13，传送门） windows sdk （我这里是windows sdk 8.1） 环境：win10+vs2013 编译通过 ","date":"2019-12-01 21:57:40","objectID":"/xlua-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%89%A9%E5%B1%95%E7%9A%84%E6%B7%BB%E5%8A%A0%E5%92%8C%E7%BC%96%E8%AF%91/:0:1","tags":["Unity"],"title":"xLua - 第三方扩展的添加和编译","uri":"/xlua-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%89%A9%E5%B1%95%E7%9A%84%E6%B7%BB%E5%8A%A0%E5%92%8C%E7%BC%96%E8%AF%91/"},{"categories":["Unity"],"content":"Android平台 参考文章 在windows上编译PC和Android平台的xlua库(并加入第三方lua库lpeg,sproto,lua-crypt) 需要工具： androidstudio android sdk android ndk (android-ndk-r10e-Windows) 环境：win10+androidstudio 编译通过 android sudio配置我这用的vpn（也可以用其它方法配置），需要下载cmake（cmake下载后自动配置到android sdk所在的目录），而不是windows安装的cmake 配置Android_SDK，Android_NDK环境变量，然后编译就可以了 android sudio下载cmake后，自动配置到android sdk目录下（默认sdk是没有cmake的）： mac和ios平台需要mac电脑，等后面补充吧 ","date":"2019-12-01 21:57:40","objectID":"/xlua-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%89%A9%E5%B1%95%E7%9A%84%E6%B7%BB%E5%8A%A0%E5%92%8C%E7%BC%96%E8%AF%91/:0:2","tags":["Unity"],"title":"xLua - 第三方扩展的添加和编译","uri":"/xlua-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%89%A9%E5%B1%95%E7%9A%84%E6%B7%BB%E5%8A%A0%E5%92%8C%E7%BC%96%E8%AF%91/"},{"categories":["other"],"content":"网络socket接收数据的异步回调不可以直接调入lua，在数据非常大的情况下如6321字节，在lua中解包，会出现线程同步的bug， 所以必须在unity的Update中转入主线程调用lua ","date":"2019-12-01 21:57:40","objectID":"/xlua-%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98/:0:0","tags":[],"title":"Xlua-线程问题","uri":"/xlua-%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98/"},{"categories":["shader"],"content":" 参考 《unity shader 入门精要》 这里说的法线纹理是储存切线空间数据 的法线纹理 根据光照的计算分为切线空间下的实现和世界空间下的实现 切线空间下的实现：指的是光照在切线空间下计算。（性能优先） 世界空间下的实现：指的是光照在世界空间下计算。（通用性优先，Cubemap环境映射需要这种方式实现） 切线空间的构建 x轴：tangent切线方向；y轴：副切线方向（或者副法线）；z轴：normal法线方向 副切线的获取：float3 binormal = cross(v.normal,v.tangent.xyz)*v.tangent.w; 根据x轴和z轴做叉乘获取垂直这两个轴所在平面的向量，有两个方向，根据v.tangent.w 来确定最后的方向； 然后构建空间变换矩阵float3x3 rotation = float3x3(v.tangent.xyz,binormal,v.normal); ","date":"2019-12-01 21:57:40","objectID":"/shader%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86/:0:0","tags":["shader"],"title":"【Shader】  法线纹理","uri":"/shader%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86/"},{"categories":["shader"],"content":"0X01 切线空间下的实现 // Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)' Shader \"Book/07.TangentNormal\" { //法线贴图 Properties { _Color (\"Color Tint\",Color)=(1,1,1,1) _MainTex (\"Main Tex\", 2D) = \"white\" {} _BumpMap(\"Normal Map\",2D) = \"white\" {} _BumpScale(\"Bump Scale\",Float) = 1.0 _Specular(\"Specular\",Color) = (1,1,1,1) _Gloss(\"Gloss\",Range(8.0,256)) = 20 } SubShader { Pass { Tags { \"LightMode\"=\"ForwardBase\" } CGPROGRAM #pragma vertex vert #pragma fragment frag // make fog work //#pragma multi_compile_fog #include \"UnityCG.cginc\" #include \"Lighting.cginc\" float4 _Color,_Specular; sampler2D _MainTex; sampler2D _BumpMap; float _BumpScale,_Gloss; float4 _MainTex_ST; float4 _BumpMap_ST; struct a2v { float4 vertex : POSITION; float3 normal: NORMAL; float4 tangent:TANGENT; float2 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float4 uv : TEXCOORD0; float3 lightDir:TEXCOORD1; float3 viewDir:TEXCOORD2; }; v2f vert (a2v v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.uv.xy = v.texcoord.xy*_MainTex_ST.xy + _MainTex_ST.zw; o.uv.zw = v.texcoord.xy*_BumpMap_ST.xy + _BumpMap_ST.zw; float3 binormal = cross(v.normal,v.tangent.xyz)*v.tangent.w; float3x3 rotation = float3x3(v.tangent.xyz,binormal,v.normal); //TANGENT_SPACE_ROTATION; //将光源位置减去顶点位置，这样就得到光照方向了 — 但是我们应该首先将顶点位置乘上光源的w分量，如果是平行光，w分量为0，得到的结果为0，说明顶点位置全变为(0.0, 0.0, 0.0)了，这样光照方向就是光源本身的位置（return objSpaceLightPos.xyz）。对于点光源，w为1，所以乘上顶点位置后，顶点位置无变化，这样计算的光照方向就是（return objSpaceLightPos.xyz – v.xyz）。 float3 lightDir = mul(unity_WorldToObject,_WorldSpaceLightPos0).xyz - v.vertex*_WorldSpaceLightPos0.w; o.lightDir = mul(rotation,lightDir); float3 viewDir = mul(unity_WorldToObject,float4(_WorldSpaceCameraPos,1)).xyz-v.vertex.xyz; o.viewDir = mul(rotation,viewDir); o.viewDir = normalize(o.viewDir); o.lightDir = normalize(o.lightDir); return o; } fixed4 frag (v2f i) : SV_Target { i.viewDir = normalize(i.viewDir); i.lightDir = normalize(i.lightDir); //uppack normal fixed3 tangentNormal; fixed4 packedNormal = tex2D(_BumpMap,i.uv.zw); #if defined(UNITY_NO_DXT5nm) tangentNormal.xyz = packedNormal.xyz*2 -1; #else // --rgba -- xyzw //DXTnm 格式中a通道（即w分量）对应发现x分量,g通道（即y分量）对应发现y分量, //tangentNormal.xy = packedNormal.ag*2 -1; tangentNormal.xy = packedNormal.wy*2 -1; tangentNormal=tangentNormal* _BumpScale; tangentNormal.z = sqrt(1.0-max(0,dot(tangentNormal.xy,tangentNormal.xy))); #endif fixed3 albedo = tex2D(_MainTex,i.uv).rgb*_Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz*albedo; fixed3 diffuse = _LightColor0.rgb*albedo*max(0,dot(tangentNormal,i.lightDir)); fixed3 halfDir = normalize(i.lightDir+i.viewDir); fixed3 specular = _LightColor0.rgb*_Specular.rgb*pow(max(0,dot(tangentNormal,halfDir)),_Gloss); return fixed4(ambient+diffuse+specular,1.0); } ENDCG } } FallBack \"Specular\" } ","date":"2019-12-01 21:57:40","objectID":"/shader%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86/:0:1","tags":["shader"],"title":"【Shader】  法线纹理","uri":"/shader%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86/"},{"categories":["shader"],"content":"0X02 世界空间下的实现 // Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)' Shader \"Book/07.WorldNormal\" { //法线贴图 Properties { _Color (\"Color Tint\",Color)=(1,1,1,1) _MainTex (\"Main Tex\", 2D) = \"white\" {} _BumpMap(\"Normal Map\",2D) = \"white\" {} _BumpScale(\"Bump Scale\",Float) = 1.0 _Specular(\"Specular\",Color) = (1,1,1,1) _Gloss(\"Gloss\",Range(8.0,256)) = 20 } SubShader { Pass { Tags { \"LightMode\"=\"ForwardBase\" } CGPROGRAM #pragma vertex vert #pragma fragment frag // make fog work //#pragma multi_compile_fog #include \"UnityCG.cginc\" #include \"Lighting.cginc\" #include \"AutoLight.cginc\" float4 _Color,_Specular; sampler2D _MainTex; sampler2D _BumpMap; float _BumpScale,_Gloss; float4 _MainTex_ST; float4 _BumpMap_ST; struct a2v { float4 vertex : POSITION; float3 normal: NORMAL; float4 tangent:TANGENT; float2 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float4 uv : TEXCOORD0; float3 worldPos: TEXCOORD1; float3 mat1: TEXCOORD2; float3 mat2: TEXCOORD3; float3 mat3: TEXCOORD4; }; v2f vert (a2v v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.worldPos= mul(unity_ObjectToWorld,v.vertex); o.uv.xy = v.texcoord.xy*_MainTex_ST.xy + _MainTex_ST.zw; o.uv.zw = v.texcoord.xy*_BumpMap_ST.xy + _BumpMap_ST.zw; //float3 worldNormal = mul((float3x3)unity_ObjectToWorld,v.normal); float3 worldNormal = mul(v.normal,(float3x3)unity_WorldToObject); float3 worldTangent= mul((float3x3)unity_ObjectToWorld,v.tangent.xyz).xyz; float3 worldBinormal = cross(worldNormal,worldTangent.xyz)*v.tangent.w; o.mat1=worldTangent.xyz; o.mat2 = worldBinormal; o.mat3 = worldNormal; return o; } fixed4 frag (v2f i) : SV_Target { float3 lightDir = _WorldSpaceLightPos0.xyz - i.worldPos*_WorldSpaceLightPos0.w; lightDir = normalize(lightDir); float3 viewDir = _WorldSpaceCameraPos.xyz - i.worldPos; viewDir = normalize(viewDir); float3x3 rotation = float3x3(i.mat1,i.mat2,i.mat3); //uppack normal fixed3 tangentNormal; fixed4 packedNormal = tex2D(_BumpMap,i.uv.zw); #if defined(UNITY_NO_DXT5nm) tangentNormal.xyz = packedNormal.xyz*2 -1; #else // --rgba -- xyzw //DXTnm 格式中a通道（即w分量）对应发现x分量,g通道（即y分量）对应发现y分量, //tangentNormal.xy = packedNormal.ag*2 -1; tangentNormal.xy = packedNormal.wy*2 -1; tangentNormal=tangentNormal* _BumpScale; tangentNormal.z = sqrt(1.0-max(0,dot(tangentNormal.xy,tangentNormal.xy))); #endif float3 worldNormal = mul(rotation,tangentNormal); fixed3 albedo = tex2D(_MainTex,i.uv).rgb*_Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz*albedo; fixed3 diffuse = _LightColor0.rgb*albedo*max(0,dot(worldNormal,lightDir)); fixed3 halfDir = normalize(lightDir+viewDir); fixed3 specular = _LightColor0.rgb*_Specular.rgb*pow(max(0,dot(worldNormal,halfDir)),_Gloss); return fixed4(ambient+diffuse+specular,1.0); } ENDCG } } } ","date":"2019-12-01 21:57:40","objectID":"/shader%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86/:0:2","tags":["shader"],"title":"【Shader】  法线纹理","uri":"/shader%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86/"},{"categories":["shader"],"content":" 使用噪声纹理模拟波纹 参考 《unity shader 入门精要》 // Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)' Shader \"Book/15.WaterWave\" { Properties { _Color (\"Main Color\", Color) = (0, 0.15, 0.115, 1) _MainTex (\"Base (RGB)\", 2D) = \"white\" {} _WaveMap (\"Wave Map\", 2D) = \"bump\" {} _Cubemap (\"Environment Cubemap\", Cube) = \"_Skybox\" {} _WaveXSpeed (\"Wave Horizontal Speed\", Range(-0.1, 0.1)) = 0.01 _WaveYSpeed (\"Wave Vertical Speed\", Range(-0.1, 0.1)) = 0.01 _Distortion (\"Distortion\", Range(0, 100)) = 10 } SubShader { Tags {\"RenderType\"=\"Opaque\" \"Queue\"=\"Transparent\"} GrabPass{\"_RefractionTex\"} Pass { Tags {\"LightMode\"=\"ForwardBase\" } CGPROGRAM #include \"UnityCG.cginc\" #include \"Lighting.cginc\" #pragma multi_compile_fwdbase #pragma vertex vert #pragma fragment frag fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; sampler2D _WaveMap; float4 _WaveMap_ST; samplerCUBE _Cubemap; fixed _WaveXSpeed; fixed _WaveYSpeed; float _Distortion; sampler2D _RefractionTex; //_RefractionTex纹理的像素大小，假设纹理大小为256*512，像素大小为（1/256,1/512） float4 _RefractionTex_TexelSize; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; float4 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float4 srcPos : TEXCOORD0; float4 uv : TEXCOORD1; float3 TtoW0 : TEXCOORD2; float3 TtoW1 : TEXCOORD3; float3 TtoW2 : TEXCOORD4; float3 worldPos:TEXCOORD5; }; v2f vert( a2v v ) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.uv.xy = v.texcoord*_MainTex_ST.xy + _MainTex_ST.zw; o.uv.zw = v.texcoord*_WaveMap_ST.xy + _WaveMap_ST.zw; o.srcPos = ComputeGrabScreenPos(o.pos); o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz; float3 worldNormal = mul(v.normal,(float3x3)unity_WorldToObject); float3 worldTangent= mul((float3x3)unity_ObjectToWorld,v.tangent.xyz).xyz; float3 worldBinormal = cross(worldNormal,worldTangent.xyz)*v.tangent.w; o.TtoW0 = float3(worldTangent.x, worldBinormal.x, worldNormal.x); o.TtoW1 = float3(worldTangent.y, worldBinormal.y, worldNormal.y); o.TtoW2 = float3(worldTangent.z, worldBinormal.z, worldNormal.z); return o; } fixed3 unpackNormal(fixed4 packedNormal) { fixed3 tangentNormal; #if defined(UNITY_NO_DXT5nm) tangentNormal.xyz = packedNormal.xyz*2 -1; #else // --rgba -- xyzw //DXTnm 格式中a通道（即w分量）对应发现x分量,g通道（即y分量）对应发现y分量, //tangentNormal.xy = packedNormal.ag*2 -1; tangentNormal.xy = packedNormal.wy*2 -1; //tangentNormal=tangentNormal* _BumpScale; tangentNormal.z = sqrt(1.0-max(0,dot(tangentNormal.xy,tangentNormal.xy))); #endif return tangentNormal; } //反射 float3 Reflect(float3 I,float3 normal) { //return I - 2*normal*dot(normal,I); return I - 2*normal*mul(I,float3x1( normal.x,normal.y,normal.z)); } half4 frag(v2f i) : SV_Target { float3 viewDir = _WorldSpaceCameraPos.xyz - i.worldPos; viewDir = normalize(viewDir); float2 speed =_Time.y*float2(_WaveXSpeed,_WaveYSpeed); // Get the normal in tangent space fixed3 bump1 = unpackNormal(tex2D(_WaveMap,i.uv.zw + speed)).rgb; fixed3 bump2 = unpackNormal(tex2D(_WaveMap,i.uv.zw - speed)).rgb; fixed3 bump = normalize(bump1 + bump2); // Compute the offset in tangent space float2 offset = bump.xy*_Distortion*_RefractionTex_TexelSize.xy; i.srcPos.xy = offset*i.srcPos.z + i.srcPos.xy; fixed3 refrCol = tex2D(_RefractionTex,i.srcPos.xy/i.srcPos.w).rgb; // Convert the normal to world space float3x3 rotation = float3x3(i.TtoW0,i.TtoW1,i.TtoW2); bump = normalize(mul(rotation,bump)); //bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump))); fixed4 texColor = tex2D(_MainTex, i.uv.xy + speed); fixed3 reflDir = Reflect(-viewDir, bump); fixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb * _Color.rgb; fixed fresnel = pow(1 - saturate(dot(viewDir, bump)), 4); fixed3 finalColor = reflCol * fresnel + refrCol * (1 - fresnel); return fixed4(finalColor,1); } ENDCG } } FallBack \"Diffuse\" } 效果：有损压缩了 ","date":"2019-12-01 21:57:40","objectID":"/shader%E6%B0%B4%E6%B3%A2%E7%BA%B9%E6%95%88%E6%9E%9C/:0:0","tags":["shader"],"title":"【Shader】 水波纹效果","uri":"/shader%E6%B0%B4%E6%B3%A2%E7%BA%B9%E6%95%88%E6%9E%9C/"},{"categories":["shader"],"content":" 法线贴图,在切线空间下计算（Cubemap环境映射不可以用，要用世界空间下计算） 参考 《unity shader 入门精要》 // Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)' Shader \"Book/07.TangentNormal\" { //法线贴图 Properties { _Color (\"Color Tint\",Color)=(1,1,1,1) _MainTex (\"Main Tex\", 2D) = \"white\" {} _BumpMap(\"Normal Map\",2D) = \"white\" {} _BumpScale(\"Bump Scale\",Float) = 1.0 _Specular(\"Specular\",Color) = (1,1,1,1) _Gloss(\"Gloss\",Range(8.0,256)) = 20 } SubShader { Pass { Tags { \"LightMode\"=\"ForwardBase\" } CGPROGRAM #pragma vertex vert #pragma fragment frag // make fog work //#pragma multi_compile_fog #include \"UnityCG.cginc\" #include \"Lighting.cginc\" float4 _Color,_Specular; sampler2D _MainTex; sampler2D _BumpMap; float _BumpScale,_Gloss; float4 _MainTex_ST; float4 _BumpMap_ST; struct a2v { float4 vertex : POSITION; float3 normal: NORMAL; float4 tangent:TANGENT; float2 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float4 uv : TEXCOORD0; float3 lightDir:TEXCOORD1; float3 viewDir:TEXCOORD2; }; v2f vert (a2v v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.uv.xy = v.texcoord.xy*_MainTex_ST.xy + _MainTex_ST.zw; o.uv.zw = v.texcoord.xy*_BumpMap_ST.xy + _BumpMap_ST.zw; float3 binormal = cross(v.normal,v.tangent.xyz)*v.tangent.w; float3x3 rotation = float3x3(v.tangent.xyz,binormal,v.normal); //TANGENT_SPACE_ROTATION; //将光源位置减去顶点位置，这样就得到光照方向了 — 但是我们应该首先将顶点位置乘上光源的w分量，如果是平行光，w分量为0，得到的结果为0，说明顶点位置全变为(0.0, 0.0, 0.0)了，这样光照方向就是光源本身的位置（return objSpaceLightPos.xyz）。对于点光源，w为1，所以乘上顶点位置后，顶点位置无变化，这样计算的光照方向就是（return objSpaceLightPos.xyz – v.xyz）。 float3 lightDir = mul(unity_WorldToObject,_WorldSpaceLightPos0).xyz - v.vertex*_WorldSpaceLightPos0.w; o.lightDir = mul(rotation,lightDir); float3 viewDir = mul(unity_WorldToObject,float4(_WorldSpaceCameraPos,1)).xyz-v.vertex.xyz; o.viewDir = mul(rotation,viewDir); o.viewDir = normalize(o.viewDir); o.lightDir = normalize(o.lightDir); return o; } fixed4 frag (v2f i) : SV_Target { i.viewDir = normalize(i.viewDir); i.lightDir = normalize(i.lightDir); //uppack normal fixed3 tangentNormal; fixed4 packedNormal = tex2D(_BumpMap,i.uv.zw); #if defined(UNITY_NO_DXT5nm) tangentNormal.xyz = packedNormal.xyz*2 -1; #else // --rgba -- xyzw //DXTnm 格式中a通道（即w分量）对应发现x分量,g通道（即y分量）对应发现y分量, //tangentNormal.xy = packedNormal.ag*2 -1; tangentNormal.xy = packedNormal.wy*2 -1; tangentNormal=tangentNormal* _BumpScale; tangentNormal.z = sqrt(1.0-max(0,dot(tangentNormal.xy,tangentNormal.xy))); #endif fixed3 albedo = tex2D(_MainTex,i.uv).rgb*_Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz*albedo; fixed3 diffuse = _LightColor0.rgb*albedo*max(0,dot(tangentNormal,i.lightDir)); fixed3 halfDir = normalize(i.lightDir+i.viewDir); fixed3 specular = _LightColor0.rgb*_Specular.rgb*pow(max(0,dot(tangentNormal,halfDir)),_Gloss); return fixed4(ambient+diffuse+specular,1.0); } ENDCG } } FallBack \"Specular\" } ","date":"2019-12-01 21:57:40","objectID":"/shader%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/:0:0","tags":["shader"],"title":"【Shader】 法线贴图","uri":"/shader%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/"},{"categories":["shader"],"content":" 法线贴图，世界空间下计算 参考 《unity shader 入门精要》 // Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)' Shader \"Book/07.WorldNormal\" { //法线贴图 Properties { _Color (\"Color Tint\",Color)=(1,1,1,1) _MainTex (\"Main Tex\", 2D) = \"white\" {} _BumpMap(\"Normal Map\",2D) = \"white\" {} _BumpScale(\"Bump Scale\",Float) = 1.0 _Specular(\"Specular\",Color) = (1,1,1,1) _Gloss(\"Gloss\",Range(8.0,256)) = 20 } SubShader { Pass { Tags { \"LightMode\"=\"ForwardBase\" } CGPROGRAM #pragma vertex vert #pragma fragment frag // make fog work //#pragma multi_compile_fog #include \"UnityCG.cginc\" #include \"Lighting.cginc\" #include \"AutoLight.cginc\" float4 _Color,_Specular; sampler2D _MainTex; sampler2D _BumpMap; float _BumpScale,_Gloss; float4 _MainTex_ST; float4 _BumpMap_ST; struct a2v { float4 vertex : POSITION; float3 normal: NORMAL; float4 tangent:TANGENT; float2 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float4 uv : TEXCOORD0; float3 worldPos: TEXCOORD1; float3 mat1: TEXCOORD2; float3 mat2: TEXCOORD3; float3 mat3: TEXCOORD4; }; v2f vert (a2v v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.worldPos= mul(unity_ObjectToWorld,v.vertex); o.uv.xy = v.texcoord.xy*_MainTex_ST.xy + _MainTex_ST.zw; o.uv.zw = v.texcoord.xy*_BumpMap_ST.xy + _BumpMap_ST.zw; //float3 worldNormal = mul((float3x3)unity_ObjectToWorld,v.normal); float3 worldNormal = mul(v.normal,(float3x3)unity_WorldToObject); float3 worldTangent= mul((float3x3)unity_ObjectToWorld,v.tangent.xyz).xyz; float3 worldBinormal = cross(worldNormal,worldTangent.xyz)*v.tangent.w; o.mat1=worldTangent.xyz; o.mat2 = worldBinormal; o.mat3 = worldNormal; return o; } fixed4 frag (v2f i) : SV_Target { float3 lightDir = _WorldSpaceLightPos0.xyz - i.worldPos*_WorldSpaceLightPos0.w; lightDir = normalize(lightDir); float3 viewDir = _WorldSpaceCameraPos.xyz - i.worldPos; viewDir = normalize(viewDir); float3x3 rotation = float3x3(i.mat1,i.mat2,i.mat3); //uppack normal fixed3 tangentNormal; fixed4 packedNormal = tex2D(_BumpMap,i.uv.zw); #if defined(UNITY_NO_DXT5nm) tangentNormal.xyz = packedNormal.xyz*2 -1; #else // --rgba -- xyzw //DXTnm 格式中a通道（即w分量）对应发现x分量,g通道（即y分量）对应发现y分量, //tangentNormal.xy = packedNormal.ag*2 -1; tangentNormal.xy = packedNormal.wy*2 -1; tangentNormal=tangentNormal* _BumpScale; tangentNormal.z = sqrt(1.0-max(0,dot(tangentNormal.xy,tangentNormal.xy))); #endif tangentNormal = mul(rotation,tangentNormal); fixed3 albedo = tex2D(_MainTex,i.uv).rgb*_Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz*albedo; fixed3 diffuse = _LightColor0.rgb*albedo*max(0,dot(tangentNormal,lightDir)); fixed3 halfDir = normalize(lightDir+viewDir); fixed3 specular = _LightColor0.rgb*_Specular.rgb*pow(max(0,dot(tangentNormal,halfDir)),_Gloss); return fixed4(ambient+diffuse+specular,1.0); } ENDCG } } } ","date":"2019-12-01 21:57:40","objectID":"/shader%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE%E4%B8%96%E7%95%8C%E7%A9%BA%E9%97%B4/:0:0","tags":["shader"],"title":"【Shader】 法线贴图（世界空间）","uri":"/shader%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE%E4%B8%96%E7%95%8C%E7%A9%BA%E9%97%B4/"},{"categories":["shader"],"content":" 角色死亡消融，尸体消融，地图烧毁特效 不带阴影 参考 《unity shader 入门精要》 // Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)' Shader \"Book/15.Dissolve\" { Properties { _BurnAmount(\"Burn Amount\",Range(0.0,1.0)) = 0.0 _LineWidth(\"Burn Line Width\",Range(0.0,0.2))=0.1 _MainTex (\"Albedo (RGB)\", 2D) = \"white\" {} _BumpMap(\"Bump Map\",2D)= \"white\" {} _BurnFirstColor(\"Burn First Color\",Color)= (1,0,0,1) _BurnSecondColor(\"Burn Second Color\",Color)= (1,0,0,1) _BurnMap(\"Burn Map\",2D)= \"white\" {} } SubShader { Tags {\"RenderType\"=\"Opaque\" \"Queue\"=\"Geometry\"} Pass { Tags {\"LightMode\"=\"ForwardBase\" } Cull Off CGPROGRAM #include \"UnityCG.cginc\" #include \"Lighting.cginc\" #include \"AutoLight.cginc\" #pragma multi_compile_fwdbase #pragma vertex vert #pragma fragment frag sampler2D _MainTex; sampler2D _BurnMap; sampler2D _BumpMap; float4 _BurnFirstColor; float4 _BurnSecondColor; float4 _MainTex_ST; float4 _BumpMap_ST; float4 _BurnMap_ST; float _BurnAmount,_LineWidth; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; float4 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float2 uvMainTex : TEXCOORD0; float2 uvBumpMap : TEXCOORD1; float2 uvBurnMap : TEXCOORD2; float3 lightDir : TEXCOORD3; float3 worldPos : TEXCOORD4; SHADOW_COORDS(5) }; v2f vert( a2v v ) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); //o.uvMainTex = v.texcoord*_MainTex_ST.xy + _MainTex_ST.zw; o.uvMainTex = TRANSFORM_TEX( v.texcoord,_MainTex); o.uvBumpMap = TRANSFORM_TEX( v.texcoord,_BumpMap); o.uvBurnMap = TRANSFORM_TEX( v.texcoord,_BurnMap); //副切线 float3 binormal = cross(v.normal,v.tangent.xyz)*v.tangent.w; //从模型空间到切线空间的转换矩阵 float3x3 rotation = float3x3(v.tangent.xyz,binormal,v.normal); //将光源位置减去顶点位置，这样就得到光照方向了 — 但是我们应该首先将顶点位置乘上光源的w分量，如果是平行光，w分量为0，得到的结果为0，说明顶点位置全变为(0.0, 0.0, 0.0)了，这样光照方向就是源 本的位置 （return objSpaceLightPos.xyz）。对于点光源，w为1，所以乘上顶点位置后，顶点位置无变化，这样计算的光照方向就是（return objSpaceLightPos.xyz – v.xyz）。 float3 lightDir = mul(unity_WorldToObject,_WorldSpaceLightPos0).xyz - v.vertex*_WorldSpaceLightPos0.w; o.lightDir = mul(rotation,lightDir); o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz; //o.worldNormal = normalize( mul(v.normal,(float3x3)unity_WorldToObject)); TRANSFER_SHADOW(o); return o; } /* 将上面的函数拷贝进来 */ half4 frag(v2f i) : SV_Target { fixed3 burn = tex2D(_BurnMap,i.uvBurnMap).rgb; clip(burn.r - _BurnAmount); float3 tangentLightDir = normalize(i.lightDir); //uppack normal fixed3 tangentNormal; fixed4 packedNormal = tex2D(_BumpMap,i.uvBumpMap); #if defined(UNITY_NO_DXT5nm) tangentNormal.xyz = packedNormal.xyz*2 -1; #else // --rgba -- xyzw //DXTnm 格式中a通道（即w分量）对应发现x分量,g通道（即y分量）对应发现y分量, //tangentNormal.xy = packedNormal.ag*2 -1; tangentNormal.xy = packedNormal.wy*2 -1; //tangentNormal=tangentNormal* _BumpScale; tangentNormal.z = sqrt(1.0-max(0,dot(tangentNormal.xy,tangentNormal.xy))); #endif fixed3 albedo = tex2D(_MainTex,i.uvMainTex).rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz*albedo; fixed3 diffuse = _LightColor0.rgb*albedo*max(0,dot(tangentNormal,tangentLightDir)); fixed t = 1 - smoothstep(0.0,_LineWidth,burn.r - _BurnAmount); fixed3 burnColor = lerp(_BurnFirstColor,_BurnSecondColor,t); burnColor = pow(burnColor,5); UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos); fixed3 finalColor = lerp(ambient+diffuse*atten,burnColor, t* step(0.0001,_BurnAmount)); return fixed4(finalColor,1); } ENDCG } } FallBack \"Diffuse\" } 效果图： ","date":"2019-12-01 21:57:40","objectID":"/shader%E6%B6%88%E8%9E%8D%E7%89%B9%E6%95%88/:0:0","tags":["shader"],"title":"【Shader】 消融特效","uri":"/shader%E6%B6%88%E8%9E%8D%E7%89%B9%E6%95%88/"},{"categories":["shader"],"content":" 参考 《unity shader 入门精要》 ","date":"2019-12-01 21:57:40","objectID":"/shader%E7%BA%B9%E7%90%86%E5%8A%A8%E7%94%BB/:0:0","tags":["shader"],"title":"【Shader】 纹理动画","uri":"/shader%E7%BA%B9%E7%90%86%E5%8A%A8%E7%94%BB/"},{"categories":["shader"],"content":"0X01 序列帧动画 ","date":"2019-12-01 21:57:40","objectID":"/shader%E7%BA%B9%E7%90%86%E5%8A%A8%E7%94%BB/:0:1","tags":["shader"],"title":"【Shader】 纹理动画","uri":"/shader%E7%BA%B9%E7%90%86%E5%8A%A8%E7%94%BB/"},{"categories":["shader"],"content":"爆炸的动画 // Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)' Shader \"Book/11.ImageSequenceAnimation\" { //折射 Properties { _Color (\"Color Tint\",Color)=(1,1,1,1) _MainTex(\"Main Tex\",2D)=\"white\"{} _HorizontalAmount(\"Horizontal Amount\",Float)=4.0 _VerticalAmount(\"Vertical Amount\",Float)=4.0 _Speed(\"Speed\",Range(1,100))=30.0 } SubShader { Tags { \"Queue\"=\"Transparent\" \"IgnoreProjector\"=\"True\" \"RenderType\"=\"Transparent\"} Pass { Tags { \"LightMode\"=\"ForwardBase\" } ZWrite Off Blend srcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag // make fog work //#pragma multi_compile_fog #include \"UnityCG.cginc\" float4 _Color; sampler2D _MainTex; float _HorizontalAmount,_VerticalAmount,_Speed; float4 _MainTex_ST; struct a2v { float4 vertex : POSITION; float3 normal: NORMAL; float4 tangent:TANGENT; float2 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float2 uv : TEXCOORD0; float3 lightDir:TEXCOORD1; float3 viewDir:TEXCOORD2; float3 worldNormal:TEXCOORD3; float3 worldPos:TEXCOORD4; float3 worldRefr:TEXCOORD5; }; v2f vert (a2v v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.texcoord,_MainTex); float time = floor(_Time.y*_Speed); float y = floor(time/_HorizontalAmount); float x = time - y*_HorizontalAmount; o.uv= o.uv +float2(x,-y); o.uv.x /= _HorizontalAmount; o.uv.y /= _VerticalAmount; return o; } fixed4 frag (v2f i) : SV_Target { float4 col = tex2D(_MainTex,i.uv); col.rgb*=_Color.rgb; return col; } fixed4 frag1 (v2f i) : SV_Target { float time = floor(_Time.y*_Speed); /* float offset = time%(_HorizontalAmount*_VerticalAmount); float offsetY=floor(offset/_HorizontalAmount); float offsetX = offset - offsetY*_HorizontalAmount; float2 uv = float2(i.uv.x/_HorizontalAmount,i.uv.y/_VerticalAmount) +float2(offsetX*1/_HorizontalAmount,-offsetY*1/_VerticalAmount); */ //想象成动画一直竖着往下滚动，向下无限远且循环，time是当前要播放第几帧的编号，这个编号一直无限增加 float y = floor(time/_HorizontalAmount); float x = time - y*_HorizontalAmount; float2 uv = i.uv +float2(x,-y); uv.x /= _HorizontalAmount; uv.y /= _VerticalAmount; float4 col = tex2D(_MainTex,uv); col.rgb*=_Color.rgb; return col; } ENDCG } } FallBack \"Diffuse\" } ","date":"2019-12-01 21:57:40","objectID":"/shader%E7%BA%B9%E7%90%86%E5%8A%A8%E7%94%BB/:0:2","tags":["shader"],"title":"【Shader】 纹理动画","uri":"/shader%E7%BA%B9%E7%90%86%E5%8A%A8%E7%94%BB/"},{"categories":["shader"],"content":"滚动背景 // Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)' Shader \"Book/11.ScrollingBackground\" { //折射 Properties { _MainTex(\"Base Layer\",2D)=\"white\"{} _DetailTex(\"2nd Layer\",2D)=\"white\"{} _ScrollX(\"Base Layer Scroll Speed\",Float)=4.0 _Scroll2X(\"2nd Layer Scroll Speed\",Float)=4.0 _Multiplier(\"Layer Multiplier\",Float)=1.0 } SubShader { Tags { \"RenderType\"=\"Opaque\" \"Queue\"=\"Geometry\"} Pass { Tags { \"LightMode\"=\"ForwardBase\" } ZWrite Off Blend srcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag // make fog work //#pragma multi_compile_fog #include \"UnityCG.cginc\" sampler2D _MainTex,_DetailTex; float _ScrollX,_Scroll2X,_Multiplier; float4 _MainTex_ST,_DetailTex_ST; struct a2v { float4 vertex : POSITION; float3 normal: NORMAL; float4 tangent:TANGENT; float2 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float4 uv : TEXCOORD0; float3 lightDir:TEXCOORD1; float3 viewDir:TEXCOORD2; float3 worldNormal:TEXCOORD3; float3 worldPos:TEXCOORD4; float3 worldRefr:TEXCOORD5; }; v2f vert (a2v v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.uv.xy = TRANSFORM_TEX(v.texcoord,_MainTex)+frac(float2(_ScrollX*_Time.y,0)); o.uv.zw = TRANSFORM_TEX(v.texcoord,_DetailTex)+frac(float2(_Scroll2X*_Time.y,0)); return o; } fixed4 frag (v2f i) : SV_Target { float4 baseColor = tex2D(_MainTex,i.uv.xy); float4 secondColor = tex2D(_DetailTex,i.uv.zw); fixed4 c = lerp(baseColor,secondColor,secondColor.a); c.rgb *= _Multiplier; return c; } ENDCG } } FallBack \"Diffuse\" } ","date":"2019-12-01 21:57:40","objectID":"/shader%E7%BA%B9%E7%90%86%E5%8A%A8%E7%94%BB/:0:3","tags":["shader"],"title":"【Shader】 纹理动画","uri":"/shader%E7%BA%B9%E7%90%86%E5%8A%A8%E7%94%BB/"},{"categories":["shader"],"content":"0X02 顶点动画 ","date":"2019-12-01 21:57:40","objectID":"/shader%E7%BA%B9%E7%90%86%E5%8A%A8%E7%94%BB/:0:4","tags":["shader"],"title":"【Shader】 纹理动画","uri":"/shader%E7%BA%B9%E7%90%86%E5%8A%A8%E7%94%BB/"},{"categories":["shader"],"content":"流动的河流 // Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)' Shader \"Book/11.Water\" { //折射 Properties { _MainTex(\"Main Tex\",2D)=\"white\"{} _Color(\"Color Tint\",Color)=(1,1,1,1) _Magnitude(\"Distortion Magnitude\",float)=1 _Frequency(\"Distortion Frequency\",float)=1 _InvWaveLength(\"Distortion Inverse Wave Length\",float)=10 _Speed(\"Speed\",float)=0.5 } SubShader { Tags { \"RenderType\"=\"Transparent\" \"Queue\"=\"Transparent\" \"IgnoreProjector\"=\"True\" \"DisableBatching\"=\"True\"} Pass { Tags { \"LightMode\"=\"ForwardBase\" } ZWrite Off Blend SrcAlpha OneMinusSrcAlpha Cull Off //Cull Front CGPROGRAM #pragma vertex vert #pragma fragment frag // make fog work //#pragma multi_compile_fog #include \"UnityCG.cginc\" float4 _Color; sampler2D _MainTex; float _Magnitude,_Frequency,_InvWaveLength,_Speed; float4 _MainTex_ST; struct a2v { float4 vertex : POSITION; float3 normal: NORMAL; float4 tangent:TANGENT; float2 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float4 uv : TEXCOORD0; float3 lightDir:TEXCOORD1; float3 viewDir:TEXCOORD2; float3 worldNormal:TEXCOORD3; float3 worldPos:TEXCOORD4; float3 worldRefr:TEXCOORD5; }; v2f vert (a2v v) { v2f o; float4 offset=float4(0,0,0,0); //offset.x = sin(_Time.y*_Frequency+(v.vertex.x+v.vertex.y+v.vertex.z)*_InvWaveLength)*_Magnitude; offset.x = sin(_Time.y*_Frequency+(v.vertex.z)*_InvWaveLength)*_Magnitude; //offset.x = sin((v.vertex.z)*_InvWaveLength)*_Magnitude; o.pos = UnityObjectToClipPos(v.vertex+offset); o.uv.xy = TRANSFORM_TEX(v.texcoord,_MainTex)+frac(float2(0,_Speed*_Time.y)); return o; } fixed4 frag (v2f i) : SV_Target { fixed4 c = tex2D(_MainTex,i.uv.xy);; return c; } ENDCG } } FallBack \"Diffuse\" } ","date":"2019-12-01 21:57:40","objectID":"/shader%E7%BA%B9%E7%90%86%E5%8A%A8%E7%94%BB/:0:5","tags":["shader"],"title":"【Shader】 纹理动画","uri":"/shader%E7%BA%B9%E7%90%86%E5%8A%A8%E7%94%BB/"},{"categories":["shader"],"content":"广告牌（始终面向摄像机） // Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)' Shader \"Book/11.Billboard\" { //折射 Properties { _MainTex(\"Main Tex\",2D)=\"white\"{} _Color(\"Color Tint\",Color)=(1,1,1,1) _VerticalBillboarding(\"Vertical Restraints\",Range(0,1))=1 } SubShader { Tags { \"RenderType\"=\"Transparent\" \"Queue\"=\"Transparent\" \"IgnoreProjector\"=\"True\" \"DisableBatching\"=\"True\"} //Tags { \"RenderType\"=\"Transparent\" \"Queue\"=\"Transparent\" \"IgnoreProjector\"=\"True\"} Pass { Tags { \"LightMode\"=\"ForwardBase\" } ZWrite Off Blend SrcAlpha OneMinusSrcAlpha //Cull Front Cull Off CGPROGRAM #pragma vertex vert #pragma fragment frag // make fog work //#pragma multi_compile_fog #include \"UnityCG.cginc\" float4 _Color; sampler2D _MainTex; float _VerticalBillboarding; float4 _MainTex_ST; struct a2v { float4 vertex : POSITION; float3 normal: NORMAL; float4 tangent:TANGENT; float2 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float4 uv : TEXCOORD0; float3 lightDir:TEXCOORD1; float3 viewDir:TEXCOORD2; float3 worldNormal:TEXCOORD3; float3 worldPos:TEXCOORD4; float3 worldRefr:TEXCOORD5; }; v2f vert (a2v v) { v2f o; float3 center = float3(0,0,0); float3 viewer = mul(unity_WorldToObject,float4(_WorldSpaceCameraPos,1)); float3 normalDir =viewer-center; normalDir.y=normalDir.y*_VerticalBillboarding; normalDir = normalize(normalDir); float3 upDir = abs(normalDir.y)\u003e0.999?float3(0,0,1): float3(0,1,0); float3 rightDir=normalize(cross(upDir,normalDir)); upDir = normalize(cross(normalDir,rightDir)); float3 centerOffs = v.vertex.xyz - center; float3 localPos = center+ rightDir*centerOffs.x+upDir*centerOffs.y+normalDir*centerOffs.z; //o.pos = mul(UNITY_MATRIX_MVP,float4(localPos,1)); o.pos = UnityObjectToClipPos(float4(localPos, 1)); o.uv.xy = TRANSFORM_TEX(v.texcoord,_MainTex); return o; } fixed4 frag (v2f i) : SV_Target { fixed4 c = tex2D(_MainTex,i.uv.xy);; c.rgb*=_Color.rgb; return c; } ENDCG } } FallBack \"Transparent/VertexLit\" } ","date":"2019-12-01 21:57:40","objectID":"/shader%E7%BA%B9%E7%90%86%E5%8A%A8%E7%94%BB/:0:6","tags":["shader"],"title":"【Shader】 纹理动画","uri":"/shader%E7%BA%B9%E7%90%86%E5%8A%A8%E7%94%BB/"},{"categories":["Unity"],"content":" 转自：MaterialPropertyBlock 设置多个相同模型的各自颜色一般是设置材质球颜色时如 gameObject.GetComponent\u003cMeshRenderer\u003e().material.color=Color.red; 这样会产生新的material实例，可以通过profile观察到，drawcall增加； ==优化方案==： 设置顶点颜色(需要shader的顶点着色器支持) gameObject.GetComponent\u003cMeshFilter\u003e().mesh.colors 通过设置MaterialPropertyBlock来设置多个模型的各自颜色（简单方便） MaterialPropertyBlock mpb = new MaterialPropertyBlock(); gameObject.GetComponent\u003cMeshRenderer\u003e().GetPropertyBlock(mpb); mpb.SetColor(\"_Color\", Color.red); gameObject.GetComponent\u003cMeshRenderer\u003e().SetPropertyBlock(mpb); ==详细内容参考 MaterialPropertyBlock== ","date":"2019-12-01 21:57:40","objectID":"/unity%E4%BC%98%E5%8C%96-%E7%9B%B8%E5%90%8C%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%A4%9A%E4%B8%AA%E5%AE%9E%E4%BE%8B%E8%AE%BE%E7%BD%AE%E5%90%84%E8%87%AA%E7%9A%84%E9%A2%9C%E8%89%B2%E4%BC%98%E5%8C%96/:0:0","tags":["Unity"],"title":"【unity优化】相同模型的多个实例设置各自的颜色优化","uri":"/unity%E4%BC%98%E5%8C%96-%E7%9B%B8%E5%90%8C%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%A4%9A%E4%B8%AA%E5%AE%9E%E4%BE%8B%E8%AE%BE%E7%BD%AE%E5%90%84%E8%87%AA%E7%9A%84%E9%A2%9C%E8%89%B2%E4%BC%98%E5%8C%96/"},{"categories":["UGUI优化"],"content":" ui中使用好多像按钮等对称的图片，如果使用1/2、1/4图片将大量的节省内存，这里详细说下这个解决方案； unity版本：2018.2.13f1 ugui源码版本2018.2（这里在这个版本基础上修改的） 使用的素材有1/2、1/4图片 下面1/2图片 左边1/2图片 左下1/4图片 这里新建类MirrorImage继承Image，对Image功能进行扩展 根据ImageType 分为四种扩展：Simple，Sliced，Tiled，Filled；只处理了三种 0X01 Simple类型 1.先在MirrorImage中增加变量mirrorType来定义当前原始素材是是要用什么镜像类型 /// \u003csummary\u003e /// 镜像类型 /// \u003c/summary\u003e public enum MirrorType { /// \u003csummary\u003e /// 水平 /// 提供左侧一半素材 /// \u003c/summary\u003e Horizontal, /// \u003csummary\u003e /// 垂直 /// 提供下侧一半素材 /// \u003c/summary\u003e Vertical, /// \u003csummary\u003e /// 四分之一 /// 相当于水平，然后再垂直 /// 提供左下侧素材 /// \u003c/summary\u003e Quarter } /// \u003csummary\u003e /// 镜像类型 /// \u003c/summary\u003e [SerializeField] private MirrorType _mirrorType = MirrorType.Horizontal; public MirrorType mirrorType { get { return _mirrorType; } set { if (_mirrorType != value) { _mirrorType = value; SetVerticesDirty(); } } } 这个地方需要修改editor，下面有整个工程，可以看下 2.重写SetNativeSize方法，实现自动扩展MirrorImage镜像的大小,根据素材的大小和镜像类型来自动配置image大小 public override void SetNativeSize() { if (sprite != null) { float w = sprite.rect.width / pixelsPerUnit; float h = sprite.rect.height / pixelsPerUnit; if (mirrorType== MirrorType.Horizontal) { w *= 2; } else if (mirrorType == MirrorType.Vertical) { h *= 2; } else { w *= 2; h *= 2; } rectTransform.anchorMax = rectTransform.anchorMin; rectTransform.sizeDelta = new Vector2(w, h); SetAllDirty(); } } 3 重写OnPopulateMesh方法，这个方法会修改mesh信息，然后给Graphic protected override void OnPopulateMesh(VertexHelper toFill) { Sprite _sprite = overrideSprite != null ? overrideSprite : sprite; if (_sprite == null) { base.OnPopulateMesh(toFill); return; } switch (type) { case Type.Simple: GenerateSimpleSprite(toFill, preserveAspect); break; case Type.Sliced: //GenerateSlicedSprite(toFill); break; case Type.Tiled: //GenerateTiledSprite(toFill); break; case Type.Filled: //GenerateFilledSprite(toFill, m_PreserveAspect); break; } } 这里先处理Simple类型 4. 修改Mesh信息和uv信息，在Image原来的基础上，将mesh增加两个顶点（1/2图片），如果是Horizontal镜像类型，将右侧两个定点移动到中间，在右侧增加这两个定点，uv信息要和左侧的对称 /// \u003csummary\u003e /// Generate vertices for a simple Image. /// \u003c/summary\u003e void GenerateSimpleSprite(VertexHelper vh, bool lPreserveAspect) { Vector4 v = GetDrawingDimensions(lPreserveAspect); var uv = (sprite != null) ? DataUtility.GetOuterUV(sprite) : Vector4.zero; Vector4 v1 = v; //Debug.Log(\"uv::::\" + uv + \" v:\" + v+ \" center:\"+ rectTransform.rect.center+ \" rect:\" + rectTransform.rect); switch (mirrorType) { case MirrorType.Horizontal: v.z = (v.z + v.x) / 2; break; case MirrorType.Vertical: v.w = (v.w + v.y) / 2; break; case MirrorType.Quarter: v.z = (v.z + v.x) / 2; v.w = (v.w + v.y) / 2; break; default: break; } //v.w = (v.w + v.y) / 2; //Debug.Log(\"uv::::\" + uv + \" v:\" + v + \" center:\" + rectTransform.rect.center + \" rect:\" + rectTransform.rect); var color32 = color; vh.Clear(); vh.AddVert(new Vector3(v.x, v.y), color32, new Vector2(uv.x, uv.y)); vh.AddVert(new Vector3(v.x, v.w), color32, new Vector2(uv.x, uv.w)); vh.AddVert(new Vector3(v.z, v.w), color32, new Vector2(uv.z, uv.w)); vh.AddVert(new Vector3(v.z, v.y), color32, new Vector2(uv.z, uv.y)); vh.AddTriangle(0, 1, 2); vh.AddTriangle(2, 3, 0); switch (mirrorType) { /// 1,2,5 /// 0,3,4 case MirrorType.Horizontal: vh.AddVert(new Vector3(v1.z, v1.y), color32, new Vector2(uv.x, uv.y)); vh.AddVert(new Vector3(v1.z, v1.w), color32, new Vector2(uv.x, uv.w)); vh.AddTriangle(3, 2, 5); vh.AddTriangle(5, 4, 3); break; //4,5 //1,2 //0,3 case MirrorType.Vertical: vh.AddVert(new Vector3(v1.x, v1.w), color32, new Vector2(uv.x, uv.y)); vh.AddVert(new Vector3(v1.z, v1.w), color32, new Vector2(uv.z, uv.y)); vh.AddTriangle(1, 4, 5); vh.AddTriangle(5, 2, 1); break; /// 8,7,6 /// 1,2,5 /// 0,3,4 case MirrorType.Quarter: vh.AddVert(new Vector3(v1.z, v1.y), color32, new Vector2(uv.x, uv.y)); vh.AddVert(new Vector3(v1.z, v.w), color32, new Vector2(uv.x, uv.w)); vh.AddTriangle(3, 2, 5); vh.AddTriangle(5, 4, 3); vh.AddVert(new Vector3(v1.z, v1.w), color32, new Vector2(uv.x, uv.y)); vh.AddVert(new Vector3(v.z, v1.w), color32, new Vector2(uv.z, uv.y)); vh.AddVert(new Vector3(v1.x, v1.w), color32, n","date":"2019-12-01 21:57:40","objectID":"/ugui%E4%BC%98%E5%8C%96-%E4%BD%BF%E7%94%A8%E9%95%9C%E5%83%8F%E5%9B%BE%E7%89%87/:0:0","tags":["UGUI","unity优化"],"title":"【Unity优化】：使用镜像图片","uri":"/ugui%E4%BC%98%E5%8C%96-%E4%BD%BF%E7%94%A8%E9%95%9C%E5%83%8F%E5%9B%BE%E7%89%87/"},{"categories":["Unity编辑器"],"content":" 今天用到了在Hierarchy中扩展右键的功能，这里整理下菜单扩展资料 这里只是简单整理，如果需要详细的直接看参考文章 ","date":"2019-12-01 21:57:40","objectID":"/unity%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95%E8%8F%9C%E5%8D%95%E9%A1%B9/:0:0","tags":["Unity编辑器"],"title":"【Unity编辑器】 扩展菜单项及右键菜单","uri":"/unity%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95%E8%8F%9C%E5%8D%95%E9%A1%B9/"},{"categories":["Unity编辑器"],"content":"API说明： [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)] [RequiredByNativeCode] public sealed class MenuItem : Attribute { public string menuItem; public bool validate; public int priority; public MenuItem(string itemName); public MenuItem(string itemName, bool isValidateFunction); public MenuItem(string itemName, bool isValidateFunction, int priority); } 可知MenuItem最多有三个参数： 参数一表示MenuItem所处的路径 参数二表示是否有验证方法 参数三表示MenuItem在整个Menu中所处的优先级 ","date":"2019-12-01 21:57:40","objectID":"/unity%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95%E8%8F%9C%E5%8D%95%E9%A1%B9/:0:1","tags":["Unity编辑器"],"title":"【Unity编辑器】 扩展菜单项及右键菜单","uri":"/unity%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95%E8%8F%9C%E5%8D%95%E9%A1%B9/"},{"categories":["Unity编辑器"],"content":"普通用法 需要将脚本放到Editor目录中；Editor目录可以在其他普通目录的子目录中 需要UnityEditor命名空间 [MenuItem(\"Tools/Test\", false, 2200)] public static void Create(MenuCommand menuCommand) { GameObject parent = menuCommand.context as GameObject; } ","date":"2019-12-01 21:57:40","objectID":"/unity%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95%E8%8F%9C%E5%8D%95%E9%A1%B9/:0:2","tags":["Unity编辑器"],"title":"【Unity编辑器】 扩展菜单项及右键菜单","uri":"/unity%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95%E8%8F%9C%E5%8D%95%E9%A1%B9/"},{"categories":["Unity编辑器"],"content":"特殊用法 在project右键使用 [MenuItem(\"Assets/Tes2\", false)] public static void Create2() { } 在Hierarchy右键使用 /* * 这里注意 priority参数，值要控制在-10到49之间 */ [MenuItem(\"GameObject/Tes1\", false, 0)] public static void Create1() { } 在Scene右键使用 [InitializeOnLoadMethod] static void Init() { SceneView.onSceneGUIDelegate += OnSceneGUI; } static void OnSceneGUI(SceneView sceneView) { Event e = Event.current; if (e != null \u0026\u0026 e.button == 1 \u0026\u0026 e.type == EventType.MouseUp) { //右键单击啦，在这里显示菜单 GenericMenu menu = new GenericMenu(); menu.AddItem(new GUIContent(\"菜单项1\"), false, OnMenuClick, \"menu_1\"); menu.AddItem(new GUIContent(\"菜单项2\"), false, OnMenuClick, \"menu_2\"); menu.AddItem(new GUIContent(\"菜单项3\"), false, OnMenuClick, \"menu_3\"); menu.ShowAsContext(); } } static void OnMenuClick(object userData) { EditorUtility.DisplayDialog(\"Tip\", \"OnMenuClick\" + userData.ToString(), \"Ok\"); } 参考文章： Unity编辑器扩展-在Scene视图添加右键菜单 https://blog.csdn.net/zw514159799/article/details/50775502 http://m.manew.com/thread-90330-1-1.html https://blog.csdn.net/WPAPA/article/details/51066397 ","date":"2019-12-01 21:57:40","objectID":"/unity%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95%E8%8F%9C%E5%8D%95%E9%A1%B9/:0:3","tags":["Unity编辑器"],"title":"【Unity编辑器】 扩展菜单项及右键菜单","uri":"/unity%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95%E8%8F%9C%E5%8D%95%E9%A1%B9/"},{"categories":["数据结构基础"],"content":" 本文以单精度的内存存储来说明的 ","date":"2019-12-01 21:57:40","objectID":"/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8%E5%92%8C%E8%BF%90%E7%AE%97/:0:0","tags":["数据结构基础"],"title":"【数据结构基础】 浮点数的内存存储和运算","uri":"/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8%E5%92%8C%E8%BF%90%E7%AE%97/"},{"categories":["数据结构基础"],"content":"0X01 浮点数的内存存储 IEEE 754浮点数标准规定的浮点数结构： S E M 公式｛V=(-1)S*2E*M ；E=e-Bias｝ 偏移量 单精度 1 8 23 (-1)S*2(e-127)*M ；(Bias = 127) 127 双精度 1 11 52 (-1)S*2(e-1023)*M；(Bias = 1023) 1023 S是符号位，E是阶码，Bias = 2k-1 -1 。 M是尾数编码，尾数m为内存中小数字段，其值依赖于阶码e是否为0，当e!=0时M=1.m;当e=0时M=0.m; 其中S符号位，只有0和1，分别表示正负；E阶码，通常使用移码表示（原码、反码、补码和移码详解）。 二进制存储结构(单精度浮点数)： 单精度 S(第31位) e((30位到23位)) m(22位到0位) 双精度 S(第63位) e((62位到52位)) m(51位到0位) 单精度浮点数和双精度浮点数都是用IEEE754标准定义的，其中有一些 约定： 规格化的 e!=0\u0026e!=255 非规格化的 e=0; 这里阶码E约定为固定值，E=1-Bias,（单精度时E=-126,双精度E=-1022）; 无穷 e=255 \u0026 m=0 ;阶码全为1，小数域全为0，根据符号位S来确定无穷大(s=0)还是无穷小(s=1) NaN（Not a Number，不是一个数） e=255 \u0026 m!=0；阶码全为1，小数域不为0 E用移码表示，为了提供一种从非规格化值到规格化值平滑转换的方法 (为了规格化最小数和非规格化最大数平滑转变) ","date":"2019-12-01 21:57:40","objectID":"/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8%E5%92%8C%E8%BF%90%E7%AE%97/:1:0","tags":["数据结构基础"],"title":"【数据结构基础】 浮点数的内存存储和运算","uri":"/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8%E5%92%8C%E8%BF%90%E7%AE%97/"},{"categories":["数据结构基础"],"content":"0X02 极限值说明 Console.WriteLine(float.MaxValue); // 3.402823E+38 Console.WriteLine(float.MinValue); //-3.402823E+38 Console.WriteLine(float.Epsilon); // 1.401298E-45 1.最大值 S位取0，E位最大值取255-1 = 254，因为255有特殊含义 254=(11111110)~2~，M尾数m为11111111111111111111111)~2~ 二进制表示： 01111111011111111111111111111111 2.最小值 S位取1，E位最大值取255-1 = 254，因为255有特殊含义 254=(11111110)~2~，M尾数m为(11111111111111111111111)~2~ 二进制表示： 11111111011111111111111111111111 3.最接近0的浮点数（+0） 这里就得用非规格数来表示了，符号位S取0，阶码E取0，M尾数m取最小值为(00000000000000000000001)~2~ 二进制表示： 00000000000000000000000000000001 这里补充上代码： using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace floatTest1 { class Program { /// \u003csummary\u003e /// 打印浮点数的二进制 /// \u003c/summary\u003e /// \u003cparam name=\"a\"\u003e\u003c/param\u003e unsafe static void FToB(float a) { float* p = \u0026a; int b = *(int*)p; Console.WriteLine(Convert.ToString(b, 2)); } /// \u003csummary\u003e /// 最大值 /// \u003c/summary\u003e unsafe static void DebugMaxFloat() { float b = 0f; int* p = (int*)\u0026b; //这里是以符号位下标为0，先压入最高位，最后压入最低位 for (int i = 0; i \u003c 32; i++) { int bit = 1; //符号位 0 if (i == 0) { bit = 0; } //阶码 1-8 else if (i \u003e= 1 \u0026\u0026 i \u003c= 8) { //254的二进制是11111110,最后一位为0； if (i == 8) { bit = 0; } } //尾数 9-31 else { bit = 1; } *p = *p \u003c\u003c 1; *p = *p ^ bit; } //*p =* p \u003e\u003e 1; FToB(b); Console.WriteLine(\"Max::::\"+b); } /// \u003csummary\u003e /// 最小值 /// \u003c/summary\u003e unsafe static void DebugMinFloat() { float b = 0f; int* p = (int*)\u0026b; //这里是以符号位下标为0，先压入最高位，最后压入最低位 for (int i = 0; i \u003c 32; i++) { int bit = 1; //符号位 0 if (i == 0) { bit = 1; } //阶码 1-8 else if (i \u003e= 1 \u0026\u0026 i \u003c= 8) { //254的二进制是11111110,最后一位为0； if (i == 8) { bit = 0; } } //尾数 9-31 else { bit = 1; } *p = *p \u003c\u003c 1; *p = *p ^ bit; } //*p =* p \u003e\u003e 1; FToB(b); Console.WriteLine(\"Min::::\" + b); } /// \u003csummary\u003e /// 最接近于+0的数 /// \u003c/summary\u003e unsafe static void DebugEpsilonFloat() { float b = 0f; int* p = (int*)\u0026b; //这里是以符号位下标为0，先压入最高位，最后压入最低位 for (int i = 0; i \u003c 32; i++) { int bit = 1; //符号位 0 if (i == 0) { bit = 0; } //阶码 1-8 else if (i \u003e= 1 \u0026\u0026 i \u003c= 8) { //阶码取0，非规格化值， bit = 0; } //尾数 9-31 else { //尾数取1； if(i==31) { bit = 1; } else { bit = 0; } } *p = *p \u003c\u003c 1; *p = *p ^ bit; } //*p =* p \u003e\u003e 1; FToB(b); Console.WriteLine(\"Epsilon::::\" + b); } unsafe static void Main(string[] args) { Console.WriteLine(\"Max=\"+float.MaxValue); // 3.402823E+38 Console.WriteLine(\"Min=\" + float.MinValue); //-3.402823E+38 Console.WriteLine(\"Epsilon=\" + float.Epsilon); // 1.401298E-45 Console.WriteLine(\"------------------------------------------------------------------------------------\"); DebugMaxFloat(); DebugMinFloat(); DebugEpsilonFloat(); } } } ","date":"2019-12-01 21:57:40","objectID":"/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8%E5%92%8C%E8%BF%90%E7%AE%97/:2:0","tags":["数据结构基础"],"title":"【数据结构基础】 浮点数的内存存储和运算","uri":"/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8%E5%92%8C%E8%BF%90%E7%AE%97/"},{"categories":["数据结构基础"],"content":"0X03 举例单精度浮点数的表示 1.整数位表示 以a = 8为例子，8的二进制1000=1*2^3^,符号位S=0;E = 3+127=130=(10000010)~2~；M尾数1.m=1.0,m全是0； 所以表示出来为： 01000001000000000000000000000000 2.小数位表示 以a= 0.75为例子 0.75 = (1.1*2^-1^)~2~,符号位S=0;E = -1+127 = 126=(01111110)~2~;M尾数1.m=1.1，m=(10000000000000000000000)~2~ ；所以表示出来的数为： 00111111010000000000000000000000 3.带整数位和小数位的表示 以a=8.75为例子，8.75= (1000.11)~2~=(1.00011*2^3^)~2~,符号位S=0;E= 3+127=130=(10000010)~2~；M尾数1.m=1.00011 , m=(00011000000000000000000)~2~;所以表示出来的数为： 01000001000011000000000000000000 上代码： /// \u003csummary\u003e /// 打印浮点数的二进制 /// \u003c/summary\u003e /// \u003cparam name=\"a\"\u003e\u003c/param\u003e unsafe static void FToB(float a) { float* p = \u0026a; int b = *(int*)p; Console.WriteLine(Convert.ToString(b, 2)); } unsafe static void Main(string[] args) { FToB(8f); FToB(0.75f); FToB(8.75f); } 结果： ","date":"2019-12-01 21:57:40","objectID":"/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8%E5%92%8C%E8%BF%90%E7%AE%97/:3:0","tags":["数据结构基础"],"title":"【数据结构基础】 浮点数的内存存储和运算","uri":"/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8%E5%92%8C%E8%BF%90%E7%AE%97/"},{"categories":["数据结构基础"],"content":"0X04 浮点数的运算 参考这篇文章：浮点数的表示和基本运算 文章参考： 浮点数的表示和基本运算 浮点型 float double IEEE-754 Analysis 2.7.1 浮点加法和减法 2.7.2 浮点乘、除法运算 浮点加法、减法, 乘法、除法运算 ","date":"2019-12-01 21:57:40","objectID":"/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8%E5%92%8C%E8%BF%90%E7%AE%97/:4:0","tags":["数据结构基础"],"title":"【数据结构基础】 浮点数的内存存储和运算","uri":"/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8%E5%92%8C%E8%BF%90%E7%AE%97/"},{"categories":["Math"],"content":" 高中知识忘的差不多了，前段时间重新推导了和差化积的公式，这里做下记录 ","date":"2019-12-01 21:57:40","objectID":"/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%92%8C%E5%B7%AE%E5%85%AC%E5%BC%8F%E7%9A%84%E6%8E%A8%E5%AF%BC/:0:0","tags":["Math"],"title":"三角函数和差公式的推导","uri":"/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%92%8C%E5%B7%AE%E5%85%AC%E5%BC%8F%E7%9A%84%E6%8E%A8%E5%AF%BC/"},{"categories":["Math"],"content":" 0X01 三角函数公式推导 两角和的公式 sin(A+B)=sinAcosB+cosAsinB sin(A-B)=sinAcosB-sinBcosA cos(A+B)=cosAcosB-sinAsinB cos(A-B)=cosAcosB+sinAsinB tan(A+B)=(tanA+tanB)/(1-tanAtanB) tan(A-B)=(tanA-tanB)/(1+tanAtanB) cot(A+B)=(cotAcotB-1)/(cotB+cotA) cot(A-B)=(cotAcotB+1)/(cotB-cotA) 倍角的公式 tan2A=2tanA/(1-tan2A) cot2A=(cot2A-1)/2cota cos2a=cos2a-sin2a=2cos2a-1=1-2sin2a sinα+sin(α+2π/n)+sin(α+2π2/n)+sin(α+2π3/n)+……+sin[α+2π*(n-1)/n]=0 cosα+cos(α+2π/n)+cos(α+2π2/n)+cos(α+2π3/n)+……+cos[α+2π*(n-1)/n]=0 以及 sin^2(α)+sin^2(α-2π/3)+sin^2(α+2π/3)=3/2 tanAtanBtan(A+B)+tanA+tanB-tan(A+B)=0 四倍角之公式： sin4A=-4*(cosAsinA(2*sinA^2-1)) cos4A=1+(-8cosA^2+8cosA^4) tan4A=(4tanA-4tanA^3)/(1-6*tanA^2+tanA^4) 五倍将式： sin5A=16sinA^5-20sinA^3+5sinA cos5A=16cosA^5-20cosA^3+5cosA tan5A=tanA*(5-10tanA^2+tanA^4)/(1-10tanA^2+5*tanA^4) 六倍将式： sin6A=2*(cosAsinA(2sinA+1)(2sinA-1)(-3+4*sinA^2)) cos6A=((-1+2cosA^2)(16cosA^4-16cosA^2+1)) tan6A=(-6tanA+20tanA^3-6tanA^5)/(-1+15tanA^2-15*tanA^4+tanA^6) 七倍将式： sin7A=-(sinA*(56sinA^2-112sinA^4-7+64*sinA^6)) cos7A=(cosA*(56cosA^2-112cosA^4+64*cosA^6-7)) tan7A=tanA*(-7+35tanA^2-21tanA^4+tanA^6)/(-1+21tanA^2-35tanA^4+7*tanA^6) 八倍将式： sin8A=-8*(cosAsinA(2sinA^2-1)(-8sinA^2+8sinA^4+1)) cos8A=1+(160cosA^4-256cosA^6+128cosA^8-32cosA^2) tan8A=-8tanA(-1+7tanA^2-7tanA^4+tanA^6)/(1-28tanA^2+70tanA^4-28*tanA^6+tanA^8) 九倍将式： sin9A=(sinA*(-3+4sinA^2)(64sinA^6-96sinA^4+36*sinA^2-3)) cos9A=(cosA*(-3+4cosA^2)(64cosA^6-96cosA^4+36*cosA^2-3)) tan9A=tanA*(9-84tanA^2+126tanA^4-36tanA^6+tanA^8)/(1-36tanA^2+126tanA^4-84tanA^6+9*tanA^8) 十倍将式： sin10A=2*(cosAsinA(4sinA^2+2sinA-1)(4sinA^2-2sinA-1)(-20sinA^2+5+16sinA^4)) cos10A=((-1+2cosA^2)(256cosA^8-512cosA^6+304cosA^4-48cosA^2+1)) tan10A=-2tanA(5-60tanA^2+126tanA^4-60tanA^6+5tanA^8)/(-1+45tanA^2-210tanA^4+210tanA^6-45tanA^8+tanA^10) ·万能公式： sinα=2tan(α/2)/[1+tan^2(α/2)] cosα=1-tan^2(α/2)/1+tan^2(α/2) tanα=2tan(α/2)/[1-tan^2(α/2)] 半将式 sin(A/2)=√((1-cosA)/2) sin(A/2)=-√((1-cosA)/2) cos(A/2)=√((1+cosA)/2) cos(A/2)=-√((1+cosA)/2) tan(A/2)=√((1-cosA)/((1+cosA)) tan(A/2)=-√((1-cosA)/((1+cosA)) cot(A/2)=√((1+cosA)/((1-cosA)) cot(A/2)=-√((1+cosA)/((1-cosA)) 和差化积 2sinAcosB=sin(A+B)+sin(A-B) 2cosAsinB=sin(A+B)-sin(A-B) 2cosAcosB=cos(A+B)-sin(A-B) -2sinAsinB=cos(A+B)-cos(A-B) sinA+sinB=2sin((A+B)/2)cos((A-B)/2 cosA+cosB=2cos((A+B)/2)sin((A-B)/2) tanA+tanB=sin(A+B)/cosAcosB tanA-tanB=sin(A-B)/cosAcosB cotA+cotBsin(A+B)/sinAsinB -cotA+cotBsin(A+B)/sinAsinB 某些数列前n项和 1+2+3+4+5+6+7+8+9+…+n=n(n+1)/2 1+3+5+7+9+11+13+15+…+(2n-1)=n2 2+4+6+8+10+12+14+…+(2n)=n(n+1) 1^2+2^2+3^2+4^2+5^2+6^2+7^2+8^2+…+n^2=n(n+1)(2n+1)/6 1^3+2^3+3^3+4^3+5^3+6^3+…n^3=(n(n+1)/2)^2 12+23+34+45+56+67+…+n(n+1)=n(n+1)(n+2)/3 正弦定理 a/sinA=b/sinB=c/sinC=2R 注： 其中 R 表示三角形的外接圆半径 余弦定理 b2=a2+c2-2accosB 注：角B是边a和边c的夹角 乘法与因式分 a2-b2=(a+b)(a-b) a3+b3=(a+b)(a2-ab+b2) a3-b3=(a-b(a2+ab+b2) 三角不等式 |a+b|≤|a|+|b| |a-b|≤|a|+|b| |a|≤b\u003c=\u003e-b≤a≤b |a-b|≥|a|-|b| -|a|≤a≤|a| ","date":"2019-12-01 21:57:40","objectID":"/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%92%8C%E5%B7%AE%E5%85%AC%E5%BC%8F%E7%9A%84%E6%8E%A8%E5%AF%BC/:0:1","tags":["Math"],"title":"三角函数和差公式的推导","uri":"/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%92%8C%E5%B7%AE%E5%85%AC%E5%BC%8F%E7%9A%84%E6%8E%A8%E5%AF%BC/"},{"categories":["Math"],"content":" 0X02 sin($\\alpha$+$\\beta$)推导 参考文章 三角函数和差公式的推导 三角函数公式 ","date":"2019-12-01 21:57:40","objectID":"/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%92%8C%E5%B7%AE%E5%85%AC%E5%BC%8F%E7%9A%84%E6%8E%A8%E5%AF%BC/:0:2","tags":["Math"],"title":"三角函数和差公式的推导","uri":"/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%92%8C%E5%B7%AE%E5%85%AC%E5%BC%8F%E7%9A%84%E6%8E%A8%E5%AF%BC/"},{"categories":["Math"],"content":" 直接上连接：https://blog.csdn.net/cai18381306175/article/details/79285490 bool res = Abs(x0-x1)\u003cW \u0026\u0026 Abs(y0-y1)\u003cH ","date":"2019-12-01 21:57:40","objectID":"/%E4%B8%A4%E4%B8%AA%E5%B9%B3%E9%9D%A2%E7%9F%A9%E5%BD%A2%E7%9B%B8%E4%BA%A4%E4%B8%8D%E6%97%8B%E8%BD%AC/:0:0","tags":["Math"],"title":"两个平面矩形相交（不旋转）","uri":"/%E4%B8%A4%E4%B8%AA%E5%B9%B3%E9%9D%A2%E7%9F%A9%E5%BD%A2%E7%9B%B8%E4%BA%A4%E4%B8%8D%E6%97%8B%E8%BD%AC/"},{"categories":["深入理解计算机系统"],"content":"color=#0099ff size=72 face=\"黑体\"-- 背景色是：orange-- 1.为什么用补码 先说明同余的概念:同余运算及其基本性质 关于同余负数问题，可以用负数，但是得想清楚为啥 怎样直白地理解补码原理？ 参考上面文章基本能明白了为什么用补码，为了用加法器能计算负数； 总结上面的结论: 那为什么正负数要隔开呢？ ———为了制造出类似原码的符号位，这样补码转换原码的时候，就可以区分转换了。正数不变，负数取反加一。 为什么是取反加一呢？ ———根据原码负数时 [x]补=M-|x|推出来的 ，这是原始式子，也挺好记的比如-8的补码就是256-8 = 248，-128的就是128,。 那为什么原码取反加一为补码，补码取反加一为原码？ ———因为负数的补码，根据前面所说和原码是互补的，根据[x]补=M-|x|推出来的公式。肯定是相同的，所以求原码也就相当求补了。 2.为什么有符号单字节最小是-128 这里说下为啥有符号单字节最小取-128，而不是最大取128，这里纠结了好久了。 -128的补码是10000000,如果128存在也是10000000； 1.假设10000000代表128，则计算128+1 为： 10000000 + 00000001 --------------------- 10000001 而10000001是-127，加法器计算错误； 2.假设10000000代表-128，则计算-128+1 为： 10000000 + 00000001 --------------------- 10000001 而10000001是-127，加法器计算正确； 所以取10000000为-128 这里纯个人理解，如有不对的地方望指正 ","date":"2019-12-01 21:57:40","objectID":"/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E8%A1%A5%E7%A0%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%8D%95%E5%AD%97%E8%8A%82%E6%9C%80%E5%B0%8F%E6%98%AF-128/:0:0","tags":["深入理解计算机系统"],"title":"为什么用补码，为什么有符号单字节最小是-128","uri":"/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E8%A1%A5%E7%A0%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%8D%95%E5%AD%97%E8%8A%82%E6%9C%80%E5%B0%8F%E6%98%AF-128/"},{"categories":["深入理解计算机系统"],"content":" 参考文章 C++：位操作基础篇之位操作全面总结 0X01位操作基础 基本的位操作符有与、或、异或、取反、左移、右移这6种，它们的运算规则如下所示： 符号 描述 运算规则 by MoreWindows \u0026 与 两个位都为1时，结果才为1 | 或 两个位都为0时，结果才为0 ^ 异或 两个位相同为0，相异为1 ~ 取反 0变1，1变0 « 左移 各二进位全部左移若干位，高位丢弃，低位补0 |右移|各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） 注意以下几点： 1． 在这6种操作符，只有~取反是单目操作符，其它5种都是双目操作符。 2． 位操作只能用于整形数据，对float和double类型进行位操作会被编译器报错。 3． 对于移位操作，在微软的VC6.0和VS2008编译器都是采取算术称位即算术移位操作，算术移位是相对于逻辑移位，它们在右移操作中都一样，低位补0即可，但在左移中逻辑移位的高位补0而算术移位的高位是补符号位。如下面代码会输出-4和3。 0X02位操作实现两个数交换 static void Main(string[] args) { int a = 3; int b = 4; swap(ref a, ref b); Console.WriteLine(a + \" \" + b); } static void swap(ref int a,ref int b) { a = a ^ b; b = a ^ b; a = a ^ b; } ","date":"2019-12-01 21:57:40","objectID":"/%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BB%8B%E7%BB%8D/:0:0","tags":["深入理解计算机系统"],"title":"位操作符介绍","uri":"/%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BB%8B%E7%BB%8D/"},{"categories":["深入理解计算机系统"],"content":" 参考文章 用基本位运算实现加减乘除 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace BseOperate { class Program { //加减乘除运算 static void Main(string[] args) { Console.WriteLine(\"1+3 = \"+Add(1, 3)) ; Console.WriteLine(\"1+(-3) = \" + Add(1, -3)); Console.WriteLine(\"1-3 = \" + Subtraction(1, 3)); Console.WriteLine(\"1-(-3) = \" + Subtraction(1, -3)); Console.WriteLine(\"5*3 = \" + Multiply(5, 3)); Console.WriteLine(\"-5*3 = \" + Multiply(-5, 3)); Console.WriteLine(\"19/3 = \" + Divide(19, 3)); Console.WriteLine(\"-19/3 = \" + Divide(-19, 3)); } /// \u003csummary\u003e /// 加法 /// \u003c/summary\u003e /// \u003cparam name=\"a\"\u003e\u003c/param\u003e /// \u003cparam name=\"b\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e static int Add(int a,int b) { int tmp = 0; while(b!=0) { tmp = a ^ b; //不带进位的加法 b = (a \u0026 b) \u003c\u003c 1; //只带进位的加法 a = tmp; } return a; } /// \u003csummary\u003e /// 减法 /// \u003c/summary\u003e /// \u003cparam name=\"a\"\u003e\u003c/param\u003e /// \u003cparam name=\"b\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e static int Subtraction(int a, int b) { return Add(a, negtive(b)); } /// \u003csummary\u003e /// 乘法 /// \u003c/summary\u003e /// \u003cparam name=\"a\"\u003e\u003c/param\u003e /// \u003cparam name=\"b\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e static int Multiply(int a, int b) { int mark = a ^ b; //对被除数和除数取绝对值 a = a \u003c 0 ? Add(~a, 1) : a; b = b \u003c 0 ? Add(~b, 1) : b; int res = 0; while (b != 0) { if ((b \u0026 1) != 0) res = Add(res, a); a = a \u003c\u003c 1; b = b \u003e\u003e 1; } if (mark \u003c 0) { res = negtive(res); } return res; } /// \u003csummary\u003e /// 除法 /// \u003c/summary\u003e /// \u003cparam name=\"a\"\u003e\u003c/param\u003e /// \u003cparam name=\"b\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e static int Divide(int a,int b) { int mark = a ^ b; //对被除数和除数取绝对值 a = a \u003c 0 ? Add(~a, 1) : a; b = b \u003c 0 ? Add(~b, 1) : b; int res = 0; while(a\u003e=b) { a = Subtraction(a, b); res = Add(res, 1); } if(mark\u003c0) { res = negtive(res); } return res; } /// \u003csummary\u003e /// 增加负号 /// 取反加一 /// \u003c/summary\u003e /// \u003cparam name=\"a\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e static int negtive(int a) { return Add(~a, 1); } } } ","date":"2019-12-01 21:57:40","objectID":"/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/:0:0","tags":["深入理解计算机系统"],"title":"位运算实现加减乘除","uri":"/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/"},{"categories":["Unity"],"content":" 使用命令行发现没办法处理九宫图呀还得在工程里面配置九宫图，太麻烦了，不知道怎么破这个问题 REM @echo off REM :: # cmd TextruePacker REM :: # --sheet path 输出图片名字 REM :: # --data path 输出描述文件，plist tpsheet REM :: # --format format 输出格式 REM :: # --max-width 1024 --max-height 1024 当前图集的尺寸 （前面两个等价于后面 --max-size 1024） REM :: # –shape-padding \u003cint\u003e 图块之间缝隙的宽度,默认值是2 REM :: # –border-padding \u003cint\u003e 可以理解为边框的宽度,默认值为2 REM :: # –enable-rotation/diable-rotation 开启/关闭旋转,默认值和输出的格式有关系,cococ2d格式默认enable REM :: # –trim/no-trim 剪裁图片,即移除图片周围的透明像素,保留原始尺寸,默认开启 set atlas=common echo %atlas% set assetDir=../%atlas% set project=../%atlas%.tps set outputPath=./../../Unity/Assets/OriginalRes/UIImage/ set texPath=%outputPath%%atlas%.png set sheetPath=%outputPath%%atlas%.tpsheet echo %assetDir% echo %outputPath% echo %texPath% echo %sheetPath% TexturePacker %project% --format unity-texture2d --sheet %texPath% --data %sheetPath% --max-width 1024 --max-height 1024 --shape-padding 2 --border-padding 2 --enable-rotation --no-trim --opt RGBA8888 --texture-format png --scale 1 REM TexturePacker %project% --format unity-texture2d --sheet %texPath% --data %sheetPath% REM TexturePacker %project% pause \u0026 exit ","date":"2019-12-01 21:57:40","objectID":"/%E4%BD%BF%E7%94%A8texturepacker%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/:0:0","tags":["Unity"],"title":"使用TexturePacker命令行的一个坑","uri":"/%E4%BD%BF%E7%94%A8texturepacker%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/"},{"categories":["计算机基础"],"content":" 二进制表示一般用原码表示，计算加减时用补码表示。 这里的二进制小数是用的定点数表示，不是用浮点数表示的。 ","date":"2019-12-01 21:57:40","objectID":"/%E5%8D%81%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/:0:0","tags":["进制"],"title":"十进制和二进制互相转换","uri":"/%E5%8D%81%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/"},{"categories":["计算机基础"],"content":"0X01 二进制转十进制 由二进制数转换成十进制数的基本做法是，把二进制数首先写成加权系数展开式，然后按十进制加法规则求和。这种做法称为\"按权相加\"法。 例子： [01101100]2=0×27+1×26+1×25+0×24+1×23+1×22+0×21+0×20=10810 [101.101]2=1×22+0×21+1×20+1×2-1+0×2-2+1×2-3=5.625 注：这里的二进制小数是原码表示的，使用的定点数表示，没有用浮点数表示 ","date":"2019-12-01 21:57:40","objectID":"/%E5%8D%81%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/:1:0","tags":["进制"],"title":"十进制和二进制互相转换","uri":"/%E5%8D%81%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/"},{"categories":["计算机基础"],"content":"0X02 十进制转二进制 ####1.十进制整数转二进制 十进制整数转换为二进制整数采用\"除2取余，逆序排列\"法。具体做法是：用2去除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为零时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。 例子：求17310的二进制 ####2.十进制小数转二进制 十进制小数转换成二进制小数采用\"乘2取整，顺序排列\"法。具体做法是：用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止。 然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位。 例子：求0.812510的二进制 例子：173.812510＝17310+0.812510=101011012(原)+0.11012(原)=10101101.11012(原) -1.2510=10000001.012(原) 十进制小数转换成二进制小数采用\"乘2取整，顺序排列\"法。具体做法是：用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数部分，又 得到一个积，再将积的整数部分取出，如此进行，直到积中的整数部分为零，或者整数部分为1，此时0或1为二进制的最后一位。或者达到所要求的精度为止。 然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位。　十进制小数转二进制 如：0.62510=0.1012 0.6252=1.25======取出整数部分1 0.252=0.5========取出整数部分0 0.5*2=1==========取出整数部分1 　再如：0.710=0.1011001102 0.72=1.4========取出整数部分1 0.42=0.8========取出整数部分0 0.82=1.6========取出整数部分1 0.62=1.2========取出整数部分1 0.22=0.4========取出整数部分0　0.42=0.8========取出整数部分0 0.82=1.6========取出整数部分1 0.62=1.2========取出整数部分1 0.2*2=0.4========取出整数部分0 参考文章： http://www.cnblogs.com/xkfz007/articles/2590472.html ","date":"2019-12-01 21:57:40","objectID":"/%E5%8D%81%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/:2:0","tags":["进制"],"title":"十进制和二进制互相转换","uri":"/%E5%8D%81%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/"},{"categories":["计算机基础"],"content":"  到目前为止，我们学习了十进制、二进制、八进制、十六进制等用来代表实际数值的数，称为真值，这些数我们再日常生活中都会使用到，那么在计算机中数值是怎么来表示的呢？ 数在计算机中的表示形式统称为机器数。计算机中处理数据及运算都是采用二进制，通常规定机器数用八位二进制表示。实用的数据有正数和负数，因为计算机只能表示0、1两种状态，数据的正号“+”或负号“-”，在计算机里就用一位二进制的0或1来区别，通常放在最高位，成为符号位。 符号位数值化之后，为能方便的对机器数进行算术运算、提高运算速度，计算机设计了多种符号位与数值一起编码的方法，最常用的机器数表示方法有:原码、反码、补码和移码，下面就分别介绍一下它们的表示方法。 ","date":"2019-12-01 21:57:40","objectID":"/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E5%92%8C%E7%A7%BB%E7%A0%81%E8%AF%A6%E8%A7%A3/:0:0","tags":[""],"title":"原码、反码、补码和移码详解","uri":"/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E5%92%8C%E7%A7%BB%E7%A0%81%E8%AF%A6%E8%A7%A3/"},{"categories":["计算机基础"],"content":"0X01 原码、反码、补码和移码 原码：正数是其二进制本身；负数是符号位为1,数值部分取X绝对值的二进制。 反码：正数的反码和原码相同；负数是符号位为1,其它位是原码取反。 补码：正数的补码和原码，反码相同；负数是符号位为1，其它位是原码取反，未位加1。（或者说负数的补码是其绝对值反码未位加1） 移码：将符号位取反的补码（不区分正负） 举个例子以一个字节8位说明：  编码 10810（sbyte） -10810（sbyte） 原码 01101100 11101100 反码 01101100 10010011 补码 01101100 10010100 移码 11101100 00010100 注：加粗的数字为符号位，补码在线工具  移码表示法是在数X上增加一个偏移量来定义的，常用来表示浮点数中的阶码，所以是整数。如果机器字长为n，规定偏移量为2(n-1)。若X是整数，则X移=2^(n-1)+X 例子：假设字长为8，以上面的108为例  108移=10000000+01101100=11101100 -108移=10000000+10010100=00010100 ","date":"2019-12-01 21:57:40","objectID":"/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E5%92%8C%E7%A7%BB%E7%A0%81%E8%AF%A6%E8%A7%A3/:1:0","tags":[""],"title":"原码、反码、补码和移码详解","uri":"/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E5%92%8C%E7%A7%BB%E7%A0%81%E8%AF%A6%E8%A7%A3/"},{"categories":["计算机基础"],"content":"0X02 补码求原码 已知一个数的补码，求原码的操作分两种情况： 如果补码的符号位为“0”，表示是一个正数，所以补码就是该数的原码。 如果补码的符号位为“1”，表示是一个负数，求原码的操作可以是：符号位为1；其余各位取反，然后再整个数加1。 ","date":"2019-12-01 21:57:40","objectID":"/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E5%92%8C%E7%A7%BB%E7%A0%81%E8%AF%A6%E8%A7%A3/:2:0","tags":[""],"title":"原码、反码、补码和移码详解","uri":"/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E5%92%8C%E7%A7%BB%E7%A0%81%E8%AF%A6%E8%A7%A3/"},{"categories":["计算机基础"],"content":"0X03 补码加、减运算公式 在做补码加减法时，只需将符号位和数值部分一起参与运算，并且将符号位产生的进位丢掉即可 补码加法公式 [X+Y]补 ＝ 补 + [Y]补 补码减法公式 [X-Y]补 = 补-[Y]补 = 补 + [-Y]补 其中：[-Y]补称为负补,求负补的办法是：对补码的每一位(包括符合位)求反，且未位加1. 假设字长为8的计算机sbyte类型所能表示的最大数是11111111，若再加1称为100000000(9位)，但因只有8位，最高位1自然丢失。又回了00000000，所以字长为8的二进制系统的模为2^8。 ","date":"2019-12-01 21:57:40","objectID":"/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E5%92%8C%E7%A7%BB%E7%A0%81%E8%AF%A6%E8%A7%A3/:3:0","tags":[""],"title":"原码、反码、补码和移码详解","uri":"/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E5%92%8C%E7%A7%BB%E7%A0%81%E8%AF%A6%E8%A7%A3/"},{"categories":["计算机基础"],"content":"0X04 为何要使用原码, 反码和补码 在开始深入学习前, 我的学习建议是先\"死记硬背\"上面的原码, 反码和补码的表示方式以及计算方法. 现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同: [+1] = [00000001]原 = [00000001]反 = [00000001]补 所以不需要过多解释. 但是对于负数: [-1] = [10000001]原= [11111110]反= [11111111]补 可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢? 首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (补码的绝对值称为真值即去掉符号位的二进制数字). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别\"符号位\"显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了. 于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码: 计算十进制的表达式: 1-1=0 1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原= [10000010]原 = -2 如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数. 为了解决原码做减法的问题, 出现了反码: 计算十进制的表达式: 1-1=0 1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反+ [1111 1110]反= [1111 1111]反= [1000 0000]原= -0 发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在\"0\"这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0. 于是补码的出现, 解决了0的符号以及两个编码的问题: 1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补+ [1111 1111]补= [0000 0000]补=[0000 0000]原 这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128: (-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补+ [1000 0001]补= [1000 0000]补 -1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的) 使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127]. 因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值. 总结： 原码负数不能参与运算并且不能做减法运算 反码的+0和-0的反码不相同 -128在运算中的补码是 [1000 0000]补，并没有原码和反码表示 引用的文章: http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html http://blog.csdn.net/peng_weida/article/details/7931990 补码和原码的转化过程 ","date":"2019-12-01 21:57:40","objectID":"/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E5%92%8C%E7%A7%BB%E7%A0%81%E8%AF%A6%E8%A7%A3/:4:0","tags":[""],"title":"原码、反码、补码和移码详解","uri":"/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E5%92%8C%E7%A7%BB%E7%A0%81%E8%AF%A6%E8%A7%A3/"},{"categories":["CSharp"],"content":"1. 可空的值类型（T?） 可空引用 引用类型可以使用空引用表示一个不存在的值，而值类型通常不能表示为空。 例如：string str=null; 是正确的，int i=null; 编译器就会报错。 为了使值类型也可为空，就可以使用可空类型，即用可空类型修饰符\"？“来表示，表现形式为\"T？” 例如：int? 表示可空的整形，DateTime? 表示可为空的时间。 T? 其实是System.Nullable(泛型结构）的缩写形式，也就意味着当你用到T？时编译器编译 时会把T？编译成System.Nullable的形式。 例如：int?,编译后便是System.Nullable的形式。 //System.Nullable //支持可为其分配 null 的值类型，如引用类型。 此类不能被继承。 class Program { struct Test { int a; int b; }; static void Main(string[] args) { Test? test=null; int? a = null; } } 2. 三元表达式(三目运算符) ?: 例如：x?y:z 表示如果表达式x为true，则返回y；如果x为false，则返回z，是省略if{}else{}的简单形式。 int b = a != null ? 1 : 0; 3. 空合并运算符 ??： 用于定义可空类型和引用类型的默认值。如果此运算符的左操作数不为null，则此运算符将返回左操作数，否则返回右操作数。 例如：a??b 当a为null时则返回b，a不为null时则返回a本身。 这里的左操作符必须是可为null的类型 static void Main(string[] args) { int? a = null; int b = a != null ? 1 : 0; Console.WriteLine(\"b::\"+b); object d = 3,e=5; //运算符“??”无法应用于“int”和“object”类型的操作数 ,int指b //string c = (a ?? b??d).ToString(); string n = (a ?? e ?? d).ToString(); Console.WriteLine(\"n::::\" + n); } 结果n的值是5，b的值是0； 参考文章： 在C#中??和?分别是什么意思？ 参考文章中的一句“空合并运算符为右结合运算符，即操作时从右向左进行组合的。如，“a??b??c”的形式按“a??(b??c)”计算。”我觉得是从左向右结合的，还是说我说错了，这里结果肯定是：当a!=null则返回a；当a==null时，b!=null返回b；当a==null且b==null，则返回c； ","date":"2019-12-01 21:57:40","objectID":"/%E4%BF%A9%E9%97%AE%E5%8F%B7%E5%92%8C%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%8A%A0%E9%97%AE%E5%8F%B7%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/:0:0","tags":["CSharp"],"title":"在C#中??和值类型加?分别是什么意思？","uri":"/%E4%BF%A9%E9%97%AE%E5%8F%B7%E5%92%8C%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%8A%A0%E9%97%AE%E5%8F%B7%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/"},{"categories":["Math"],"content":" 引用： https://jingyan.baidu.com/article/63acb44a04a18c61fcc17e82.html https://wenku.baidu.com/view/8bf6d3aedd3383c4bb4cd291.html ","date":"2019-12-01 21:57:40","objectID":"/%E5%9F%BA%E6%9C%AC%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99%E4%B8%8E%E5%AF%BC%E6%95%B0%E5%85%AC%E5%BC%8F/:0:0","tags":["Math"],"title":"基本求导法则与导数公式","uri":"/%E5%9F%BA%E6%9C%AC%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99%E4%B8%8E%E5%AF%BC%E6%95%B0%E5%85%AC%E5%BC%8F/"},{"categories":["深入理解计算机系统"],"content":" 参照深入理解计算机系统 假设变量int x = 0x01234567 假设x的指针地址为0x100,则在内存中数据存储为： 0x100 0x101 0x102 0x103 大端法（big endian） 01 23 45 67 小端法（little endian） 67 45 23 01 可以这么记：指向地址位是数字低位为小端，指向地址位是数字高位为大端 判断本机当前环境是大端还是小端代码： #define _CRT_SECURE_NO_WARNINGS #include \u003cstdio.h\u003e void main() { int a = 0x01234567; //我这里输出的是67 是小端，如果是大端则输出01 printf(\"%.2x\\n\", *(char*)(\u0026a)); //只是为了不让命令行关闭 char b; scanf(\"%c\", \u0026b); } 第二个测试 #define _CRT_SECURE_NO_WARNINGS #include \u003cstdio.h\u003e typedef unsigned char* byte_poiner; void show_bytes(byte_poiner start, size_t len) { size_t i; for (int i = 0; i \u003c len; i++) { printf(\"%.2x\", start[i]); } printf(\"\\n\"); } void show_int(int x) { show_bytes((byte_poiner)\u0026x, sizeof(int)); } void show_float(float x) { show_bytes((byte_poiner)\u0026x, sizeof(float)); } void show_pointer(void* x) { show_bytes((byte_poiner)\u0026x, sizeof(void*)); } void main() { int val = 0x87654321; byte_poiner valp = (byte_poiner)\u0026val; show_bytes(valp, 1); show_bytes(valp, 2); show_bytes(valp, 3); show_bytes(valp, 4); //只是为了不让命令行关闭 char b; scanf(\"%c\", \u0026b); } 结果： ","date":"2019-12-01 21:57:40","objectID":"/%E5%A4%9A%E5%AD%97%E8%8A%82%E5%A4%A7%E5%B0%8F%E7%AB%AF%E8%AF%B4%E6%98%8E/:0:0","tags":["深入理解计算机系统"],"title":"多字节大小端说明","uri":"/%E5%A4%9A%E5%AD%97%E8%8A%82%E5%A4%A7%E5%B0%8F%E7%AB%AF%E8%AF%B4%E6%98%8E/"},{"categories":["CSharp"],"content":"命名规范 使用驼峰法命名 类名使用首字母大写的驼峰法命名，例如：PlayerObject 方法名使用首写字母大写命名方式，例如：Init() 成员变量、局部变量都统一使用首字母小写的命名方式，例如：localValue；属性首字母大写，字段统一小写；（属性是指带get，set访问器的） 常量和enum的命名都使用大写+下划线的方式，例如：MAX_PLAYER_NUMBER 抽象类名使用Abstract开头，例如：AbstractCharacter，接口使用I开头，例如：ITask 避免在类和变量的命名中使用缩写 对于接口和抽象类，需要在类前加注释，在每个方法上也尽量多写注释，用来说明类或者函数的作用 枚举类名也使用首字母大写的驼峰法命名，且以Enum结尾，例如：ServerStatusEnum 所有的语句块必须使用大括号包裹，禁止出现if(condition) do();这种使用方式，这种写法不利于调试 驼峰式（补充） 驼峰式命名法就是当变量名或函式名是由一个或多个单词连结在一起，而构成的唯一识别字时，第一个单词以小写字母开始；第二个单词的首字母大写或每一个单词的首字母都采用大写字母，例如：myFirstName、myLastName，这样的变量名看上去就像驼峰峰一样此起彼伏，故得名。 驼峰式命名法（Camel-Case）一词来自 Perl 语言中普遍使用的大小写混合格式，而 Larry Wall 等人所著的畅销书《Programming Perl》（O’Reilly 出版）的封面图片正是一匹骆驼。 驼峰式命名法的命名规则可视为一种惯例，并无绝对与强制，为的是增加识别和可读性。 小驼峰法 变量一般用小驼峰法标识。驼峰法的意思是：除第一个单词之外，其他单词首字母大写。譬如 int myStudentCount; 变量myStudentCount第一个单词是全部小写，后面的单词首字母大写。 大驼峰法* 相比小驼峰法，大驼峰法把第一个单词的首字母也大写了。常用于类名，函数名，属性，命名空间。譬如 public class DataBaseUser; ","date":"2019-12-01 21:57:40","objectID":"/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91csharp%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E6%89%8B%E5%86%8C/:0:0","tags":["CSharp"],"title":"客户端开发C#命名规范手册","uri":"/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91csharp%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E6%89%8B%E5%86%8C/"},{"categories":["Unity"],"content":"命名规范 使用驼峰法命名 类名使用首字母大写的驼峰法命名，例如：PlayerObject 方法名使用首写字母大写命名方式，例如：Init() 成员变量、局部变量都统一使用首字母小写的命名方式，例如：localValue；属性首字母大写，字段统一小写；（属性是指带get，set访问器的） 常量和enum的命名都使用大写+下划线的方式，例如：MAX_PLAYER_NUMBER 抽象类名使用Abstract开头，例如：AbstractCharacter，接口使用I开头，例如：ITask 避免在类和变量的命名中使用缩写 对于接口和抽象类，需要在类前加注释，在每个方法上也尽量多写注释，用来说明类或者函数的作用 枚举类名也使用首字母大写的驼峰法命名，且以Enum结尾，例如：ServerStatusEnum 所有的语句块必须使用大括号包裹，禁止出现if(condition) do();这种使用方式，这种写法不利于调试 驼峰式（补充） 驼峰式命名法就是当变量名或函式名是由一个或多个单词连结在一起，而构成的唯一识别字时，第一个单词以小写字母开始；第二个单词的首字母大写或每一个单词的首字母都采用大写字母，例如：myFirstName、myLastName，这样的变量名看上去就像驼峰峰一样此起彼伏，故得名。 驼峰式命名法（Camel-Case）一词来自 Perl 语言中普遍使用的大小写混合格式，而 Larry Wall 等人所著的畅销书《Programming Perl》（O’Reilly 出版）的封面图片正是一匹骆驼。 驼峰式命名法的命名规则可视为一种惯例，并无绝对与强制，为的是增加识别和可读性。 小驼峰法 变量一般用小驼峰法标识。驼峰法的意思是：除第一个单词之外，其他单词首字母大写。譬如 int myStudentCount; 变量myStudentCount第一个单词是全部小写，后面的单词首字母大写。 大驼峰法* 相比小驼峰法，大驼峰法把第一个单词的首字母也大写了。常用于类名，函数名，属性，命名空间。譬如 public class DataBaseUser; ","date":"2019-12-01 21:57:40","objectID":"/csharp%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E6%89%8B%E5%86%8C/:0:0","tags":["Unity"],"title":"客户端开发C#命名规范手册","uri":"/csharp%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E6%89%8B%E5%86%8C/"},{"categories":["Math"],"content":"一、极限公式 （系数不为0的情况） ","date":"2019-12-01 21:57:40","objectID":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/:1:0","tags":["Math"],"title":"微分和积分数学公式大全","uri":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/"},{"categories":["Math"],"content":"二、重要公式 ","date":"2019-12-01 21:57:40","objectID":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/:2:0","tags":["Math"],"title":"微分和积分数学公式大全","uri":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/"},{"categories":["Math"],"content":"三、下列常用等价无穷小关系（x-\u003e0） ","date":"2019-12-01 21:57:40","objectID":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/:3:0","tags":["Math"],"title":"微分和积分数学公式大全","uri":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/"},{"categories":["Math"],"content":"四、导数的四则运算法则 ","date":"2019-12-01 21:57:40","objectID":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/:4:0","tags":["Math"],"title":"微分和积分数学公式大全","uri":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/"},{"categories":["Math"],"content":"五、基本导数公式 ","date":"2019-12-01 21:57:40","objectID":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/:5:0","tags":["Math"],"title":"微分和积分数学公式大全","uri":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/"},{"categories":["Math"],"content":"六、高阶导数的运算法则 ","date":"2019-12-01 21:57:40","objectID":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/:6:0","tags":["Math"],"title":"微分和积分数学公式大全","uri":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/"},{"categories":["Math"],"content":"七、基本初等函数的n阶导数公式 ","date":"2019-12-01 21:57:40","objectID":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/:7:0","tags":["Math"],"title":"微分和积分数学公式大全","uri":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/"},{"categories":["Math"],"content":"八、微分公式与微分运算法则 ","date":"2019-12-01 21:57:40","objectID":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/:8:0","tags":["Math"],"title":"微分和积分数学公式大全","uri":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/"},{"categories":["Math"],"content":"九、微分运算法则 ","date":"2019-12-01 21:57:40","objectID":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/:9:0","tags":["Math"],"title":"微分和积分数学公式大全","uri":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/"},{"categories":["Math"],"content":"十、基本积分公式 ","date":"2019-12-01 21:57:40","objectID":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/:10:0","tags":["Math"],"title":"微分和积分数学公式大全","uri":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/"},{"categories":["Math"],"content":"十一、下列常用凑微分公式 ","date":"2019-12-01 21:57:40","objectID":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/:11:0","tags":["Math"],"title":"微分和积分数学公式大全","uri":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/"},{"categories":["Math"],"content":"十二、补充下面几个积分公式 ","date":"2019-12-01 21:57:40","objectID":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/:12:0","tags":["Math"],"title":"微分和积分数学公式大全","uri":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/"},{"categories":["Math"],"content":"十三、分部积分法公式 ","date":"2019-12-01 21:57:40","objectID":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/:13:0","tags":["Math"],"title":"微分和积分数学公式大全","uri":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/"},{"categories":["Math"],"content":"十四、第二换元积分法中的三角换元公式 ","date":"2019-12-01 21:57:40","objectID":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/:14:0","tags":["Math"],"title":"微分和积分数学公式大全","uri":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/"},{"categories":["Math"],"content":"十五、三角函数公式 ","date":"2019-12-01 21:57:40","objectID":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/:15:0","tags":["Math"],"title":"微分和积分数学公式大全","uri":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/"},{"categories":["Math"],"content":"十六、几种常见的微分方程 引用： https://www.sohu.com/a/215294583_275707 ","date":"2019-12-01 21:57:40","objectID":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/:16:0","tags":["Math"],"title":"微分和积分数学公式大全","uri":"/%E5%BE%AE%E5%88%86%E5%92%8C%E7%A7%AF%E5%88%86%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/"},{"categories":[""],"content":"打开文件或者目录： Mac 打开文件或者目录使用 open ./ Windows 打开文件或者目录使用 start ./ ","date":"2019-12-01 21:57:40","objectID":"/%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4/:0:0","tags":[""],"title":"日常使用命令","uri":"/%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["深入理解计算机系统"],"content":"2.11 数组翻转 #define _CRT_SECURE_NO_WARNINGS #include \u003cstdio.h\u003e#include\u003cwindows.h\u003e void swap(int * x, int *y) { *y = *x^*y; *x = *x^*y; *y = *x^*y; } void reverse_array(int a[], int cnt) { for (size_t i = 0; i \u003c cnt-i-1; i++) { swap(\u0026a[i], \u0026a[cnt - i - 1]); } } void main() { int a[] = { 4, 2, 1, 5, 6,7 }; reverse_array(a, 6); for (int i = 0; i \u003c 6;i++) { printf(\"%d,\", a[i]); } //只是为了不让命令行关闭 char b; scanf(\"%c\", \u0026b); } ","date":"2019-12-01 21:57:40","objectID":"/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0%E9%83%A8%E5%88%86%E7%BB%83%E4%B9%A0%E9%A2%98/:0:1","tags":["深入理解计算机系统"],"title":"深入理解计算机系统第二章部分练习题","uri":"/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0%E9%83%A8%E5%88%86%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["深入理解计算机系统"],"content":"2.12 #define _CRT_SECURE_NO_WARNINGS #include \u003cstdio.h\u003e#include\u003cwindows.h\u003e void main() { int x = 0x87654321; // A int A = x \u0026 0xff; printf(\"%.8X\\n\", A); // B int B = ~x ^ 0xff; printf(\"%.8X\\n\", B); // C int C = x | 0xff; printf(\"%.8X\\n\", C); //只是为了不让命令行关闭 char b; scanf(\"%c\", \u0026b); } ","date":"2019-12-01 21:57:40","objectID":"/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0%E9%83%A8%E5%88%86%E7%BB%83%E4%B9%A0%E9%A2%98/:0:2","tags":["深入理解计算机系统"],"title":"深入理解计算机系统第二章部分练习题","uri":"/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0%E9%83%A8%E5%88%86%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["随笔"],"content":" 给美术同学和策划同学提供的文档 ","date":"2019-12-01 21:57:40","objectID":"/%E6%B7%BB%E5%8A%A0%E7%BD%91%E7%BB%9C%E4%BD%8D%E7%BD%AE%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95/:0:0","tags":[""],"title":"添加网络位置（共享目录）","uri":"/%E6%B7%BB%E5%8A%A0%E7%BD%91%E7%BB%9C%E4%BD%8D%E7%BD%AE%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95/"},{"categories":["随笔"],"content":"0X01 添加网络位置 1.双击我的电脑 2.在下面空白处右键，选择添加网络位置 3.弹出添加向导，点击下一步 4.点击选择自定义网络位置，双击 5.地址栏输入网络地址,然后点击下一步 这里输入自己要用的网络位置\\\\10.113.4.228\\SharedFile， 6.网络地址名字，这里默认，直接下一步 7.点击完成 8.双击我的电脑，下面看到添加的网络位置，直接打开就能使用共享的文件了 sourcetree的路径在这 ","date":"2019-12-01 21:57:40","objectID":"/%E6%B7%BB%E5%8A%A0%E7%BD%91%E7%BB%9C%E4%BD%8D%E7%BD%AE%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95/:0:1","tags":[""],"title":"添加网络位置（共享目录）","uri":"/%E6%B7%BB%E5%8A%A0%E7%BD%91%E7%BB%9C%E4%BD%8D%E7%BD%AE%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95/"},{"categories":["随笔"],"content":" 轉載： https://www.cnblogs.com/duanxz/archive/2012/07/10/2584726.html https://www.cnblogs.com/shely-Wangfan/p/5425995.html https://blog.csdn.net/ivy___/article/details/52383744?hmsr=toutiao.io\u0026utm_medium=toutiao.io\u0026utm_source=toutiao.io https://blog.csdn.net/ibukikonoha/article/details/80643959 https://www.cnblogs.com/xiaoshayu520ly/p/8638041.html 覺得不錯的引導文章 ","date":"2019-12-01 21:57:40","objectID":"/%E7%94%A8astash-%E7%94%BBuml%E7%B1%BB%E5%9B%BE/:0:0","tags":[""],"title":"用astash 画UML类图","uri":"/%E7%94%A8astash-%E7%94%BBuml%E7%B1%BB%E5%9B%BE/"},{"categories":["随笔"],"content":" 感谢TexturePacker团队回复我的邮件，已经顺利获取到免费注册码 为了申请费劲了，尴尬 感谢： It is my honor to apply for your key thank you very much！ 申请地址：http://www.codeandweb.com TexturePacker官方网站：http://www.codeandweb.com/ 这里说下我的英语不好，找申请入口的时候费劲，参考别人的教程，始终找不到入口，很尴尬，我是点击左下角的help按钮提交的自己信息，供大家参考 我提交得信息： I am programmer of unity ,I want use texture packer to create ui atlas by my project,so requst a license of texture packer, I not find request free license entry ,thank you. my blog: https://blog.csdn.net/codingriver（自己的博客） my mail : 自己的邮箱 my name: 自己的名字 country: China city: Beijing blog description: I use my blog to record some technology of my work and learn book. so I like learn to program. thank you! ","date":"2019-12-01 21:57:40","objectID":"/%E7%94%B3%E8%AF%B7texturepacker%E5%85%8D%E8%B4%B9%E6%B3%A8%E5%86%8C%E7%A0%812018%E5%B9%B411%E6%9C%88%E4%BB%BD%E7%94%B3%E8%AF%B7%E7%9A%84/:0:0","tags":[""],"title":"申请TexturePacker免费注册码(2018年11月份申请的)","uri":"/%E7%94%B3%E8%AF%B7texturepacker%E5%85%8D%E8%B4%B9%E6%B3%A8%E5%86%8C%E7%A0%812018%E5%B9%B411%E6%9C%88%E4%BB%BD%E7%94%B3%E8%AF%B7%E7%9A%84/"},{"categories":["Math"],"content":" 这里说明下b站的3Blue1Brown讲解的非常好 这里就不做过多的说明了 ， 线性代数的本质笔记这篇文章整理的非常全面可供参考 吐槽一下大学课程线性代数，忒死板了，最后也没搞明白，参考视频和笔记后搞明白大部分了，剩下的用到再研究就行了 ","date":"2019-12-01 21:57:40","objectID":"/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/:0:0","tags":["Math"],"title":"线性代数的本质（全）","uri":"/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/"},{"categories":["Unity"],"content":" 代码经过验证，但是这里只提供了iap相关的代码，有依赖其他的代码自行删减 直接上代码 // // PurchaseSDK.h // Unity-iPhone // // Created by wang guo qing on 2017/3/24. // // #import \u003cFoundation/Foundation.h\u003e #import \"StoreKit/StoreKit.h\" @protocol IAPPayResult \u003cNSObject\u003e -(void)OnPayResult:(NSString*)res; @end @interface PurchaseSDK : NSObject \u003cSKProductsRequestDelegate, SKPaymentTransactionObserver\u003e +(instancetype) Instance; @property double SystemVersion; @property (retain)id\u003cIAPPayResult\u003e PayResultObj; @property (nonatomic, retain)NSMutableDictionary* TransactionDict; -(void)Init:(id\u003cIAPPayResult\u003e)obj; -(void)BuyProduct:(NSString * )productId Quantity:(NSInteger)quantity SignId:(NSString * )signId; -(void)FinishTransaction:(NSString*)transactionIdentifier; -(void)BuyProductBySKProductsRequest:(NSString * )productId; - (void)provideContentWithTransaction:(SKPaymentTransaction *)transaction; @end // // PurchaseSDK.m // Unity-iPhone // // Created by wang guo qing on 2017/3/24. // // #import \u003cFoundation/Foundation.h\u003e #import \"PurchaseSDK.h\" @implementation PurchaseSDK static PurchaseSDK*instance=nil; +(instancetype) Instance{ static dispatch_once_t onceToken=0; dispatch_once(\u0026onceToken,^{ instance=[[PurchaseSDK alloc] init]; NSLog(@\"PurchaseSDK Instance alloc!!!!\"); }); return instance; } -(void)Init:(id\u003cIAPPayResult\u003e)obj{ self.PayResultObj=obj; self.TransactionDict=[[NSMutableDictionary alloc] init]; NSString *version=[UIDevice currentDevice].systemVersion; NSLog(@\"系统版本号：%@\",version); _SystemVersion=[[UIDevice currentDevice] systemVersion].floatValue; //NSLog(@\"系统版本号：%f\",_SystemVersion); //注册观察者 // NSLog(@\"Purchase obj::%@\",self); [[SKPaymentQueue defaultQueue]addTransactionObserver:self]; //获取购买过所有的非消耗商品 //[[SKPaymentQueue defaultQueue] restoreCompletedTransactions]; } //使用商品查询会有bug，当查询时断网，回调方法productsRequest始终不会被调用，网络恢复后也不会被调用；在上一种情况操作的基础上网络恢复后再次查询商品也不会有回调，大约5-10分钟后再次查询商品才有回调 -(void)BuyProductBySKProductsRequest:(NSString * )productId { if([SKPaymentQueue canMakePayments]) { NSLog(@\"---------查询商品请求------------\"); //请求商品信息 NSSet* dataSet = [[NSSet alloc] initWithObjects:productId, nil]; SKProductsRequest* request = [[SKProductsRequest alloc] initWithProductIdentifiers:dataSet]; request.delegate = self; [request start]; } else { NSLog(@\"应用内不允许购买！\"); } } // 请求商品信息回调，商品信息 - (void)productsRequest:(SKProductsRequest *)request didReceiveResponse:(SKProductsResponse *)response { NSLog(@\"productsRequest=======\"); NSArray * products = response.products; NSLog(@\"产品Product count:%d\",(int)response.invalidProductIdentifiers.count); NSLog(@\"产品付费数量: %d\", (int)[products count]); for(SKProduct *product in products){ NSLog(@\"SKProduct 描述信息%@\", [product description]); NSLog(@\"产品标题 %@\" , product.localizedTitle); NSLog(@\"产品描述信息: %@\" , product.localizedDescription); NSLog(@\"价格: %@\" , product.price); NSLog(@\"Product id: %@\" , product.productIdentifier); } if(products.count\u003e0) { SKPayment *payment = [SKPayment paymentWithProduct:products[0]]; NSLog(@\"Purchase obj::%@\",self); //payment.applicationUsername=; //NSLog(@\"buyProduct::updatedTransactions,applicationUsername:%@\",payment.applicationUsername); NSLog(@\"---------发送商品信息请求------------\"); if ([SKPaymentQueue defaultQueue]) { [[SKPaymentQueue defaultQueue] addPayment:payment]; } } else { NSLog(@\"获取商品信息失败,连接AppStore失败，请稍后再试,或则商品不存在!\"); } } -(void)BuyProduct:(NSString * )productId Quantity:(NSInteger)quantity SignId:(NSString * )signId { if([SKPaymentQueue canMakePayments]) { // NSLog(@\"Purchase obj::%@\",self); NSLog(@\"---------发送购买请求------------\"); //请求商品信息 SKMutablePayment *payment = [[SKMutablePayment alloc] init]; payment.productIdentifier=productId; payment.quantity=quantity; payment.applicationUsername=signId; if ([SKPaymentQueue defaultQueue]) { [[SKPaymentQueue defaultQueue] addPayment:payment]; } } else { NSLog(@\"游戏内不允许购买！\"); //self.PayCallBack(@\"-10\"); //UnitySendMessage([_ObjName UTF8String],[_FailCall UTF8String],[@\"游戏内不允许购买!\" UTF8String]); } } - (void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray\u003cSKPaymentTran","date":"2019-12-01 21:57:40","objectID":"/%E8%8B%B9%E6%9E%9C%E5%86%85%E8%B4%AD/:0:0","tags":["Unity","IOS"],"title":"苹果内购","uri":"/%E8%8B%B9%E6%9E%9C%E5%86%85%E8%B4%AD/"},{"categories":["笔记"],"content":"Git LFS的使用 https://git-lfs.github.com/ https://www.jianshu.com/p/493b81544f80 https://zzz.buzz/zh/2016/04/19/the-guide-to-git-lfs/ # 查看安装的git lfs 环境信息 git lfs env git lfs env | head -2 # 查看当前使用 Git LFS 管理的匹配列表 git lfs track # 使用 Git LFS 管理指定的文件 git lfs track \"*.psd\" # 不再使用 Git LFS 管理指定的文件 git lfs untrack \"*.psd\" # 类似 `git status`，查看当前 Git LFS 对象的状态 git lfs status # 枚举目前所有被 Git LFS 管理的具体文件 git lfs ls-files # 检查当前所用 Git LFS 的版本 git lfs version # 针对使用了 LFS 的仓库进行了特别优化的 clone 命令，显著提升获取 # LFS 对象的速度，接受和 `git clone` 一样的参数。 [1] [2] git lfs clone https://github.com/user/repo.git git lfs install开启lfs功能 git lfs track \"*.png\" 添加大文件追踪，所有的png文件 指定文件后缀名 git lfs track \"*.filetype\" 指定某个目录下的所有文件 git lfs track \"directory/*\" 具体指定某个文件 git lfs track \"path/to/file\" git lfs track 查看所有的lfs文件追踪模式 git lfs ls-files 可以显示当前跟踪的文件列表 ","date":"2019-11-30 14:18:54","objectID":"/git%E7%AC%94%E8%AE%B0/:1:0","tags":["git"],"title":"Git笔记","uri":"/git%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"迁移已有的 git 仓库使用 git lfs 管理 # 重写 master 分支，将历史提交中的 *.zip 都用 git lfs 进行管理 git lfs migrate import --include-ref=master --include=\"*.png\" # 重写所有分支及标签，将历史提交中的 *.rar,*.zip 都用 git lfs 进行管理 git lfs migrate import --everything --include=\"*.bin,*.lib,*.so,*.dll,*.a,*.param,*.zip,*.gz,*.png,*.jpg,*.unitypackage,*.hdr,*.HDR\" 注意： 重写历史后的提交需执行： git push --force --all 注意： 如有迁移至 git lfs 前的仓库的多份拷贝，其他拷贝可能需要执行 git reset –hard origin/master 来重置其本地的分支，注意执行 git reset –hard 命令将会丢失本地的改动。 如果需要对本地仓库进行清理(非安全的) git reflog expire --expire-unreachable=now --all git gc --prune=now ","date":"2019-11-30 14:18:54","objectID":"/git%E7%AC%94%E8%AE%B0/:1:1","tags":["git"],"title":"Git笔记","uri":"/git%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"git clone命令 git clone -b ${branch} --depth=1 可以拉对应分支 ","date":"2019-11-30 14:18:54","objectID":"/git%E7%AC%94%E8%AE%B0/:2:0","tags":["git"],"title":"Git笔记","uri":"/git%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"git clone --depth=1后只有一个分支的解决办法 git clone --depth=1克隆项目后，使用git branch -r查看远程仓库只显示一个分支，实际远程仓库有多个分支。 这种方法克隆的项目只包含最近的一次commit的一个分支，体积很小，即可解决文章开头提到的项目过大导致Timeout的问题，但会产生另外一个问题，他只会把默认分支clone下来，其他远程分支并不在本地，也看不到其他远程分支。 ","date":"2019-11-30 14:18:54","objectID":"/git%E7%AC%94%E8%AE%B0/:3:0","tags":["git"],"title":"Git笔记","uri":"/git%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"checkout 一个新的分支 $ git clone --depth 1 https://github.com/dogescript/xxxxxxx.git $ git remote set-branches origin 'remote_branch_name' $ git fetch --depth 1 origin remote_branch_name $ git checkout remote_branch_name 参考：https://blog.csdn.net/qq_29094161/article/details/120649473 ","date":"2019-11-30 14:18:54","objectID":"/git%E7%AC%94%E8%AE%B0/:3:1","tags":["git"],"title":"Git笔记","uri":"/git%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"获取全部分支 修改.git/config文件中的 fetch = +refs/heads/master:refs/remotes/origin/master 为 fetch = +refs/heads/*:refs/remotes/origin/* 然后执行 git fetch --all 参考https://blog.csdn.net/a924068818/article/details/115725982 ","date":"2019-11-30 14:18:54","objectID":"/git%E7%AC%94%E8%AE%B0/:3:2","tags":["git"],"title":"Git笔记","uri":"/git%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"Git更新远程分支列表 git remote update origin --prune 这个命令没有测试 ","date":"2019-11-30 14:18:54","objectID":"/git%E7%AC%94%E8%AE%B0/:4:0","tags":["git"],"title":"Git笔记","uri":"/git%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"Git 强制推送 git push -f origin master git push --force origin master:master ","date":"2019-11-30 14:18:54","objectID":"/git%E7%AC%94%E8%AE%B0/:5:0","tags":["git"],"title":"Git笔记","uri":"/git%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"Git Pull ","date":"2019-11-30 14:18:54","objectID":"/git%E7%AC%94%E8%AE%B0/:6:0","tags":["git"],"title":"Git笔记","uri":"/git%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"git pull origin master:mm 在repository中找到名字为master的branch，使用它去更新local repository中找到名字为mm的branch，，如果local repository下不存在名字是mm的branch，那么新建一个。(如果mm不是当前激活的分支，git pull执行完也不是) ","date":"2019-11-30 14:18:54","objectID":"/git%E7%AC%94%E8%AE%B0/:6:1","tags":["git"],"title":"Git笔记","uri":"/git%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"Git Push ","date":"2019-11-30 14:18:54","objectID":"/git%E7%AC%94%E8%AE%B0/:7:0","tags":["git"],"title":"Git笔记","uri":"/git%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"git push origin master:master git push origin master:master 在local repository中找到名字为master的branch，使用它去更新remote repository下名字为master的branch，如果remote repository下不存在名字是master的branch，那么新建一个 ","date":"2019-11-30 14:18:54","objectID":"/git%E7%AC%94%E8%AE%B0/:7:1","tags":["git"],"title":"Git笔记","uri":"/git%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"Git Clean git clean命令用来从你的工作目录中删除所有没有tracked过的文件 git clean经常和git reset --hard一起结合使用. 记住reset只影响被track过的文件, 所以需要clean来删除没有track过的文件. 结合使用这两个命令能让你的工作目录完全回到一个指定的的状态 git clean -n 是一次clean的演习, 告诉你哪些文件会被删除. 记住他不会真正的删除文件, 只是一个提醒 git clean -f 删除当前目录下所有没有track过的文件. 他不会删除.gitignore文件里面指定的文件夹和文件, 不管这些文件有没有被track过 git clean -f \u003cpath\u003e 删除指定路径下的没有被track过的文件 git clean -df 删除当前目录下没有被track过的文件和文件夹 git clean -xf 删除当前目录下所有没有track过的文件. 不管他是否是.gitignore文件里面指定的文件夹和文件 下面的例子要删除所有工作目录下面的修改, 包括新添加的文件. 假设你已经提交了一些快照了, 而且做了一些新的开发 git reset --hard git clean -df 运行后, 工作目录和缓存区回到最近一次commit时候一摸一样的状态. git status会告诉你这是一个干净的工作目录, 又是一个新的开始了！ https://www.jianshu.com/p/0b05ef199749 ","date":"2019-11-30 14:18:54","objectID":"/git%E7%AC%94%E8%AE%B0/:8:0","tags":["git"],"title":"Git笔记","uri":"/git%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"Git Config 用git config命令查看配置文件： 查看仓库级的config，即.git/.config，命令：git config –local -l 查看全局级的config，即~\\.gitconfig，命令：git config –global -l 查看系统级的config，即C:\\Program Files\\Git\\etc\\gitconfig，命令：git config –system -l 查看当前生效的配置，命令：git config -l，这个时候会显示最终三个配置文件计算后的配置信息 查看当前生效的配置，命令：git config -l，这个时候会显示最终三个配置文件计算后的配置信息，如下图： git有几个配置文件呢？ 是的，聪明的你，稍微查查资料就知道咯，git里面一共有3个配置文件 仓库级配置文件：.git/config (该文件位于当前仓库下) [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true [remote \"origin\"] url = git@github.com:codingriver/codingriver.github.io.git fetch = +refs/heads/*:refs/remotes/origin/* [branch \"master\"] remote = origin merge = refs/heads/master [lfs] repositoryformatversion = 0 全局配置文件 ~/.gitconfig [user] name = codingriver email = codingriver@163.com [filter \"lfs\"] clean = git-lfs clean -- %f smudge = git-lfs smudge -- %f process = git-lfs filter-process required = true 系统级配置文件 C:\\Program Files\\Git\\etc\\gitconfig (git安装目录) [diff \"astextplain\"] textconv = astextplain [filter \"lfs\"] clean = git-lfs clean -- %f smudge = git-lfs smudge -- %f process = git-lfs filter-process required = true [http] sslBackend = openssl sslCAInfo = C:/Program Files/Git/mingw64/ssl/certs/ca-bundle.crt [core] autocrlf = false fscache = true symlinks = false [pull] rebase = false [credential] helper = manager-core [credential \"https://dev.azure.com\"] useHttpPath = true [init] defaultBranch = master git config --global user.name “yourname” git config --global user.email “email@email.com ” 案例: git config --global user.name \"codingriver\" git config --global user.email \"codingriver@163.com\" ","date":"2019-11-30 14:18:54","objectID":"/git%E7%AC%94%E8%AE%B0/:9:0","tags":["git"],"title":"Git笔记","uri":"/git%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"Git 提交空文件夹 git设计时是不支持空文件夹提交的，这里是在文件夹里面新建.gitignore文件或者.gitkeep空文件来处理的 unity也支持忽略以.开头的文件的 新建.gitignore文件 在空文件夹下新建.gitignore文件，文件内容： ## Ignore everything in this directory * ## Except this file !.gitignore 这样就能提交git仓库了 我这是在windows上操作的，不能直接创建以.开头的文件，参考这篇文章Windows创建.开头的文件或者.开头的文件夹 新建.gitkeep文件 在空文件夹下新建.gitkeep文件，是空文件，这样就能提交git仓库了 ","date":"2019-11-30 14:18:54","objectID":"/git%E7%AC%94%E8%AE%B0/:10:0","tags":["git"],"title":"Git笔记","uri":"/git%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"shell判断git remote是否存在 假如，要判断的 remote 的名字为 faraway。 第一种方案 if git config remote.faraway.url \u003e /dev/null; then … fi 第二种方案 if git remote | grep faraway \u003e /dev/null; then … fi 判断 remote 是否已存在，如果已存在，直接进行 git fetch faraway 等操作，如果不存在，git add remote faraway http://xxxxx 后，再进行操作。 参考： https://www.jianshu.com/p/e4b9c6c6bab7 https://www.cnblogs.com/ibingshan/p/11126345.html https://blog.csdn.net/longerzone/article/details/12948925 ","date":"2019-11-30 14:18:54","objectID":"/git%E7%AC%94%E8%AE%B0/:11:0","tags":["git"],"title":"Git笔记","uri":"/git%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"shell 判断 git branch 分支是否存在 举例：判断当前分支是否为master，本地分支master是否存在，远端分支master是否存在 if git branch --list master | grep \"*\"; then ## 分支名字完全匹配，不是模糊匹配！只能匹配master，不能匹配mastertest等 echo \"当前分支是master\" git reset --hard git clean -df \u003e /dev/null elif git branch --list | grep -w master \u003e /dev/null; then ## 分支名字完全匹配，不是模糊匹配！只能匹配master，不能匹配mastertest等 echo \"master不是当前分支，但本地分支master存在\" git reset --hard git clean -df \u003e /dev/null git checkout master elif git branch -r | grep -w master; then ## 分支名字完全匹配，不是模糊匹配，只能匹配origin/master,不能匹配origin/mastertest等 echo \"本地分支master不存在,远端master分支存在\" git reset --hard git clean -df \u003e /dev/null git checkout -b master origin/master else echo \"本地分支master不存在,远端master分支也不存在\" fi ","date":"2019-11-30 14:18:54","objectID":"/git%E7%AC%94%E8%AE%B0/:12:0","tags":["git"],"title":"Git笔记","uri":"/git%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"shell 判断 git本地工作文件夹是否干净(clean) if [[ -z $(git status -s) ]]; then ## 没有修改的文件和未纳入版本控制的文件(untracked)的文件 echo \"没有可提交内容\" exit 2 fi https://blog.csdn.net/10km/article/details/100689481 ","date":"2019-11-30 14:18:54","objectID":"/git%E7%AC%94%E8%AE%B0/:13:0","tags":["git"],"title":"Git笔记","uri":"/git%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"git文件内容没变但status显示不同的解决方案 这里提示的不同，是文件的权限改变了。 SO，解决方案奏是：不让git检测文件权限的区别 git config core.filemode false 参考: https://blog.csdn.net/u012109105/article/details/51252242 ","date":"2019-11-30 14:18:54","objectID":"/git%E7%AC%94%E8%AE%B0/:14:0","tags":["git"],"title":"Git笔记","uri":"/git%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"The file will have its original line endings in your working directory git 报错： warning: LF will be replaced by CRLF in basic-markdown-syntax/index.html. The file will have its original line endings in your working directory warning: LF will be replaced by CRLF in hugo-loveit-problems/index.html. The file will have its original line endings in your working directory 解决方案： git rm -r --cached . git config core.autocrlf false git add . https://blog.csdn.net/namechenfl/article/details/81257973 ","date":"2019-11-30 14:18:54","objectID":"/git%E7%AC%94%E8%AE%B0/:15:0","tags":["git"],"title":"Git笔记","uri":"/git%E7%AC%94%E8%AE%B0/"},{"categories":["笔记"],"content":"Git处理换行符问题 对仓库使用 .gitattributes文件进行配置 # Set the default behavior, in case people don't have core.autocrlf set. * text=auto #让git自行处理左边匹配的文件使用何种换行符格式，这是默认选项。 # text eol=lf # Explicitly declare text files you want to always be normalized and converted # to native line endings on checkout. *.c text *.h text # Declare files that will always have CRLF line endings on checkout. *.sln text eol=crlf # Denote all files that are truly binary and should not be modified. *.png binary *.jpg binary 参考: https://blog.csdn.net/github_30605157/article/details/56680990 项目在用的.gitattributes文件 * text=auto *.cs diff=csharp text *.cginc text *.shader text *.spriteatlas text eol=lf # Unity YAML *.anim -text merge=unityyamlmerge diff *.asset -text merge=unityyamlmerge diff *.controller -text merge=unityyamlmerge diff *.mat -text merge=unityyamlmerge diff *.meta -text merge=unityyamlmerge diff *.physicMaterial -text merge=unityyamlmerge diff *.physicsMaterial2D -text merge=unityyamlmerge diff *.prefab -text merge=unityyamlmerge diff *.unity -text merge=unityyamlmerge diff # Unity LFS *.cubemap filter=lfs diff=lfs merge=lfs -text *.unitypackage filter=lfs diff=lfs merge=lfs -text # 2D formats *.[aA][iI] filter=lfs diff=lfs merge=lfs -text *.[bB][mM][pP] filter=lfs diff=lfs merge=lfs -text *.[dD][dD][sS] filter=lfs diff=lfs merge=lfs -text *.[eE][xX][rR] filter=lfs diff=lfs merge=lfs -text *.[gG][iI][fF] filter=lfs diff=lfs merge=lfs -text *.[hH][dD][rR] filter=lfs diff=lfs merge=lfs -text *.[iI][fF][fF] filter=lfs diff=lfs merge=lfs -text *.[jJ][pP][eE][gG] filter=lfs diff=lfs merge=lfs -text *.[jJ][pP][gG] filter=lfs diff=lfs merge=lfs -text *.[pP][iI][cC][tT] filter=lfs diff=lfs merge=lfs -text *.[pP][nN][gG] filter=lfs diff=lfs merge=lfs -text *.[pP][sS][dD] filter=lfs diff=lfs merge=lfs -text *.[tT][gG][aA] filter=lfs diff=lfs merge=lfs -text *.[tT][iI][fF] filter=lfs diff=lfs merge=lfs -text *.[tT][iI][fF][fF] filter=lfs diff=lfs merge=lfs -text # 3D formats *.3[dD][mM] filter=lfs diff=lfs merge=lfs -text *.3[dD][sS] filter=lfs diff=lfs merge=lfs -text *.[aA][bB][cC] filter=lfs diff=lfs merge=lfs -text *.[bB][lL][eE][nN][dD] filter=lfs diff=lfs merge=lfs -text *.[cC]4[dD] filter=lfs diff=lfs merge=lfs -text *.[cC][oO][lL][lL][aA][dD][aA] filter=lfs diff=lfs merge=lfs -text *.[dD][aA][eE] filter=lfs diff=lfs merge=lfs -text *.[dD][xX][fF] filter=lfs diff=lfs merge=lfs -text *.[fF][bB][xX] filter=lfs diff=lfs merge=lfs -text *.[jJ][aA][sS] filter=lfs diff=lfs merge=lfs -text *.[lL][wW][oO] filter=lfs diff=lfs merge=lfs -text *.[lL][wW][oO]2 filter=lfs diff=lfs merge=lfs -text *.[lL][wW][sS] filter=lfs diff=lfs merge=lfs -text *.[lL][xX][oO] filter=lfs diff=lfs merge=lfs -text *.[mM][aA] filter=lfs diff=lfs merge=lfs -text *.[mM][aA][xX] filter=lfs diff=lfs merge=lfs -text *.[mM][bB] filter=lfs diff=lfs merge=lfs -text *.[oO][bB][jJ] filter=lfs diff=lfs merge=lfs -text *.[pP][lL][yY] filter=lfs diff=lfs merge=lfs -text *.[sS][kK][pP] filter=lfs diff=lfs merge=lfs -text *.[sS][tT][lL] filter=lfs diff=lfs merge=lfs -text *.[zZ][tT][lL] filter=lfs diff=lfs merge=lfs -text # Audio formats *.[aA][iI][fF] filter=lfs diff=lfs merge=lfs -text *.[aA][iI][fF][fF] filter=lfs diff=lfs merge=lfs -text *.[bB][aA][nN][kK] filter=lfs diff=lfs merge=lfs -text *.[iI][tT] filter=lfs diff=lfs merge=lfs -text *.[mM][oO][dD] filter=lfs diff=lfs merge=lfs -text *.[mM][pP]3 filter=lfs diff=lfs merge=lfs -text *.[oO][gG][gG] filter=lfs diff=lfs merge=lfs -text *.[sS]3[mM] filter=lfs diff=lfs merge=lfs -text *.[wW][aA][vV] filter=lfs diff=lfs merge=lfs -text *.[xX][mM] filter=lfs diff=lfs merge=lfs -text # Video formats *.[aA][sS][fF] filter=lfs diff=lfs merge=lfs -text *.[aA][vV][iI] filter=lfs diff=lfs merge=lfs -text *.[fF][lL][vV] filter=lfs diff=lfs merge=lfs -text *.[mM][oO][vV] filter=lfs diff=lfs merge=lfs -text *.[mM][pP]4 filter=lfs diff=lfs merge=lfs -text *.[mM][pP][eE][gG] filter=lfs diff=lfs merge=lfs -text *.[mM][pP][gG] filter=lfs diff=lfs merge=lfs -text *.[oO]","date":"2019-11-30 14:18:54","objectID":"/git%E7%AC%94%E8%AE%B0/:16:0","tags":["git"],"title":"Git笔记","uri":"/git%E7%AC%94%E8%AE%B0/"}]