<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>OpenGL 图形学记录 - codingriver blog</title><meta name="Description" content="codingriver blog"><meta property="og:title" content="OpenGL 图形学记录" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://codingriver.github.io/opengl%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" />
<meta property="og:image" content="https://codingriver.github.io/logo.png"/>
<meta property="article:published_time" content="2020-09-27T16:03:56+08:00" />
<meta property="article:modified_time" content="2020-09-27T16:03:56+08:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://codingriver.github.io/logo.png"/>

<meta name="twitter:title" content="OpenGL 图形学记录"/>
<meta name="twitter:description" content=""/>
<meta name="application-name" content="codingriver">
<meta name="apple-mobile-web-app-title" content="codingriver"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://codingriver.github.io/opengl%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" /><link rel="prev" href="https://codingriver.github.io/csharp%E8%AE%B0%E5%BD%95/" /><link rel="next" href="https://codingriver.github.io/ugui-text%E6%8D%A2%E8%A1%8C%E9%97%AE%E9%A2%98/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "OpenGL 图形学记录",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/codingriver.github.io\/opengl%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0\/"
        },"genre": "posts","keywords": "opengl","wordcount":  26620 ,
        "url": "https:\/\/codingriver.github.io\/opengl%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0\/","datePublished": "2020-09-27T16:03:56+08:00","dateModified": "2020-09-27T16:03:56+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "xxxx"},"author": {
                "@type": "Person",
                "name": "codingriver"
            },"description": ""
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="codingriver blog"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>codingriver</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/about/"> 关于 </a><a class="menu-item" href="https://github.com/codingriver" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="codingriver blog"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>codingriver</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/about/" title="">关于</a><a class="menu-item" href="https://github.com/codingriver" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">OpenGL 图形学记录</h1><h2 class="single-subtitle">OpenGL图形学记录</h2><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://codingriver.github.io" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>codingriver</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/%E7%AC%94%E8%AE%B0/"><i class="far fa-folder fa-fw"></i>笔记</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2020-09-27 16:03:56">2020-09-27 16:03:56</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 26620 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 54 分钟&nbsp;<span id="/opengl%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" class="leancloud_visitors" data-flag-title="OpenGL 图形学记录">
                        <i class="far fa-eye fa-fw"></i>&nbsp;<span class=leancloud-visitors-count></span>&nbsp;次阅读
                    </span>&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#基础概念">基础概念</a></li>
    <li><a href="#opengl缓冲区对象之vao">OpenGL缓冲区对象之VAO</a>
      <ul>
        <li><a href="#介绍">介绍</a></li>
        <li><a href="#vao包含的内容">VAO包含的内容</a></li>
        <li><a href="#vao的使用">VAO的使用</a>
          <ul>
            <li>
              <ul>
                <li><a href="#1创建vao">1.创建VAO</a></li>
                <li><a href="#2绑定并设置vao">2.绑定并设置VAO</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#纹理">纹理</a>
      <ul>
        <li>
          <ul>
            <li><a href="#纹理绑定">纹理绑定</a></li>
            <li><a href="#纹理环绕方式">纹理环绕方式</a></li>
            <li><a href="#纹理过滤texture-filtering">纹理过滤(Texture Filtering)</a></li>
            <li><a href="#多级渐远纹理mipmap">多级渐远纹理(Mipmap)</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#深度测试depth">深度测试（Depth）</a>
      <ul>
        <li><a href="#深度值精度">深度值精度</a></li>
        <li><a href="#深度冲突">深度冲突</a></li>
        <li><a href="#防止深度冲突">防止深度冲突</a></li>
      </ul>
    </li>
    <li><a href="#模板测试">模板测试</a>
      <ul>
        <li><a href="#物体轮廓描边">物体轮廓(描边)</a></li>
      </ul>
    </li>
    <li><a href="#面剔除face-culling">面剔除（Face culling）</a>
      <ul>
        <li><a href="#环绕顺序">环绕顺序</a></li>
        <li><a href="#面剔除">面剔除</a></li>
      </ul>
    </li>
    <li><a href="#实例化gpu-instancing">实例化（GPU Instancing）</a>
      <ul>
        <li><a href="#基础实例化">基础实例化</a></li>
        <li><a href="#实例化数组">实例化数组</a></li>
      </ul>
    </li>
    <li><a href="#抗锯齿anti-aliasing">抗锯齿（Anti Aliasing）</a>
      <ul>
        <li><a href="#多重采样multisampling">多重采样（Multisampling）</a></li>
        <li><a href="#msaa-multisample-anti-aliasing">MSAA （Multisample Anti Aliasing）</a></li>
        <li><a href="#离屏msaa-off-screen-multisample-anti-aliasing">离屏MSAA (Off Screen Multisample Anti Aliasing)</a></li>
      </ul>
    </li>
    <li><a href="#阴影shadow">阴影（Shadow）</a>
      <ul>
        <li><a href="#阴影映射direct-shadows">阴影映射(Direct Shadows)</a></li>
        <li><a href="#改进阴影贴图">改进阴影贴图</a>
          <ul>
            <li><a href="#阴影失真">阴影失真</a></li>
            <li><a href="#悬浮">悬浮</a></li>
            <li><a href="#采样过多">采样过多</a></li>
            <li><a href="#pcf">PCF</a></li>
          </ul>
        </li>
        <li><a href="#点光源阴影point-shadows">点光源阴影(Point Shadows)</a>
          <ul>
            <li><a href="#生成深度立方体贴图">生成深度立方体贴图</a></li>
            <li><a href="#光空间的变换">光空间的变换</a></li>
            <li><a href="#深度着色器">深度着色器</a></li>
            <li><a href="#万向阴影贴图">万向阴影贴图</a></li>
          </ul>
        </li>
        <li><a href="#csm联机阴影">CSM(联机阴影)</a></li>
      </ul>
    </li>
    <li><a href="#视差贴图视差映射">视差贴图（视差映射）</a>
      <ul>
        <li><a href="#衰减attenuation">衰减（Attenuation）</a></li>
        <li><a href="#色调映射tone-mapping">色调映射(Tone Mapping)</a></li>
      </ul>
    </li>
    <li><a href="#泛光bloom">泛光(Bloom)</a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#glgenbuffers">glGenBuffers</a></li>
            <li><a href="#glbindbuffer">glBindBuffer</a></li>
            <li><a href="#glbufferdata">glBufferData</a></li>
            <li><a href="#glvertexattribpointer">glVertexAttribPointer</a></li>
            <li><a href="#glenablevertexattribarray">glEnableVertexAttribArray</a></li>
            <li><a href="#gldrawarrays">glDrawArrays</a></li>
            <li><a href="#gldrawelements">glDrawElements</a></li>
            <li><a href="#glteximage2d">glTexImage2D</a></li>
            <li><a href="#glbuffersubdata">glBufferSubData</a></li>
            <li><a href="#glmapbuffer">glMapBuffer</a></li>
            <li><a href="#glcopybuffersubdata">glCopyBufferSubData</a></li>
            <li><a href="#glvertexattribdivisor">glVertexAttribDivisor</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><blockquote>
<p>GAMES101-现代计算机图形学入门-闫令琪:<br>
<a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html</a><br>
<a href="https://www.bilibili.com/video/BV1X7411F744">https://www.bilibili.com/video/BV1X7411F744</a><br>
<a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html</a></p>
</blockquote>
<blockquote>
<p>本文主要是OpenGL和相关图形学笔记<br>
学习资料：<a href="https://learnopengl-cn.github.io/" target="_blank" rel="noopener noreffer">https://learnopengl-cn.github.io/</a></p>
</blockquote>
<h2 id="基础概念">基础概念</h2>
<ul>
<li>顶点数组对象：Vertex Array Object，VAO</li>
<li>顶点缓冲对象：Vertex Buffer Object，VBO</li>
<li>索引缓冲对象：Element Buffer Object，EBO或Index Buffer Object，IBO</li>
<li>帧缓冲对象:   Framebuffer Object, FBO</li>
<li>渲染缓冲对象: Renderbuffer Object
<ul>
<li>可以存储depth和stencil,(depth和stencil存储到一个渲染缓冲对象上)</li>
</ul>
</li>
<li>Uniform缓冲对象： Uniform Buffer Object，UBO</li>
<li>多重采样缓冲: Multisample Buffer,MS
<blockquote>
<p>抗锯齿使用的就是多重采样缓冲，MSAA（Multisample Anti Aliasing）</p>
</blockquote>
</li>
<li>图元(Primitive):一系列的点(GL_POINTS),一系列的三角形(GL_TRIANGLES),还是仅仅是一个长长的线(GL_LINE_STRIP)</li>
<li>顶点着色器(Vertex Shader)，它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。</li>
<li>图元装配(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状；本节例子中是一个三角形。</li>
<li>几何着色器(Geometry Shader)。几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。例子中，它生成了另一个三角形。
-光栅化阶段(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。
-片段着色器的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。</li>
</ul>
<blockquote>
<p>OpenGL仅当3D坐标在3个轴（x、y和z）上都为-1.0到1.0的范围内时才处理它。所有在所谓的标准化设备坐标(Normalized Device Coordinates)范围内的坐标才会最终呈现在屏幕上（在这个范围以外的坐标都不会显示）。</p>
</blockquote>
<h2 id="opengl缓冲区对象之vao">OpenGL缓冲区对象之VAO</h2>
<blockquote>
<p>参考： <a href="https://blog.csdn.net/csxiaoshui/article/details/53197527" target="_blank" rel="noopener noreffer">https://blog.csdn.net/csxiaoshui/article/details/53197527</a></p>
</blockquote>
<h3 id="介绍">介绍</h3>
<blockquote>
<p>VAO （ Vertex Array Object ）是OpenGL用来处理顶点数据的一个缓冲区对象，它不能单独使用，都是结合VBO来一起使用的。VAO是OpenGL CoreProfile 引入的一个特性。事实上在CoreProfile中做顶点数据传入时，必须使用VAO方式。</p>
</blockquote>
<p>当我们使用VBO传入顶点数据时，一般的处理如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 绑定VBO，设置VBO中的数据
</span><span class="c1"></span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span>
<span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
<span class="c1">// 1. 设置顶点属性
</span><span class="c1"></span><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">GLfloat</span><span class="p">),</span> <span class="p">(</span><span class="n">GLvoid</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  
<span class="c1">// 2. 使用Shader程序
</span><span class="c1"></span><span class="n">glUseProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
<span class="c1">// 3. 绘制
</span><span class="c1"></span><span class="n">someOpenGLFunctionThatDrawsOurTriangle</span><span class="p">();</span>  
</code></pre></td></tr></table>
</div>
</div><p>每当我们绘制一个几何体时，我们需要重复同样的工作（首先绑定缓冲区、然后设置顶点属性）。当需要绘制的物体很多时，这个过程就显得有些耗时。那么我们有没有一种方式来简化这一过程呢？这就是VAO做的事情，<strong>它将所有顶点绘制过程中的这些设置和绑定过程集中存储在一起</strong>，当我们需要时，只需要使用相应的VAO即可。
VAO的这种方式有点像一个中介，把所有繁琐的绑定和顶点设置工作都集中起来处理，我们需要绘制时，直接找这个中介就好了。</p>
<h3 id="vao包含的内容">VAO包含的内容</h3>
<p>VAO对象中存储的内容包括：</p>
<ol>
<li>VAO开启或者关闭的状态（glEnableVertexAttribArray和glDisableVertexAttribArray)</li>
<li>使用glVertexAttribPointer对顶点属性进行的设置</li>
<li>存储顶点数据的VBO对象<br>
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/ikdC5zqDJXc2Bw3.png"
        data-srcset="../../imgs/ikdC5zqDJXc2Bw3.png, ../../imgs/ikdC5zqDJXc2Bw3.png 1.5x, ../../imgs/ikdC5zqDJXc2Bw3.png 2x"
        data-sizes="auto"
        alt="../../imgs/ikdC5zqDJXc2Bw3.png"
        title="../../imgs/ikdC5zqDJXc2Bw3.png" /></li>
</ol>
<h3 id="vao的使用">VAO的使用</h3>
<h5 id="1创建vao">1.创建VAO</h5>
<p>创建VAO使用<code>glGenVertexArrays</code>参数与创建其他缓冲区对象的glGenBuffers类似
<code>void glGenVertexArrays( GLsizei n, GLuint *arrays);</code></p>
<h5 id="2绑定并设置vao">2.绑定并设置VAO</h5>
<p>在创建VAO之后，需要使用<code>glBindVertexArray</code>设置它为当前操作的VAO，之后我们所有关于顶点数据的设置（包括数据使用的VBO对象，顶点的属性设置的信息都会被存储在VAO之中），在设置完成之后一般会解绑VAO，然后在需要绘制的时候启用相应的VAO对象。具体的代码如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">//创建VAO
</span><span class="c1"></span><span class="n">GLuint</span> <span class="n">VAO</span><span class="p">;</span>
<span class="n">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VAO</span><span class="p">);</span>
<span class="c1">//设置当前VAO，之后所有操作(注意：这些操作必须是上文VAO中包含的内容所注明的调用，其他非VAO中存储的内容即使调用了也不会影响VAO）存储在该VAO中
</span><span class="c1"></span><span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span> <span class="c1">//设置了VBO
</span><span class="c1"></span>    <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">vertices</span><span class="p">,</span>  <span class="n">GL_STATIC_DRAW</span><span class="p">);</span><span class="c1">//设置VBO中的数据
</span><span class="c1"></span>    <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">GLfloat</span><span class="p">),</span> <span class="p">(</span><span class="n">GLvoid</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//设置顶点属性（索引为0的属性，与shader中的内容有交互）
</span><span class="c1"></span>    <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//设置开启顶点属性（索引为0的属性,与shader中的内容有交互）
</span><span class="c1"></span><span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//解绑VAO（解绑主要是为了不影响后续VAO的设置，有点类似于C++中指针delete后置空，是个好习惯）
</span></code></pre></td></tr></table>
</div>
</div><p>通过上面的代码就完成了对VAO的设置，当我们需要绘制的时候，使用的代码类似于：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">glUseProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
<span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span> <span class="c1">//绑定我们需要的VAO，会导致上面所有VAO保存的设置自动设置完成
</span><span class="c1"></span><span class="n">someOpenGLFunctionThatDrawsOurTriangle</span><span class="p">();</span>   
<span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>   <span class="c1">//解绑VAO
</span></code></pre></td></tr></table>
</div>
</div><p>另外需要注意的是，当我们使用EBO的时候，VAO中也会记录索引信息，因此完整的VAO所包含的内容图如下所示（添加了EBO）</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/lqNIL9m6gunKbPS.png"
        data-srcset="../../imgs/lqNIL9m6gunKbPS.png, ../../imgs/lqNIL9m6gunKbPS.png 1.5x, ../../imgs/lqNIL9m6gunKbPS.png 2x"
        data-sizes="auto"
        alt="../../imgs/lqNIL9m6gunKbPS.png"
        title="../../imgs/lqNIL9m6gunKbPS.png" /></p>
<blockquote>
<p>当目标是GL_ELEMENT_ARRAY_BUFFER的时候，VAO会储存glBindBuffer的函数调用。这也意味着它也会储存解绑调用，所以确保你没有在解绑VAO之前解绑索引数组缓冲，否则它就没有这个EBO配置了。</p>
</blockquote>
<h2 id="纹理">纹理</h2>
<h4 id="纹理绑定">纹理绑定</h4>
<p>设置纹理绑定的纹理缓冲区序号：<br>
0 对应纹理对象GL_TEXTURE0，1对应对应纹理对象GL_TEXTURE1</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">ourShader.use(); // 不要忘记在设置uniform变量之前激活着色器程序！
glUniform1i(glGetUniformLocation(ourShader.ID, &#34;texture1&#34;), 0); // 手动设置
glUniform1i(glGetUniformLocation(ourShader.ID, &#34;texture2&#34;), 1); // 手动设置
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, texture1);
glActiveTexture(GL_TEXTURE1);
glBindTexture(GL_TEXTURE_2D, texture2);
</code></pre></td></tr></table>
</div>
</div><h4 id="纹理环绕方式">纹理环绕方式</h4>
<table>
<thead>
<tr>
<th>环绕方式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GL_REPEAT</td>
<td>对纹理的默认行为。重复纹理图像。</td>
</tr>
<tr>
<td>GL_MIRRORED_REPEAT</td>
<td>和GL_REPEAT一样，但每次重复图片是镜像放置的。</td>
</tr>
<tr>
<td>GL_CLAMP_TO_EDGE</td>
<td>纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。</td>
</tr>
<tr>
<td>GL_CLAMP_TO_BORDER</td>
<td>超出的坐标为用户指定的边缘颜色。</td>
</tr>
</tbody>
</table>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/pY3FRq5mevtzdIA.png"
        data-srcset="../../imgs/pY3FRq5mevtzdIA.png, ../../imgs/pY3FRq5mevtzdIA.png 1.5x, ../../imgs/pY3FRq5mevtzdIA.png 2x"
        data-sizes="auto"
        alt="../../imgs/pY3FRq5mevtzdIA.png"
        title="../../imgs/pY3FRq5mevtzdIA.png" /></p>
<p>前面提到的每个选项都可以使用glTexParameter*函数对单独的一个坐标轴设置（s、t（如果是使用3D纹理那么还有一个r）它们和x、y、z是等价的）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_MIRRORED_REPEAT</span><span class="p">);</span>
<span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_MIRRORED_REPEAT</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><em>第一个参数指定了纹理目标；我们使用的是2D纹理，因此纹理目标是GL_TEXTURE_2D。第二个参数需要我们指定设置的选项与应用的纹理轴。我们打算配置的是WRAP选项，并且指定S和T轴。最后一个参数需要我们传递一个环绕方式(Wrapping)，在这个例子中OpenGL会给当前激活的纹理设定纹理环绕方式为GL_MIRRORED_REPEAT。</em></p>
<h4 id="纹理过滤texture-filtering">纹理过滤(Texture Filtering)</h4>
<ul>
<li>
<p>GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）(Point)</p>
</li>
<li>
<p>GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）(Line)</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_NEAREST</span><span class="p">);</span>
<span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="多级渐远纹理mipmap">多级渐远纹理(Mipmap)</h4>
<table>
<thead>
<tr>
<th>过滤方式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GL_NEAREST_MIPMAP_NEAREST</td>
<td>使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样</td>
</tr>
<tr>
<td>GL_LINEAR_MIPMAP_NEAREST</td>
<td>使用最邻近的多级渐远纹理级别，并使用线性插值进行采样</td>
</tr>
<tr>
<td>GL_NEAREST_MIPMAP_LINEAR</td>
<td>在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样</td>
</tr>
<tr>
<td>GL_LINEAR_MIPMAP_LINEAR</td>
<td>在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样</td>
</tr>
</tbody>
</table>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR_MIPMAP_LINEAR</span><span class="p">);</span>
<span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="深度测试depth">深度测试（Depth）</h2>
<blockquote>
<p>深度缓冲就像颜色缓冲(Color Buffer)（储存所有的片段颜色：视觉输出）一样，在每个片段中储存了信息，并且（通常）和颜色缓冲有着一样的宽度和高度。深度缓冲是由窗口系统自动创建的，它会以16、24或32位float的形式储存它的深度值。在大部分的系统中，<code>深度缓冲的精度都是24位的</code></p>
</blockquote>
<ul>
<li>启动深度测试 <code>glEnable(GL_DEPTH_TEST);</code></li>
<li>清除深度缓冲 <code>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</code></li>
<li>只读深度比较，不做写入 <code>glDepthMask(GL_FALSE);</code></li>
<li>深度测试函数 <code>glDepthFunc(GL_LESS);</code><br>
这个函数接受下面表格中的比较运算符：</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GL_ALWAYS</td>
<td>永远通过深度测试</td>
</tr>
<tr>
<td>GL_NEVER</td>
<td>永远不通过深度测试</td>
</tr>
<tr>
<td>GL_LESS</td>
<td>在片段深度值小于缓冲的深度值时通过测试</td>
</tr>
<tr>
<td>GL_EQUAL</td>
<td>在片段深度值等于缓冲区的深度值时通过测试</td>
</tr>
<tr>
<td>GL_LEQUAL</td>
<td>在片段深度值小于等于缓冲区的深度值时通过测试</td>
</tr>
<tr>
<td>GL_GREATER</td>
<td>在片段深度值大于缓冲区的深度值时通过测试</td>
</tr>
<tr>
<td>GL_NOTEQUAL</td>
<td>在片段深度值不等于缓冲区的深度值时通过测试</td>
</tr>
<tr>
<td>GL_GEQUAL</td>
<td>在片段深度值大于等于缓冲区的深度值时通过测试</td>
</tr>
</tbody>
</table>
<h3 id="深度值精度">深度值精度</h3>
<p><code>结论</code>: <strong>屏幕空间中的深度值是非线性的，即它在z值很小的时候有很高的精度，而z值很大的时候有较低的精度。</strong></p>
<blockquote>
<p>下面这个（线性）方程将z值变换到了0.0到1.0之间的深度值：<br>
<strong>F<sub>depth</sub>=(z−near)/(far−near)</strong></p>
<p><em>然而，在实践中是几乎永远不会使用这样的线性深度缓冲(Linear Depth Buffer)的。要想有正确的投影性质，需要使用一个非线性的深度方程，它是与 1/z 成正比的。它做的就是在z值很小的时候提供非常高的精度，而在z值很远的时候提供更少的精度。花时间想想这个：我们真的需要对1000单位远的深度值和只有1单位远的充满细节的物体使用相同的精度吗？线性方程并不会考虑这一点。</em></p>
</blockquote>
<p>由于非线性方程与 1/z 成正比，在1.0和2.0之间的z值将会变换至1.0到0.5之间的深度值，这就是一个float提供给我们的一半精度了，这在z值很小的情况下提供了非常大的精度。在50.0和100.0之间的z值将会只占2%的float精度，这正是我们所需要的。这样的一个考虑了远近距离的方程是这样的：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/pZG7HK4saPDfc6l.png"
        data-srcset="../../imgs/pZG7HK4saPDfc6l.png, ../../imgs/pZG7HK4saPDfc6l.png 1.5x, ../../imgs/pZG7HK4saPDfc6l.png 2x"
        data-sizes="auto"
        alt="../../imgs/pZG7HK4saPDfc6l.png"
        title="../../imgs/pZG7HK4saPDfc6l.png" /></p>
<p>如果你不知道这个方程是怎么回事也不用担心。重要的是要记住深度缓冲中的值在屏幕空间中不是线性的（在透视矩阵应用之前在观察空间中是线性的）。深度缓冲中0.5的值并不代表着物体的z值是位于平截头体的中间了，这个顶点的z值实际上非常接近近平面！你可以在下图中看到z值和最终的深度缓冲值之间的非线性关系：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/Ov2TdRoxZepPLF1.png"
        data-srcset="../../imgs/Ov2TdRoxZepPLF1.png, ../../imgs/Ov2TdRoxZepPLF1.png 1.5x, ../../imgs/Ov2TdRoxZepPLF1.png 2x"
        data-sizes="auto"
        alt="../../imgs/Ov2TdRoxZepPLF1.png"
        title="../../imgs/Ov2TdRoxZepPLF1.png" /></p>
<p>可以看到，深度值很大一部分是由很小的z值所决定的，这给了近处的物体很大的深度精度。这个（从观察者的视角）变换z值的方程是嵌入在投影矩阵中的，所以当我们想将一个顶点坐标从观察空间至裁剪空间的时候这个非线性方程就被应用了。</p>
<h3 id="深度冲突">深度冲突</h3>
<p>一个很常见的视觉错误会在两个平面或者三角形非常紧密地平行排列在一起时会发生，深度缓冲没有足够的精度来决定两个形状哪个在前面。结果就是这两个形状不断地在切换前后顺序，这会导致很奇怪的花纹。这个现象叫做<code>深度冲突</code>(Z-fighting),因为它看起来像是这两个形状在争夺(Fight)谁该处于顶端。</p>
<h3 id="防止深度冲突">防止深度冲突</h3>
<p>第一个也是最重要的技巧是<strong>永远不要把多个物体摆得太靠近，以至于它们的一些三角形会重叠</strong>。通过在两个物体之间设置一个用户无法注意到的偏移值，你可以完全避免这两个物体之间的深度冲突。在箱子和地板的例子中，我们可以将箱子沿着正y轴稍微移动一点。箱子位置的这点微小改变将不太可能被注意到，但它能够完全减少深度冲突的发生。然而，这需要对每个物体都手动调整，并且需要进行彻底的测试来保证场景中没有物体会产生深度冲突。</p>
<p>第二个技巧是<strong>尽可能将近平面设置远一些</strong>。在前面我们提到了精度在靠近近平面时是非常高的，所以如果我们将近平面远离观察者，我们将会对整个平截头体有着更大的精度。然而，将近平面设置太远将会导致近处的物体被裁剪掉，所以这通常需要实验和微调来决定最适合你的场景的近平面距离。</p>
<p>另外一个很好的技巧是牺牲一些性能，<strong>使用更高精度的深度缓冲</strong>。大部分深度缓冲的精度都是24位的，但现在大部分的显卡都支持32位的深度缓冲，这将会极大地提高精度。所以，牺牲掉一些性能，你就能获得更高精度的深度测试，减少深度冲突。</p>
<p>我们上面讨论的三个技术是最普遍也是很容易实现的抗深度冲突技术了。还有一些更复杂的技术，但它们依然不能完全消除深度冲突。深度冲突是一个常见的问题，但如果你组合使用了上面列举出来的技术，你可能不会再需要处理深度冲突了。</p>
<hr>
<h2 id="模板测试">模板测试</h2>
<blockquote>
<p>当片段着色器处理完一个片段之后，<code>模板测试</code>(Stencil Test)会开始执行，和深度测试一样，它也可能会丢弃片段。接下来，被保留的片段会进入深度测试，它可能会丢弃更多的片段。模板测试是根据又一个缓冲来进行的，它叫做<code>模板缓冲</code>(Stencil Buffer)，我们可以在渲染的时候更新它来获得一些很有意思的效果。</p>
</blockquote>
<p>一个模板缓冲中，（通常）每个<code>模板值</code>(Stencil Value)是<code>8位</code>的。所以每个像素/片段一共能有256种不同的模板值。我们可以将这些模板值设置为我们想要的值，然后当某一个片段有某一个模板值的时候，我们就可以选择丢弃或是保留这个片段了。</p>
<p>模板缓冲的一个简单的例子如下：<br>
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/WA4drmBOYhfpJgU.png"
        data-srcset="../../imgs/WA4drmBOYhfpJgU.png, ../../imgs/WA4drmBOYhfpJgU.png 1.5x, ../../imgs/WA4drmBOYhfpJgU.png 2x"
        data-sizes="auto"
        alt="../../imgs/WA4drmBOYhfpJgU.png"
        title="../../imgs/WA4drmBOYhfpJgU.png" /></p>
<p>模板缓冲使用大概步骤：</p>
<ul>
<li>启用模板缓冲的写入 <code>glEnable(GL_STENCIL_TEST);</code></li>
<li>清除模板缓冲<br>
<code>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);</code></li>
<li>渲染物体，更新模板缓冲的内容。</li>
<li>禁用模板缓冲的写入。</li>
<li>渲染（其它）物体，这次根据模板缓冲的内容丢弃特定的片段。</li>
</ul>
<p>所以，通过使用模板缓冲，我们可以根据场景中已绘制的其它物体的片段，来决定是否丢弃特定的片段。</p>
<p>和深度测试的glDepthMask函数一样，模板缓冲也有一个类似的函数。glStencilMask允许我们设置一个位掩码(Bitmask)，它会与将要写入缓冲的模板值进行与(AND)运算。默认情况下设置的位掩码所有位都为1，不影响输出，但如果我们将它设置为0x00，写入缓冲的所有模板值最后都会变成0.这与深度测试中的glDepthMask(GL_FALSE)是等价的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">glStencilMask</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">);</span> <span class="c1">// 每一位写入模板缓冲时都保持原样
</span><span class="c1"></span><span class="n">glStencilMask</span><span class="p">(</span><span class="mh">0x00</span><span class="p">);</span> <span class="c1">// 每一位在写入模板缓冲时都会变成0（禁用写入）
</span></code></pre></td></tr></table>
</div>
</div><p>大部分情况下你都只会使用0x00或者0xFF作为模板掩码(Stencil Mask)，但是知道有选项可以设置自定义的位掩码总是好的。</p>
<p>模板函数:
<code>glStencilFunc(GLenum func, GLint ref, GLuint mask)</code>
参数说明：</p>
<ul>
<li>func：设置模板测试函数(Stencil Test Function)。这个测试函数将会应用到已储存的模板值上和glStencilFunc函数的<code>ref</code>值上。可用的选项有：GL_NEVER、GL_LESS、GL_LEQUAL、GL_GREATER、GL_GEQUAL、GL_EQUAL、GL_NOTEQUAL和GL_ALWAYS。它们的语义和深度缓冲的函数类似。</li>
<li>ref：设置了模板测试的参考值(Reference Value)。模板缓冲的内容将会与这个值进行比较。</li>
<li>mask：设置一个掩码，它将会与参考值和储存的模板值在测试比较它们之前进行与(AND)运算。初始情况下所有位都为1。</li>
</ul>
<p>例子：<code>glStencilFunc(GL_EQUAL, 1, 0xFF)</code></p>
<p>但是glStencilFunc仅仅描述了OpenGL应该对模板缓冲内容做什么，而不是我们应该如何更新缓冲。这就需要glStencilOp这个函数了。</p>
<p><code>glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)</code><br>
参数说明：</p>
<ul>
<li>sfail：模板测试失败时采取的行为。</li>
<li>dpfail：模板测试通过，但深度测试失败时采取的行为。</li>
<li>dppass：模板测试和深度测试都通过时采取的行为。</li>
</ul>
<p>每个选项都可以选用以下的其中一种行为：</p>
<table>
<thead>
<tr>
<th>行为</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GL_KEEP</td>
<td>保持当前储存的模板值</td>
</tr>
<tr>
<td>GL_ZERO</td>
<td>将模板值设置为0</td>
</tr>
<tr>
<td>GL_REPLACE</td>
<td>将模板值设置为glStencilFunc函数设置的ref值</td>
</tr>
<tr>
<td>GL_INCR</td>
<td>如果模板值小于最大值则将模板值加1</td>
</tr>
<tr>
<td>GL_INCR_WRAP</td>
<td>与GL_INCR一样，但如果模板值超过了最大值则归零</td>
</tr>
<tr>
<td>GL_DECR</td>
<td>如果模板值大于最小值则将模板值减1</td>
</tr>
<tr>
<td>GL_DECR_WRAP</td>
<td>与GL_DECR一样，但如果模板值小于0则将其设置为最大值</td>
</tr>
<tr>
<td>GL_INVERT</td>
<td>按位翻转当前的模板缓冲值</td>
</tr>
</tbody>
</table>
<p><em>默认情况下glStencilOp是设置为(GL_KEEP, GL_KEEP, GL_KEEP)的，所以不论任何测试的结果是如何，模板缓冲都会保留它的值。默认的行为不会更新模板缓冲，所以如果你想写入模板缓冲的话，你需要至少对其中一个选项设置不同的值。</em></p>
<p>所以，通过使用glStencilFunc和glStencilOp，我们可以精确地指定更新模板缓冲的时机与行为了，我们也可以指定什么时候该让模板缓冲通过，即什么时候片段需要被丢弃。</p>
<h3 id="物体轮廓描边">物体轮廓(描边)</h3>
<p>物体创建轮廓的步骤:</p>
<ul>
<li>在绘制（需要添加轮廓的）物体之前，将模板函数设置为GL_ALWAYS，每当物体的片段被渲染时，将模板缓冲更新为1。</li>
<li>渲染物体。</li>
<li>禁用模板写入以及深度测试。</li>
<li>将每个物体缩放一点点。</li>
<li>使用一个不同的片段着色器，输出一个单独的（边框）颜色。</li>
<li>再次绘制物体，但只在它们片段的模板值不等于1时才绘制。</li>
<li>再次启用模板写入和深度测试。</li>
</ul>
<blockquote>
<p>假设绘制Cube物体A的描边：</p>
<ol>
<li>先清除模板缓冲区</li>
<li>绘制物体A：写入A对应的模板值（Always），设置为1，绘制A</li>
<li>绘制描边颜色：对A放大到1.1倍，然后比较模板值和1是否相同，如果不同则执行绘制颜色。</li>
</ol>
</blockquote>
<h2 id="面剔除face-culling">面剔除（Face culling）</h2>
<h3 id="环绕顺序">环绕顺序</h3>
<p>当我们定义一组三角形顶点时，我们会以特定的环绕顺序来定义它们，可能是顺时针(Clockwise)的，也可能是逆时针(Counter-clockwise)的。每个三角形由3个顶点所组成，我们会从三角形中间来看，为这3个顶点设定一个环绕顺序。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/zVjb47QgLwkahme.png"
        data-srcset="../../imgs/zVjb47QgLwkahme.png, ../../imgs/zVjb47QgLwkahme.png 1.5x, ../../imgs/zVjb47QgLwkahme.png 2x"
        data-sizes="auto"
        alt="../../imgs/zVjb47QgLwkahme.png"
        title="../../imgs/zVjb47QgLwkahme.png" /></p>
<p>怎样分析顶点数据的顺序:</p>
<ul>
<li><strong>正面</strong>：按照逆时针顶点连接顺序的三角形面</li>
<li><strong>背面</strong>：按照顺时针顶点连接顺序的三角形面</li>
</ul>
<p>可以看到，我们首先定义了顶点1，之后我们可以选择定义顶点2或者顶点3，这个选择将定义了这个三角形的环绕顺序。下面的代码展示了这点：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">float</span> <span class="n">vertices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// 顺时针
</span><span class="c1"></span>    <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="c1">// 顶点1
</span><span class="c1"></span>    <span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="c1">// 顶点2
</span><span class="c1"></span>    <span class="n">vertices</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="c1">// 顶点3
</span><span class="c1"></span>    <span class="c1">// 逆时针
</span><span class="c1"></span>    <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="c1">// 顶点1
</span><span class="c1"></span>    <span class="n">vertices</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="c1">// 顶点3
</span><span class="c1"></span>    <span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1">// 顶点2  
</span><span class="c1"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>每组组成三角形图元的三个顶点就包含了一个环绕顺序。OpenGL在渲染图元的时候将使用这个信息来决定一个三角形是一个正向三角形还是背向三角形。默认情况下，逆时针顶点所定义的三角形将会被处理为正向三角形。</p>
<p>当你定义顶点顺序的时候，你应该想象对应的三角形是面向你的，所以你定义的三角形从正面看去应该是逆时针的。这样定义顶点很棒的一点是，实际的环绕顺序是在光栅化阶段进行的，也就是顶点着色器运行之后。这些顶点就是从观察者视角所见的了。</p>
<p>观察者所面向的所有三角形顶点就是我们所指定的正确环绕顺序了，而立方体另一面的三角形顶点则是以相反的环绕顺序所渲染的。这样的结果就是，我们所面向的三角形将会是正向三角形，而背面的三角形则是背向三角形。下面这张图显示了这个效果：<br>
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/ZhpGCgBQLJvtaTc.png"
        data-srcset="../../imgs/ZhpGCgBQLJvtaTc.png, ../../imgs/ZhpGCgBQLJvtaTc.png 1.5x, ../../imgs/ZhpGCgBQLJvtaTc.png 2x"
        data-sizes="auto"
        alt="../../imgs/ZhpGCgBQLJvtaTc.png"
        title="../../imgs/ZhpGCgBQLJvtaTc.png" /></p>
<ul>
<li>当观察者在右侧时，则右侧的三角形方向为逆时针方向则为正面，左侧的三角形为顺时针为背面</li>
<li>当观察者在左侧时，则左侧的三角形方向为逆时针方向为正面，右侧的三角形为顺时针为背面</li>
<li>正面和背面是由三角形的顶点定义顺序和观察者的方向共同决定的，随着观察者的角度方向改变，正面背面也会跟着改变</li>
</ul>
<p><em>在顶点数据中，我们将两个三角形都以逆时针顺序定义（正面的三角形是1、2、3，背面的三角形也是1、2、3（如果我们从正面看这个三角形的话））。然而，如果从观察者当前视角使用1、2、3的顺序来绘制的话，从观察者的方向来看，背面的三角形将会是以顺时针顺序渲染的。虽然背面的三角形是以逆时针定义的，它现在是以顺时针顺序渲染的了。这正是我们想要剔除（Cull，丢弃）的不可见面了！</em></p>
<p>在顶点数据中，我们定义的是两个逆时针顺序的三角形。然而，从观察者的方面看，后面的三角形是顺时针的，如果我们仍以1、2、3的顺序以观察者当面的视野看的话。即使我们以逆时针顺序定义后面的三角形，它现在还是变为顺时针。它正是我们打算剔除（丢弃）的不可见的面！</p>
<h3 id="面剔除">面剔除</h3>
<p>启用面剔除：<br>
<code>glEnable(GL_CULL_FACE);</code></p>
<p>剔除背面还是正面：<br>
<code>glCullFace(GL_FRONT);</code>
glCullFace函数有三个可用的选项：</p>
<ul>
<li>GL_BACK：只剔除背向面。</li>
<li>GL_FRONT：只剔除正向面。</li>
<li>GL_FRONT_AND_BACK：剔除正向面和背向面。</li>
</ul>
<p>glCullFace的初始值是GL_BACK。除了需要剔除的面之外，我们也可以通过调用glFrontFace，告诉OpenGL我们希望将顺时针的面（而不是逆时针的面）定义为正向面：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">glFrontFace</span><span class="p">(</span><span class="n">GL_CCW</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><em>默认值是GL_CCW，它代表的是逆时针的环绕顺序，另一个选项是GL_CW，它（显然）代表的是顺时针顺序。</em></p>
<p>我们可以来做一个实验，告诉OpenGL现在顺时针顺序代表的是正向面：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_CULL_FACE</span><span class="p">);</span>
<span class="n">glCullFace</span><span class="p">(</span><span class="n">GL_BACK</span><span class="p">);</span>
<span class="n">glFrontFace</span><span class="p">(</span><span class="n">GL_CW</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>这样的结果是只有背向面被渲染了：<br>
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/b3IKft8dPpEUrWC.png"
        data-srcset="../../imgs/b3IKft8dPpEUrWC.png, ../../imgs/b3IKft8dPpEUrWC.png 1.5x, ../../imgs/b3IKft8dPpEUrWC.png 2x"
        data-sizes="auto"
        alt="../../imgs/b3IKft8dPpEUrWC.png"
        title="../../imgs/b3IKft8dPpEUrWC.png" /></p>
<p>注意你可以仍使用默认的逆时针环绕顺序，但剔除正向面，来达到相同的效果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">glEnable</span><span class="p">(</span><span class="n">GL_CULL_FACE</span><span class="p">);</span>
<span class="n">glCullFace</span><span class="p">(</span><span class="n">GL_FRONT</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到，面剔除是一个提高OpenGL程序性能的很棒的工具。但你需要记住哪些物体能够从面剔除中获益，而哪些物体不应该被剔除。</p>
<p>开关正背面剔除和用户指定逆时针/顺时针为正面的代码实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">//开启表面剔除（默认是背面剔除）
</span><span class="c1"></span><span class="kt">void</span> <span class="n">glEnable</span><span class="p">(</span><span class="n">GL_CULL_FACE</span><span class="p">)</span>
<span class="c1">//关闭表面剔除
</span><span class="c1"></span><span class="kt">void</span> <span class="n">glDisable</span><span class="p">(</span><span class="n">GL_CULL_FACE</span><span class="p">)</span>
<span class="c1">//用户选择剔除哪个面（正面/背面）
</span><span class="c1"></span><span class="kt">void</span> <span class="n">glCullFace</span><span class="p">(</span><span class="o">&lt;</span><span class="err">#</span><span class="n">GLenum</span> <span class="n">mode</span><span class="err">#</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">model参数为</span><span class="err">：</span><span class="n">GL_FRONT_AND_BACK</span><span class="p">,</span><span class="n">GL_FRONT</span><span class="p">,</span><span class="n">GL_BACK</span>
<span class="c1">//用户指定逆时针/顺时针为正面，默认为逆时针
</span><span class="c1"></span><span class="kt">void</span> <span class="n">glFrontFace</span><span class="p">(</span><span class="o">&lt;</span><span class="err">#</span><span class="n">GLenum</span> <span class="n">mode</span><span class="err">#</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">model参数为</span><span class="err">：</span><span class="n">GL_CW</span><span class="p">,</span><span class="n">GL_CCW</span><span class="p">(</span><span class="err">默认值</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="实例化gpu-instancing">实例化（GPU Instancing）</h2>
<blockquote>
<p>如果我们能够将数据一次性发送给GPU，然后使用一个绘制函数让OpenGL利用这些数据绘制多个物体，就会更方便了。这就是实例化(Instancing)。</p>
<p>实例化这项技术能够让我们使用一个渲染调用来绘制多个物体，来节省每次绘制物体时CPU -&gt; GPU的通信，它只需要一次即可。如果想使用实例化渲染，我们只需要将glDrawArrays和glDrawElements的渲染调用分别改为glDrawArraysInstanced和glDrawElementsInstanced就可以了。这些渲染函数的<code>实例化</code>版本需要一个额外的参数，叫做<code>实例数量</code>(Instance Count)，它能够设置我们需要渲染的实例个数。这样我们只需要将必须的数据发送到GPU一次，然后使用一次函数调用告诉GPU它应该如何绘制这些实例。GPU将会直接渲染这些实例，而不用不断地与CPU进行通信。<br>
这个函数本身并没有什么用。渲染同一个物体一千次对我们并没有什么用处，每个物体都是完全相同的，而且还在同一个位置。我们只能看见一个物体！处于这个原因，GLSL在顶点着色器中嵌入了另一个内建变量，<code>gl_InstanceID</code>。</p>
<p>在使用实例化渲染调用时，<code>gl_InstanceID</code>会从0开始，在每个实例被渲染时递增1。比如说，我们正在渲染第43个实例，那么顶点着色器中它的gl_InstanceID将会是42。因为每个实例都有唯一的ID，我们可以建立一个数组，将ID与位置值对应起来，将每个实例放置在世界的不同位置。</p>
</blockquote>
<h3 id="基础实例化">基础实例化</h3>
<p>直接上案例 ,绘制100个片显示在屏幕上</p>
<p>vertex shader代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#version 330 core
</span><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">aPos</span><span class="p">;</span>
<span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aColor</span><span class="p">;</span>

<span class="n">out</span> <span class="n">vec3</span> <span class="n">fColor</span><span class="p">;</span>

<span class="n">uniform</span> <span class="n">vec2</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">vec2</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">[</span><span class="n">gl_InstanceID</span><span class="p">];</span>
    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
    <span class="n">fColor</span> <span class="o">=</span> <span class="n">aColor</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>c++代码（部分）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">shader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
<span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">stringstream</span> <span class="n">ss</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">index</span><span class="p">;</span>
    <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span> 
    <span class="n">index</span> <span class="o">=</span> <span class="n">ss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span> 
    <span class="n">shader</span><span class="p">.</span><span class="n">setVec2</span><span class="p">((</span><span class="s">&#34;offsets[&#34;</span> <span class="o">+</span> <span class="n">index</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="p">).</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">translations</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="c1">//在循环中执行
</span><span class="c1"></span>
<span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">quadVAO</span><span class="p">);</span>
<span class="n">glDrawArraysInstanced</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="实例化数组">实例化数组</h3>
<blockquote>
<p>这里和unity中的shader不一样的地方是可以自定义顶点属性进行设置aOffset没有语义,在untiy中:</p>
</blockquote>
<pre><code>```c
            struct appdata
            {
                float4 vertex : POSITION; //模型空间顶点坐标
                half2 texcoord0 : TEXCOORD0; //第一套UV
                half2 texcoord1 : TEXCOORD1; //第二套UV
                half2 texcoord2 : TEXCOORD2; //第二套UV
                half2 texcoord4 : TEXCOORD3;  //模型最多只能有4套UV
                half4 color : COLOR; //顶点颜色
                half3 normal : NORMAL; //顶点法线
                half4 tangent : TANGENT; //顶点切线(模型导入Unity后自动计算得到)				
            };
```
</code></pre>
<blockquote>
<p>unity中的顶点属性都有语义，而这里OpenGL可以自定义顶点属性<code>aOffset</code>，并且对<code>aOffset</code>再c++中进行设置处理</p>
</blockquote>
<p>例子：
vertex shader代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#version 330 core
</span><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">aPos</span><span class="p">;</span>
<span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aColor</span><span class="p">;</span>
<span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">aOffset</span><span class="p">;</span>

<span class="n">out</span> <span class="n">vec3</span> <span class="n">fColor</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span> <span class="o">+</span> <span class="n">aOffset</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
    <span class="n">fColor</span> <span class="o">=</span> <span class="n">aColor</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>c++代码（部分）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">quadVAO</span><span class="p">,</span> <span class="n">quadVBO</span><span class="p">;</span>
    <span class="n">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">quadVAO</span><span class="p">);</span>
    <span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">quadVBO</span><span class="p">);</span>
    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">quadVAO</span><span class="p">);</span>
    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">quadVBO</span><span class="p">);</span>
    <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">quadVertices</span><span class="p">),</span> <span class="n">quadVertices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
    <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">5</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">5</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)));</span>

    <span class="c1">// also set instance data 设置aOffset顶点属性的instance数据
</span><span class="c1"></span>    <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">instanceVBO</span><span class="p">);</span> <span class="c1">// this attribute comes from a different vertex buffer
</span><span class="c1"></span>    <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">glVertexAttribDivisor</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// tell OpenGL this is an instanced vertex attribute.
</span><span class="c1"></span>
    <span class="c1">//循环中执行
</span><span class="c1"></span>        <span class="c1">// draw 100 instanced quads
</span><span class="c1"></span>        <span class="n">shader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
        <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">quadVAO</span><span class="p">);</span>
        <span class="n">glDrawArraysInstanced</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span> <span class="c1">// 100 triangles of 6 vertices each    
</span></code></pre></td></tr></table>
</div>
</div><p>我们调用了glVertexAttribDivisor。这个函数告诉了OpenGL该什么时候更新顶点属性的内容至新一组数据。它的第一个参数是需要的顶点属性，第二个参数是属性除数(Attribute Divisor)。默认情况下，属性除数是0，告诉OpenGL我们需要在顶点着色器的每次迭代时更新顶点属性。将它设置为1时，我们告诉OpenGL我们希望在渲染一个新实例的时候更新顶点属性。而设置为2时，我们希望每2个实例更新一次属性，以此类推。我们将属性除数设置为1，是在告诉OpenGL，处于位置值2的顶点属性是一个实例化数组。</p>
<h2 id="抗锯齿anti-aliasing">抗锯齿（Anti Aliasing）</h2>
<h3 id="多重采样multisampling">多重采样（Multisampling）</h3>
<blockquote>
<blockquote>
<p>光栅化时执行</p>
</blockquote>
</blockquote>
<p>多重采样所做的正是将单一的采样点变为多个采样点（这也是它名称的由来）。我们不再使用像素中心的单一采样点，取而代之的是以特定图案排列的4个子采样点(Subsample)。我们将用这些子采样点来决定像素的遮盖度。当然，这也意味着颜色缓冲的大小会随着子采样点的增加而增加。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/pQFnBoRqytPvKEe.png"
        data-srcset="../../imgs/pQFnBoRqytPvKEe.png, ../../imgs/pQFnBoRqytPvKEe.png 1.5x, ../../imgs/pQFnBoRqytPvKEe.png 2x"
        data-sizes="auto"
        alt="../../imgs/pQFnBoRqytPvKEe.png"
        title="../../imgs/pQFnBoRqytPvKEe.png" /></p>
<p>上图的左侧展示了正常情况下判定三角形是否遮盖的方式。在例子中的这个像素上不会运行片段着色器（所以它会保持空白）。因为它的采样点并未被三角形所覆盖。上图的右侧展示的是实施多重采样之后的版本，每个像素包含有4个采样点（<code>子采样点</code>）。这里，只有两个采样点遮盖住了三角形。</p>
<p><em>从这里开始多重采样就变得有趣起来了。我们知道三角形只遮盖了2个子采样点，所以下一步是决定这个像素的颜色。你的猜想可能是，我们对每个被遮盖住的子采样点运行一次片段着色器，最后将每个像素所有子采样点的颜色平均一下。在这个例子中，我们需要在两个子采样点上对被插值的顶点数据运行两次片段着色器，并将结果的颜色储存在这些采样点中。（幸运的是）这并不是它工作的方式，因为这本质上说还是需要运行更多次的片段着色器，会显著地降低性能。</em></p>
<p>MSAA真正的工作方式是，<strong><code>无论三角形遮盖了多少个子采样点，（每个图元中）每个像素只运行一次片段着色器</code></strong>。片段着色器所使用的顶点数据会插值到每个像素的中心，所得到的结果颜色会被储存在每个被遮盖住的子采样点中。当颜色缓冲的子样本被图元的所有颜色填满时，所有的这些颜色将会在每个像素内部平均化。因为上图的4个采样点中只有2个被遮盖住了，这个像素的颜色将会是三角形颜色与其他两个采样点的颜色（在这里是无色）的平均值，最终形成一种淡蓝色。</p>
<h3 id="msaa-multisample-anti-aliasing">MSAA （Multisample Anti Aliasing）</h3>
<blockquote>
<p>如果我们想要在OpenGL中使用MSAA，我们必须要使用一个能在每个像素中存储大于1个颜色值的颜色缓冲（因为多重采样需要我们为每个采样点都储存一个颜色）。所以，我们需要一个新的缓冲类型，来存储特定数量的多重采样样本，它叫做 <strong>多重采样缓冲</strong>(Multisample Buffer)。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_SAMPLES</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>现在再调用glfwCreateWindow创建渲染窗口时，每个屏幕坐标就会使用一个包含4个子采样点的颜色缓冲了。GLFW会自动创建一个每像素4个子采样点的深度和样本缓冲。这也意味着所有缓冲的大小都增长了4倍。现在是在 <strong>显示的FBO</strong> 中进行实时抗锯齿计算。</p>
<h3 id="离屏msaa-off-screen-multisample-anti-aliasing">离屏MSAA (Off Screen Multisample Anti Aliasing)</h3>
<blockquote>
<p>由于GLFW负责了创建多重采样缓冲，启用MSAA非常简单。然而，如果我们想要使用我们自己的帧缓冲来进行离屏渲染，那么我们就必须要自己动手生成多重采样缓冲了。<br>
有两种方式可以创建多重采样缓冲，将其作为帧缓冲的附件：纹理附件和渲染缓冲附件，这和在帧缓冲教程中所讨论的普通附件很相似。</p>
</blockquote>
<ul>
<li>多重采样纹理附件</li>
</ul>
<p>为了创建一个支持储存多个采样点的纹理，我们使用<code>glTexImage2DMultisample</code>来替代<code>glTexImage2D</code>，它的纹理目标是<code>GL_TEXTURE_2D_MULTISAPLE</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D_MULTISAMPLE</span><span class="p">,</span> <span class="n">tex</span><span class="p">);</span>
<span class="n">glTexImage2DMultisample</span><span class="p">(</span><span class="n">GL_TEXTURE_2D_MULTISAMPLE</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">GL_TRUE</span><span class="p">);</span>
<span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D_MULTISAMPLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>它的第二个参数设置的是纹理所拥有的样本个数。如果最后一个参数为GL_TRUE，图像将会对每个纹素使用相同的样本位置以及相同数量的子采样点个数。</p>
<p>我们使用glFramebufferTexture2D将多重采样纹理附加到帧缓冲上，但这里纹理类型使用的是GL_TEXTURE_2D_MULTISAMPLE。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D_MULTISAMPLE</span><span class="p">,</span> <span class="n">tex</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>当前绑定的帧缓冲现在就有了一个纹理图像形式的多重采样颜色缓冲。</p>
<ul>
<li>多重采样渲染缓冲对象</li>
</ul>
<p>和纹理类似，创建一个多重采样渲染缓冲对象并不难。我们所要做的只是在指定（当前绑定的）渲染缓冲的内存存储时，将glRenderbufferStorage的调用改为glRenderbufferStorageMultisample就可以了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">glRenderbufferStorageMultisample</span><span class="p">(</span><span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">GL_DEPTH24_STENCIL8</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>函数中，渲染缓冲对象后的参数我们将设定为样本的数量，在当前的例子中是4。</p>
<ul>
<li>渲染到多重采样帧缓冲</li>
</ul>
<p>渲染到多重采样帧缓冲对象的过程都是自动的。只要我们在帧缓冲绑定时绘制任何东西，光栅器就会负责所有的多重采样运算。我们最终会得到一个多重采样颜色缓冲以及/或深度和模板缓冲。因为多重采样缓冲有一点特别，我们不能直接将它们的缓冲图像用于其他运算，比如在着色器中对它们进行采样。</p>
<p>一个多重采样的图像包含比普通图像更多的信息，我们所要做的是缩小或者还原(Resolve)图像。多重采样帧缓冲的还原通常是通过glBlitFramebuffer来完成，它能够将一个帧缓冲中的某个区域复制到另一个帧缓冲中，并且将多重采样缓冲还原。</p>
<p>glBlitFramebuffer会将一个用4个屏幕空间坐标所定义的源区域复制到一个同样用4个屏幕空间坐标所定义的目标区域中。你可能记得在帧缓冲教程中，当我们绑定到GL_FRAMEBUFFER时，我们是同时绑定了读取和绘制的帧缓冲目标。我们也可以将帧缓冲分开绑定至GL_READ_FRAMEBUFFER与GL_DRAW_FRAMEBUFFER。glBlitFramebuffer函数会根据这两个目标，决定哪个是源帧缓冲，哪个是目标帧缓冲。接下来，我们可以将图像位块传送(Blit)到默认的帧缓冲中，将多重采样的帧缓冲传送到屏幕上。(屏幕的FBO不是多重采样的，这里就从4倍屏幕空间的多重采样图片映射到当前屏幕大小的FBO了)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_READ_FRAMEBUFFER</span><span class="p">,</span> <span class="n">multisampledFBO</span><span class="p">);</span>
<span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_DRAW_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">glBlitFramebuffer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">,</span> <span class="n">GL_NEAREST</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>举例,部分代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c">  <span class="c1">// configure MSAA framebuffer
</span><span class="c1"></span>    <span class="c1">// --------------------------
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">framebuffer</span><span class="p">;</span>
    <span class="n">glGenFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">framebuffer</span><span class="p">);</span>
    <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">framebuffer</span><span class="p">);</span>
    <span class="c1">// create a multisampled color attachment texture
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">textureColorBufferMultiSampled</span><span class="p">;</span>
    <span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">textureColorBufferMultiSampled</span><span class="p">);</span>
    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D_MULTISAMPLE</span><span class="p">,</span> <span class="n">textureColorBufferMultiSampled</span><span class="p">);</span>
    <span class="n">glTexImage2DMultisample</span><span class="p">(</span><span class="n">GL_TEXTURE_2D_MULTISAMPLE</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">SCR_WIDTH</span><span class="p">,</span> <span class="n">SCR_HEIGHT</span><span class="p">,</span> <span class="n">GL_TRUE</span><span class="p">);</span>
    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D_MULTISAMPLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D_MULTISAMPLE</span><span class="p">,</span> <span class="n">textureColorBufferMultiSampled</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">// create a (also multisampled) renderbuffer object for depth and stencil attachments
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rbo</span><span class="p">;</span>
    <span class="n">glGenRenderbuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rbo</span><span class="p">);</span>
    <span class="n">glBindRenderbuffer</span><span class="p">(</span><span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">rbo</span><span class="p">);</span>
    <span class="n">glRenderbufferStorageMultisample</span><span class="p">(</span><span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">GL_DEPTH24_STENCIL8</span><span class="p">,</span> <span class="n">SCR_WIDTH</span><span class="p">,</span> <span class="n">SCR_HEIGHT</span><span class="p">);</span>
    <span class="n">glBindRenderbuffer</span><span class="p">(</span><span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">glFramebufferRenderbuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_DEPTH_STENCIL_ATTACHMENT</span><span class="p">,</span> <span class="n">GL_RENDERBUFFER</span><span class="p">,</span> <span class="n">rbo</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">glCheckFramebufferStatus</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">)</span> <span class="o">!=</span> <span class="n">GL_FRAMEBUFFER_COMPLETE</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ERROR::FRAMEBUFFER:: Framebuffer is not complete!&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// configure second post-processing framebuffer
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">intermediateFBO</span><span class="p">;</span>
    <span class="n">glGenFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intermediateFBO</span><span class="p">);</span>
    <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">intermediateFBO</span><span class="p">);</span>
    <span class="c1">// create a color attachment texture
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">screenTexture</span><span class="p">;</span>
    <span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">screenTexture</span><span class="p">);</span>
    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">screenTexture</span><span class="p">);</span>
    <span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">SCR_WIDTH</span><span class="p">,</span> <span class="n">SCR_HEIGHT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
    <span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">screenTexture</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="c1">// we only need a color buffer
</span><span class="c1"></span>
    <span class="k">if</span> <span class="p">(</span><span class="n">glCheckFramebufferStatus</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">)</span> <span class="o">!=</span> <span class="n">GL_FRAMEBUFFER_COMPLETE</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ERROR::FRAMEBUFFER:: Intermediate framebuffer is not complete!&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// shader configuration
</span><span class="c1"></span>    <span class="c1">// --------------------
</span><span class="c1"></span>    <span class="n">shader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
    <span class="n">screenShader</span><span class="p">.</span><span class="n">setInt</span><span class="p">(</span><span class="s">&#34;screenTexture&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// render loop
</span><span class="c1"></span>    <span class="c1">// -----------
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">// per-frame time logic
</span><span class="c1"></span>        <span class="c1">// --------------------
</span><span class="c1"></span>        <span class="kt">float</span> <span class="n">currentFrame</span> <span class="o">=</span> <span class="n">glfwGetTime</span><span class="p">();</span>
        <span class="n">deltaTime</span> <span class="o">=</span> <span class="n">currentFrame</span> <span class="o">-</span> <span class="n">lastFrame</span><span class="p">;</span>
        <span class="n">lastFrame</span> <span class="o">=</span> <span class="n">currentFrame</span><span class="p">;</span>

        <span class="c1">// input
</span><span class="c1"></span>        <span class="c1">// -----
</span><span class="c1"></span>        <span class="n">processInput</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>

        <span class="c1">// render
</span><span class="c1"></span>        <span class="c1">// ------
</span><span class="c1"></span>        <span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.1f</span><span class="p">,</span> <span class="mf">0.1f</span><span class="p">,</span> <span class="mf">0.1f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
        <span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>

        <span class="c1">// 1. draw scene as normal in multisampled buffers
</span><span class="c1"></span>        <span class="c1">//渲染到MSAA的FBO上
</span><span class="c1"></span>        <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">framebuffer</span><span class="p">);</span>
        <span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.1f</span><span class="p">,</span> <span class="mf">0.1f</span><span class="p">,</span> <span class="mf">0.1f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
        <span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>
        <span class="n">glEnable</span><span class="p">(</span><span class="n">GL_DEPTH_TEST</span><span class="p">);</span>

        <span class="c1">// set transformation matrices		
</span><span class="c1"></span>        <span class="n">shader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
        <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">projection</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">perspective</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="n">camera</span><span class="p">.</span><span class="n">Zoom</span><span class="p">),</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">SCR_WIDTH</span> <span class="o">/</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">SCR_HEIGHT</span><span class="p">,</span> <span class="mf">0.1f</span><span class="p">,</span> <span class="mf">1000.0f</span><span class="p">);</span>
        <span class="n">shader</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;projection&#34;</span><span class="p">,</span> <span class="n">projection</span><span class="p">);</span>
        <span class="n">shader</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;view&#34;</span><span class="p">,</span> <span class="n">camera</span><span class="p">.</span><span class="n">GetViewMatrix</span><span class="p">());</span>
        <span class="n">shader</span><span class="p">.</span><span class="n">setMat4</span><span class="p">(</span><span class="s">&#34;model&#34;</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">));</span>

        <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">cubeVAO</span><span class="p">);</span>
        <span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">36</span><span class="p">);</span>

        <span class="c1">// 2. now blit multisampled buffer(s) to normal colorbuffer of intermediate FBO. Image is stored in screenTexture
</span><span class="c1"></span>        <span class="c1">// Blit 从多重采样framebuffer（4倍屏幕大小纹理）到intermediateFBO（屏幕大小纹理）即从 textureColorBufferMultiSampled 立刻映射到 screenTexture 
</span><span class="c1"></span>
        <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_READ_FRAMEBUFFER</span><span class="p">,</span> <span class="n">framebuffer</span><span class="p">);</span> <span class="c1">// 读取 framebuffer
</span><span class="c1"></span>        <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_DRAW_FRAMEBUFFER</span><span class="p">,</span> <span class="n">intermediateFBO</span><span class="p">);</span> <span class="c1">// 写入 intermediateFBO
</span><span class="c1"></span>        <span class="c1">//从 framebuffer 写入到 intermediateFBO
</span><span class="c1"></span>        <span class="n">glBlitFramebuffer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCR_WIDTH</span><span class="p">,</span> <span class="n">SCR_HEIGHT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCR_WIDTH</span><span class="p">,</span> <span class="n">SCR_HEIGHT</span><span class="p">,</span> <span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">,</span> <span class="n">GL_NEAREST</span><span class="p">);</span> 

        <span class="c1">// 3. now render quad with scene&#39;s visuals as its texture image
</span><span class="c1"></span>        <span class="c1">//激活当前正在渲染屏幕的FBO，0代表正在渲染屏幕的FBO
</span><span class="c1"></span>        <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">glClearColor</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
        <span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span>
        <span class="n">glDisable</span><span class="p">(</span><span class="n">GL_DEPTH_TEST</span><span class="p">);</span>

        <span class="c1">// draw Screen quad
</span><span class="c1"></span>        <span class="n">screenShader</span><span class="p">.</span><span class="n">use</span><span class="p">();</span>
        <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">quadVAO</span><span class="p">);</span>
        <span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE0</span><span class="p">);</span>
        <span class="c1">// 将 MASS处理后得 screenTexture 纹理绑定，
</span><span class="c1"></span>        <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">screenTexture</span><span class="p">);</span> <span class="c1">// use the now resolved color attachment as the quad&#39;s texture
</span><span class="c1"></span>        <span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span> <span class="c1">//绘制
</span><span class="c1"></span>
        <span class="c1">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)
</span><span class="c1"></span>        <span class="c1">// -------------------------------------------------------------------------------
</span><span class="c1"></span>        <span class="n">glfwSwapBuffers</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
        <span class="n">glfwPollEvents</span><span class="p">();</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="阴影shadow">阴影（Shadow）</h2>
<h3 id="阴影映射direct-shadows">阴影映射(Direct Shadows)</h3>
<blockquote>
<p>方向光源：使用正交相机获取深度图，正交投影矩阵变换</p>
</blockquote>
<h3 id="改进阴影贴图">改进阴影贴图</h3>
<h4 id="阴影失真">阴影失真</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/eQm5xkEjuavlc3M.png"
        data-srcset="../../imgs/eQm5xkEjuavlc3M.png, ../../imgs/eQm5xkEjuavlc3M.png 1.5x, ../../imgs/eQm5xkEjuavlc3M.png 2x"
        data-sizes="auto"
        alt="../../imgs/eQm5xkEjuavlc3M.png"
        title="../../imgs/eQm5xkEjuavlc3M.png" /><br>
我们可以看到地板四边形渲染出很大一块交替黑线。这种阴影贴图的不真实感叫做<strong>阴影失真(Shadow Acne)</strong>。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/GVivqehkXWbFp3t.png"
        data-srcset="../../imgs/GVivqehkXWbFp3t.png, ../../imgs/GVivqehkXWbFp3t.png 1.5x, ../../imgs/GVivqehkXWbFp3t.png 2x"
        data-sizes="auto"
        alt="../../imgs/GVivqehkXWbFp3t.png"
        title="../../imgs/GVivqehkXWbFp3t.png" /><br>
因为阴影贴图受限于分辨率，在距离光源比较远的情况下，多个片段可能从深度贴图的同一个值中去采样。图片每个斜坡代表深度贴图一个单独的纹理像素。你可以看到，多个片段从同一个深度值进行采样。</p>
<p>虽然很多时候没问题，但是当光源以一个角度朝向表面的时候就会出问题，这种情况下深度贴图也是从一个角度下进行渲染的。多个片段就会从同一个斜坡的深度纹理像素中采样，有些在地板上面，有些在地板下面；这样我们所得到的阴影就有了差异。因为这个，有些片段被认为是在阴影之中，有些不在，由此产生了图片中的条纹样式。</p>
<p>我们可以用一个叫做<strong>阴影偏移</strong>（shadow bias）的技巧来解决这个问题，我们简单的对表面的深度（或深度贴图）应用一个偏移量，这样片段就不会被错误地认为在表面之下了。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/hJutrW13lnjQxUF.png"
        data-srcset="../../imgs/hJutrW13lnjQxUF.png, ../../imgs/hJutrW13lnjQxUF.png 1.5x, ../../imgs/hJutrW13lnjQxUF.png 2x"
        data-sizes="auto"
        alt="../../imgs/hJutrW13lnjQxUF.png"
        title="../../imgs/hJutrW13lnjQxUF.png" /><br>
使用了偏移量后，所有采样点都获得了比表面深度更小的深度值，这样整个表面就正确地被照亮，没有任何阴影。我们可以这样实现这个偏移：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">float</span> <span class="n">bias</span> <span class="o">=</span> <span class="mf">0.005</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">currentDepth</span> <span class="o">-</span> <span class="n">bias</span> <span class="o">&gt;</span> <span class="n">closestDepth</span>  <span class="o">?</span> <span class="mf">1.0</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>一个0.005的偏移就能帮到很大的忙，但是有些表面坡度很大，仍然会产生阴影失真。有一个更加可靠的办法能够根据表面朝向光线的角度更改偏移量：使用点乘：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">float</span> <span class="n">bias</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mf">0.05</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">lightDir</span><span class="p">)),</span> <span class="mf">0.005</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>这里我们有一个偏移量的最大值0.05，和一个最小值0.005，它们是基于表面法线和光照方向的。这样像地板这样的表面几乎与光源垂直，得到的偏移就很小.</p>
<h4 id="悬浮">悬浮</h4>
<p>使用阴影偏移的一个缺点是你对物体的实际深度应用了平移。偏移有可能足够大，以至于可以看出阴影相对实际物体位置的偏移，你可以从下图看到这个现象（这是一个夸张的偏移值）：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/GFzap4TQjHvtfql.png"
        data-srcset="../../imgs/GFzap4TQjHvtfql.png, ../../imgs/GFzap4TQjHvtfql.png 1.5x, ../../imgs/GFzap4TQjHvtfql.png 2x"
        data-sizes="auto"
        alt="../../imgs/GFzap4TQjHvtfql.png"
        title="../../imgs/GFzap4TQjHvtfql.png" /></p>
<p>这个阴影失真叫做<strong>悬浮</strong>(Peter Panning)，因为物体看起来轻轻悬浮在表面之上。我们可以使用一个叫技巧解决大部分的Peter panning问题：当渲染深度贴图时候使用正面剔除（front face culling）你也许记得在面剔除教程中OpenGL默认是背面剔除。我们要告诉OpenGL我们要剔除正面。</p>
<p>因为我们只需要深度贴图的深度值，对于实体物体无论我们用它们的正面还是背面都没问题。使用背面深度不会有错误，因为阴影在物体内部有错误我们也看不见。<br>
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/GdE8hCgUqoSOtJ5.png"
        data-srcset="../../imgs/GdE8hCgUqoSOtJ5.png, ../../imgs/GdE8hCgUqoSOtJ5.png 1.5x, ../../imgs/GdE8hCgUqoSOtJ5.png 2x"
        data-sizes="auto"
        alt="../../imgs/GdE8hCgUqoSOtJ5.png"
        title="../../imgs/GdE8hCgUqoSOtJ5.png" /></p>
<h4 id="采样过多">采样过多</h4>
<p>无论你喜不喜欢还有一个视觉差异，就是光的视锥不可见的区域一律被认为是处于阴影中，不管它真的处于阴影之中。出现这个状况是因为超出光的视锥的投影坐标比1.0大，这样采样的深度纹理就会超出他默认的0到1的范围。根据纹理环绕方式，我们将会得到不正确的深度结果，它不是基于真实的来自光源的深度值。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/A2Blkc17q6oIbif.png"
        data-srcset="../../imgs/A2Blkc17q6oIbif.png, ../../imgs/A2Blkc17q6oIbif.png 1.5x, ../../imgs/A2Blkc17q6oIbif.png 2x"
        data-sizes="auto"
        alt="../../imgs/A2Blkc17q6oIbif.png"
        title="../../imgs/A2Blkc17q6oIbif.png" /><br>
你可以在图中看到，光照有一个区域，超出该区域就成为了阴影；这个区域实际上代表着深度贴图的大小，这个贴图投影到了地板上。发生这种情况的原因是我们之前将深度贴图的环绕方式设置成了GL_REPEAT。</p>
<p>我们宁可让所有超出深度贴图的坐标的深度范围是1.0，这样超出的坐标将永远不在阴影之中。我们可以储存一个边框颜色，然后把深度贴图的纹理环绕选项设置为GL_CLAMP_TO_BORDER：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_BORDER</span><span class="p">);</span>
<span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_BORDER</span><span class="p">);</span>
<span class="n">GLfloat</span> <span class="n">borderColor</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">};</span>
<span class="n">glTexParameterfv</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_BORDER_COLOR</span><span class="p">,</span> <span class="n">borderColor</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>现在如果我们采样深度贴图0到1坐标范围以外的区域，纹理函数总会返回一个1.0的深度值，阴影值为0.0。结果看起来会更真实：<br>
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/4eV5EhauKncSZld.png"
        data-srcset="../../imgs/4eV5EhauKncSZld.png, ../../imgs/4eV5EhauKncSZld.png 1.5x, ../../imgs/4eV5EhauKncSZld.png 2x"
        data-sizes="auto"
        alt="../../imgs/4eV5EhauKncSZld.png"
        title="../../imgs/4eV5EhauKncSZld.png" /></p>
<p>仍有一部分是黑暗区域。那里的坐标超出了光的正交视锥的远平面。你可以看到这片黑色区域总是出现在光源视锥的极远处。</p>
<p>当一个点比光的远平面还要远时，它的投影坐标的z坐标大于1.0。这种情况下，GL_CLAMP_TO_BORDER环绕方式不起作用，因为我们把坐标的z元素和深度贴图的值进行了对比；它总是为大于1.0的z返回true。</p>
<p>解决这个问题也很简单，只要投影向量的z坐标大于1.0，我们就把shadow的值强制设为0.0：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">float</span> <span class="nf">ShadowCalculation</span><span class="p">(</span><span class="n">vec4</span> <span class="n">fragPosLightSpace</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">[...]</span>
    <span class="k">if</span><span class="p">(</span><span class="n">projCoords</span><span class="p">.</span><span class="n">z</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">shadow</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">shadow</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>检查远平面，并将深度贴图限制为一个手工指定的边界颜色，就能解决深度贴图采样超出的问题，我们最终会得到下面我们所追求的效果：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/DUAfavFJXBsk4V9.png"
        data-srcset="../../imgs/DUAfavFJXBsk4V9.png, ../../imgs/DUAfavFJXBsk4V9.png 1.5x, ../../imgs/DUAfavFJXBsk4V9.png 2x"
        data-sizes="auto"
        alt="../../imgs/DUAfavFJXBsk4V9.png"
        title="../../imgs/DUAfavFJXBsk4V9.png" /></p>
<h4 id="pcf">PCF</h4>
<blockquote>
<p>简言之：使用该像素点阴影的一个<code>3*3的卷积核</code>（权重都相同），计算出一个平均值作为该像素点的阴影值</p>
</blockquote>
<p>阴影现在已经附着到场景中了，不过这仍不是我们想要的。如果你放大看阴影，阴影映射对分辨率的依赖很快变得很明显。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/mz2vxdFfakHjCcg.png"
        data-srcset="../../imgs/mz2vxdFfakHjCcg.png, ../../imgs/mz2vxdFfakHjCcg.png 1.5x, ../../imgs/mz2vxdFfakHjCcg.png 2x"
        data-sizes="auto"
        alt="../../imgs/mz2vxdFfakHjCcg.png"
        title="../../imgs/mz2vxdFfakHjCcg.png" /><br>
因为深度贴图有一个固定的分辨率，多个片段对应于一个纹理像素。结果就是多个片段会从深度贴图的同一个深度值进行采样，这几个片段便得到的是同一个阴影，这就会产生锯齿边。</p>
<p>你可以通过增加深度贴图的分辨率的方式来降低锯齿块，也可以尝试尽可能的让光的视锥接近场景。</p>
<p>另一个（并不完整的）解决方案叫做<strong>PCF</strong>（percentage-closer filtering），这是一种多个不同过滤方式的组合，它产生柔和阴影，使它们出现更少的锯齿块和硬边。核心思想是从深度贴图中多次采样，每一次采样的纹理坐标都稍有不同。每个独立的样本可能在也可能不再阴影中。所有的次生结果接着结合在一起，进行平均化，我们就得到了柔和阴影。</p>
<p>一个简单的PCF的实现是简单的从纹理像素四周对深度贴图采样，然后把结果平均起来：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="n">vec2</span> <span class="n">texelSize</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">textureSize</span><span class="p">(</span><span class="n">shadowMap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">y</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">float</span> <span class="n">pcfDepth</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">shadowMap</span><span class="p">,</span> <span class="n">projCoords</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">vec2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">texelSize</span><span class="p">).</span><span class="n">r</span><span class="p">;</span> 
        <span class="n">shadow</span> <span class="o">+=</span> <span class="n">currentDepth</span> <span class="o">-</span> <span class="n">bias</span> <span class="o">&gt;</span> <span class="n">pcfDepth</span> <span class="o">?</span> <span class="mf">1.0</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">;</span>        
    <span class="p">}</span>    
<span class="p">}</span>
<span class="n">shadow</span> <span class="o">/=</span> <span class="mf">9.0</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>这个textureSize返回一个给定采样器纹理的0级mipmap的vec2类型的宽和高。用1除以它返回一个单独纹理像素的大小，我们用以对纹理坐标进行偏移，确保每个新样本，来自不同的深度值。这里我们采样得到9个值，它们在投影坐标的x和y值的周围，为阴影阻挡进行测试，并最终通过样本的总数目将结果平均化。</p>
<p>使用更多的样本，更改texelSize变量，你就可以增加阴影的柔和程度。下面你可以看到应用了PCF的阴影：<br>
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/fxpMGURaSFw9NAQ.png"
        data-srcset="../../imgs/fxpMGURaSFw9NAQ.png, ../../imgs/fxpMGURaSFw9NAQ.png 1.5x, ../../imgs/fxpMGURaSFw9NAQ.png 2x"
        data-sizes="auto"
        alt="../../imgs/fxpMGURaSFw9NAQ.png"
        title="../../imgs/fxpMGURaSFw9NAQ.png" /></p>
<blockquote>
<p>透视投影矩阵，将深度缓冲视觉化经常会得到一个几乎全白的结果。发生这个是因为透视投影下，深度变成了非线性的深度值，它的大多数可辨范围都位于近平面附近。为了可以像使用正交投影一样合适地观察深度值，你必须先将非线性深度值转变为线性的，如我们在深度测试教程中已经讨论过的那样。</p>
</blockquote>
<h3 id="点光源阴影point-shadows">点光源阴影(Point Shadows)</h3>
<blockquote>
<p>原文：<a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/03%20Shadows/02%20Point%20Shadows/" target="_blank" rel="noopener noreffer">点光源阴影</a>
点光源：使用透视相机获取深度图，透视投影矩阵变换 ，阴影投射到立方体贴图
点光阴影，过去的名字是万向阴影贴图（omnidirectional shadow maps）技术。
定向阴影映射(方向光阴影)和万向阴影映射的主要不同在于深度贴图的使用上。</p>
</blockquote>
<p>对于深度贴图，我们需要从一个点光源的所有渲染场景，普通2D深度贴图不能工作；如果我们使用立方体贴图会怎样？因为立方体贴图可以储存6个面的环境数据，它可以将整个场景渲染到立方体贴图的每个面上，把它们当作点光源四周的深度值来采样。<br>
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/dAKOzC1o5TXw6vQ.png"
        data-srcset="../../imgs/dAKOzC1o5TXw6vQ.png, ../../imgs/dAKOzC1o5TXw6vQ.png 1.5x, ../../imgs/dAKOzC1o5TXw6vQ.png 2x"
        data-sizes="auto"
        alt="../../imgs/dAKOzC1o5TXw6vQ.png"
        title="../../imgs/dAKOzC1o5TXw6vQ.png" /></p>
<p>生成后的深度立方体贴图被传递到光照像素着色器，它会用一个方向向量来采样立方体贴图，从而得到当前的fragment的深度（从光的透视图）。大部分复杂的事情已经在阴影映射教程中讨论过了。算法只是在深度立方体贴图生成上稍微复杂一点。</p>
<h4 id="生成深度立方体贴图">生成深度立方体贴图</h4>
<p>为创建一个光周围的深度值的立方体贴图，我们必须渲染场景6次：每次一个面。显然渲染场景6次需要6个不同的视图矩阵，每次把一个不同的立方体贴图面附加到帧缓冲对象上。这看起来是这样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">for(int i = 0; i &lt; 6; i++)
{
    GLuint face = GL_TEXTURE_CUBE_MAP_POSITIVE_X + i;
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, face, depthCubemap, 0);
    BindViewMatrix(lightViewMatrices[i]);
    RenderScene();  
}
</code></pre></td></tr></table>
</div>
</div><p>这会很耗费性能因为一个深度贴图下需要进行很多渲染调用。这个教程中我们将转而使用另外的一个小技巧来做这件事，几何着色器允许我们使用一次渲染过程来建立深度立方体贴图。</p>
<p>首先，我们需要创建一个立方体贴图：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">GLuint</span> <span class="n">depthCubemap</span><span class="p">;</span>
<span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">depthCubemap</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>然后生成立方体贴图的每个面，将它们作为2D深度值纹理图像：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">const</span> <span class="n">GLuint</span> <span class="n">SHADOW_WIDTH</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">SHADOW_HEIGHT</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
<span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">depthCubemap</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="n">GLuint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP_POSITIVE_X</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_DEPTH_COMPONENT</span><span class="p">,</span> 
                     <span class="n">SHADOW_WIDTH</span><span class="p">,</span> <span class="n">SHADOW_HEIGHT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_DEPTH_COMPONENT</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>正常情况下，我们把立方体贴图纹理的一个面附加到帧缓冲对象上，渲染场景6次，每次将帧缓冲的深度缓冲目标改成不同立方体贴图面。由于我们将使用一个几何着色器，它允许我们把所有面在一个过程渲染，我们可以使用glFramebufferTexture直接把立方体贴图附加成帧缓冲的深度附件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">depthMapFBO</span><span class="p">);</span>
<span class="n">glFramebufferTexture</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_DEPTH_ATTACHMENT</span><span class="p">,</span> <span class="n">depthCubemap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">glDrawBuffer</span><span class="p">(</span><span class="n">GL_NONE</span><span class="p">);</span>
<span class="n">glReadBuffer</span><span class="p">(</span><span class="n">GL_NONE</span><span class="p">);</span>
<span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>还要记得调用glDrawBuffer和glReadBuffer：当生成一个深度立方体贴图时我们只关心深度值，所以我们必须显式告诉OpenGL这个帧缓冲对象不会渲染到一个颜色缓冲里。</p>
<p>万向阴影贴图有两个渲染阶段：首先我们生成深度贴图，然后我们正常使用深度贴图渲染，在场景中创建阴影。帧缓冲对象和立方体贴图的处理看起是这样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 1. first render to depth cubemap
</span><span class="c1"></span><span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SHADOW_WIDTH</span><span class="p">,</span> <span class="n">SHADOW_HEIGHT</span><span class="p">);</span>
<span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">depthMapFBO</span><span class="p">);</span>
<span class="n">glClear</span><span class="p">(</span><span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>
<span class="n">ConfigureShaderAndMatrices</span><span class="p">();</span>
<span class="n">RenderScene</span><span class="p">();</span>
<span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">// 2. then render scene as normal with shadow mapping (using depth cubemap)
</span><span class="c1"></span><span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCR_WIDTH</span><span class="p">,</span> <span class="n">SCR_HEIGHT</span><span class="p">);</span>
<span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>
<span class="n">ConfigureShaderAndMatrices</span><span class="p">();</span>
<span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_CUBE_MAP</span><span class="p">,</span> <span class="n">depthCubemap</span><span class="p">);</span>
<span class="n">RenderScene</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div><p>这个过程和默认的阴影映射一样，尽管这次我们渲染和使用的是一个立方体贴图深度纹理，而不是2D深度纹理。在我们实际开始从光的视角的所有方向渲染场景之前，我们先得计算出合适的变换矩阵。</p>
<h4 id="光空间的变换">光空间的变换</h4>
<p>设置了帧缓冲和立方体贴图，我们需要一些方法来讲场景的所有几何体变换到6个光的方向中相应的光空间。与阴影映射教程类似，我们将需要一个光空间的变换矩阵T，但是这次是每个面都有一个。</p>
<p>每个光空间的变换矩阵包含了投影和视图矩阵。对于投影矩阵来说，我们将使用一个透视投影矩阵；光源代表一个空间中的点，所以透视投影矩阵更有意义。每个光空间变换矩阵使用同样的投影矩阵：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">GLfloat</span> <span class="n">aspect</span> <span class="o">=</span> <span class="p">(</span><span class="n">GLfloat</span><span class="p">)</span><span class="n">SHADOW_WIDTH</span><span class="o">/</span><span class="p">(</span><span class="n">GLfloat</span><span class="p">)</span><span class="n">SHADOW_HEIGHT</span><span class="p">;</span>
<span class="n">GLfloat</span> <span class="n">near</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
<span class="n">GLfloat</span> <span class="n">far</span> <span class="o">=</span> <span class="mf">25.0f</span><span class="p">;</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span> <span class="n">shadowProj</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">perspective</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">90.0f</span><span class="p">),</span> <span class="n">aspect</span><span class="p">,</span> <span class="n">near</span><span class="p">,</span> <span class="n">far</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>非常重要的一点是，这里glm::perspective的视野参数，设置为90度。90度我们才能保证视野足够大到可以合适地填满立方体贴图的一个面，立方体贴图的所有面都能与其他面在边缘对齐。</p>
<p>因为投影矩阵在每个方向上并不会改变，我们可以在6个变换矩阵中重复使用。我们要为每个方向提供一个不同的视图矩阵。用glm::lookAt创建6个观察方向，每个都按顺序注视着立方体贴图的的一个方向：右、左、上、下、近、远：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="o">&gt;</span> <span class="n">shadowTransforms</span><span class="p">;</span>
<span class="n">shadowTransforms</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">shadowProj</span> <span class="o">*</span> 
                 <span class="n">glm</span><span class="o">::</span><span class="n">lookAt</span><span class="p">(</span><span class="n">lightPos</span><span class="p">,</span> <span class="n">lightPos</span> <span class="o">+</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">));</span>
<span class="n">shadowTransforms</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">shadowProj</span> <span class="o">*</span> 
                 <span class="n">glm</span><span class="o">::</span><span class="n">lookAt</span><span class="p">(</span><span class="n">lightPos</span><span class="p">,</span> <span class="n">lightPos</span> <span class="o">+</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">));</span>
<span class="n">shadowTransforms</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">shadowProj</span> <span class="o">*</span> 
                 <span class="n">glm</span><span class="o">::</span><span class="n">lookAt</span><span class="p">(</span><span class="n">lightPos</span><span class="p">,</span> <span class="n">lightPos</span> <span class="o">+</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">));</span>
<span class="n">shadowTransforms</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">shadowProj</span> <span class="o">*</span> 
                 <span class="n">glm</span><span class="o">::</span><span class="n">lookAt</span><span class="p">(</span><span class="n">lightPos</span><span class="p">,</span> <span class="n">lightPos</span> <span class="o">+</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">));</span>
<span class="n">shadowTransforms</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">shadowProj</span> <span class="o">*</span> 
                 <span class="n">glm</span><span class="o">::</span><span class="n">lookAt</span><span class="p">(</span><span class="n">lightPos</span><span class="p">,</span> <span class="n">lightPos</span> <span class="o">+</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">));</span>
<span class="n">shadowTransforms</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">shadowProj</span> <span class="o">*</span> 
                 <span class="n">glm</span><span class="o">::</span><span class="n">lookAt</span><span class="p">(</span><span class="n">lightPos</span><span class="p">,</span> <span class="n">lightPos</span> <span class="o">+</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">));</span>
</code></pre></td></tr></table>
</div>
</div><p>这里我们创建了6个视图矩阵，把它们乘以投影矩阵，来得到6个不同的光空间变换矩阵。glm::lookAt的target参数是它注视的立方体贴图的面的一个方向。</p>
<p>这些变换矩阵发送到着色器渲染到立方体贴图里。</p>
<h4 id="深度着色器">深度着色器</h4>
<p>为了把值渲染到深度立方体贴图，我们将需要3个着色器：顶点和像素着色器，以及一个它们之间的<strong>几何着色器</strong>。</p>
<p>几何着色器是负责将所有世界空间的顶点变换到6个不同的光空间的着色器。因此<strong>顶点着色器简单地将顶点变换到世界空间</strong>，然后直接发送到几何着色器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#version 330 core
</span><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">position</span><span class="p">;</span>

<span class="n">uniform</span> <span class="n">mat4</span> <span class="n">model</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>紧接着几何着色器以3个三角形的顶点作为输入，它还有一个光空间变换矩阵的uniform数组。几何着色器接下来会负责将顶点变换到光空间；这里它开始变得有趣了。</p>
<p>几何着色器有一个内建变量叫做gl_Layer，它指定发散出基本图形送到立方体贴图的哪个面。当不管它时，几何着色器就会像往常一样把它的基本图形发送到输送管道的下一阶段，但当我们更新这个变量就能控制每个基本图形将渲染到立方体贴图的哪一个面。当然这只有当我们有了一个附加到激活的帧缓冲的立方体贴图纹理才有效：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#version 330 core
</span><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">triangles</span><span class="p">)</span> <span class="n">in</span><span class="p">;</span>
<span class="n">layout</span> <span class="p">(</span><span class="n">triangle_strip</span><span class="p">,</span> <span class="n">max_vertices</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span> <span class="n">out</span><span class="p">;</span>

<span class="n">uniform</span> <span class="n">mat4</span> <span class="n">shadowMatrices</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>

<span class="n">out</span> <span class="n">vec4</span> <span class="n">FragPos</span><span class="p">;</span> <span class="c1">// FragPos from GS (output per emitvertex)
</span><span class="c1"></span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">face</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">face</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">face</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">gl_Layer</span> <span class="o">=</span> <span class="n">face</span><span class="p">;</span> <span class="c1">// built-in variable that specifies to which face we render.
</span><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="c1">// for each triangle&#39;s vertices
</span><span class="c1"></span>        <span class="p">{</span>
            <span class="n">FragPos</span> <span class="o">=</span> <span class="n">gl_in</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">gl_Position</span><span class="p">;</span>
            <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">shadowMatrices</span><span class="p">[</span><span class="n">face</span><span class="p">]</span> <span class="o">*</span> <span class="n">FragPos</span><span class="p">;</span>
            <span class="n">EmitVertex</span><span class="p">();</span>
        <span class="p">}</span>    
        <span class="n">EndPrimitive</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>几何着色器相对简单。我们输入一个三角形，输出总共6个三角形（6*3顶点，所以总共18个顶点）。在main函数中，我们遍历立方体贴图的6个面，我们每个面指定为一个输出面，把这个面的interger（整数）存到gl_Layer。然后，我们通过把面的光空间变换矩阵乘以FragPos，将每个世界空间顶点变换到相关的光空间，生成每个三角形。注意，我们还要将最后的FragPos变量发送给像素着色器，我们需要计算一个深度值。</p>
<p>上个教程，我们使用的是一个空的像素着色器，让OpenGL配置深度贴图的深度值。这次我们将计算自己的深度，这个深度就是每个fragment位置和光源位置之间的线性距离。计算自己的深度值使得之后的阴影计算更加直观。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#version 330 core
</span><span class="cp"></span><span class="n">in</span> <span class="n">vec4</span> <span class="n">FragPos</span><span class="p">;</span>

<span class="n">uniform</span> <span class="n">vec3</span> <span class="n">lightPos</span><span class="p">;</span>
<span class="n">uniform</span> <span class="kt">float</span> <span class="n">far_plane</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// get distance between fragment and light source
</span><span class="c1"></span>    <span class="kt">float</span> <span class="n">lightDistance</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">FragPos</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">lightPos</span><span class="p">);</span>

    <span class="c1">// map to [0;1] range by dividing by far_plane
</span><span class="c1"></span>    <span class="n">lightDistance</span> <span class="o">=</span> <span class="n">lightDistance</span> <span class="o">/</span> <span class="n">far_plane</span><span class="p">;</span>

    <span class="c1">// write this as modified depth
</span><span class="c1"></span>    <span class="n">gl_FragDepth</span> <span class="o">=</span> <span class="n">lightDistance</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>像素着色器将来自几何着色器的FragPos、光的位置向量和视锥的远平面值作为输入。这里我们把fragment和光源之间的距离，映射到0到1的范围，把它写入为fragment的深度值。</p>
<p>使用这些着色器渲染场景，立方体贴图附加的帧缓冲对象激活以后，你会得到一个完全填充的深度立方体贴图，以便于进行第二阶段的阴影计算。</p>
<h4 id="万向阴影贴图">万向阴影贴图</h4>
<p>所有事情都做好了，是时候来渲染万向阴影(Omnidirectional Shadow)了。这个过程和定向阴影映射教程相似，尽管这次我们绑定的深度贴图是一个立方体贴图，而不是2D纹理，并且将光的投影的远平面发送给了着色器。</p>
<p>顶点着色器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#version 330 core
</span><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">position</span><span class="p">;</span>
<span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">normal</span><span class="p">;</span>
<span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">texCoords</span><span class="p">;</span>

<span class="n">out</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>

<span class="n">out</span> <span class="n">VS_OUT</span> <span class="p">{</span>
    <span class="n">vec3</span> <span class="n">FragPos</span><span class="p">;</span>
    <span class="n">vec3</span> <span class="n">Normal</span><span class="p">;</span>
    <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
<span class="p">}</span> <span class="n">vs_out</span><span class="p">;</span>

<span class="n">uniform</span> <span class="n">mat4</span> <span class="n">projection</span><span class="p">;</span>
<span class="n">uniform</span> <span class="n">mat4</span> <span class="n">view</span><span class="p">;</span>
<span class="n">uniform</span> <span class="n">mat4</span> <span class="n">model</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="n">view</span> <span class="o">*</span> <span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
    <span class="n">vs_out</span><span class="p">.</span><span class="n">FragPos</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="n">model</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">));</span>
    <span class="n">vs_out</span><span class="p">.</span><span class="n">Normal</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">inverse</span><span class="p">(</span><span class="n">mat3</span><span class="p">(</span><span class="n">model</span><span class="p">)))</span> <span class="o">*</span> <span class="n">normal</span><span class="p">;</span>
    <span class="n">vs_out</span><span class="p">.</span><span class="n">TexCoords</span> <span class="o">=</span> <span class="n">texCoords</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>片段着色器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#version 330 core
</span><span class="cp"></span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>

<span class="n">in</span> <span class="n">VS_OUT</span> <span class="p">{</span>
    <span class="n">vec3</span> <span class="n">FragPos</span><span class="p">;</span>
    <span class="n">vec3</span> <span class="n">Normal</span><span class="p">;</span>
    <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>
<span class="p">}</span> <span class="n">fs_in</span><span class="p">;</span>

<span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">diffuseTexture</span><span class="p">;</span>
<span class="n">uniform</span> <span class="n">samplerCube</span> <span class="n">depthMap</span><span class="p">;</span>

<span class="n">uniform</span> <span class="n">vec3</span> <span class="n">lightPos</span><span class="p">;</span>
<span class="n">uniform</span> <span class="n">vec3</span> <span class="n">viewPos</span><span class="p">;</span>

<span class="n">uniform</span> <span class="kt">float</span> <span class="n">far_plane</span><span class="p">;</span>

<span class="kt">float</span> <span class="nf">ShadowCalculation</span><span class="p">(</span><span class="n">vec3</span> <span class="n">fragPos</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">[...]</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>           
    <span class="n">vec3</span> <span class="n">color</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">diffuseTexture</span><span class="p">,</span> <span class="n">fs_in</span><span class="p">.</span><span class="n">TexCoords</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
    <span class="n">vec3</span> <span class="n">normal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">fs_in</span><span class="p">.</span><span class="n">Normal</span><span class="p">);</span>
    <span class="n">vec3</span> <span class="n">lightColor</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">0.3</span><span class="p">);</span>
    <span class="c1">// Ambient
</span><span class="c1"></span>    <span class="n">vec3</span> <span class="n">ambient</span> <span class="o">=</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="n">color</span><span class="p">;</span>
    <span class="c1">// Diffuse
</span><span class="c1"></span>    <span class="n">vec3</span> <span class="n">lightDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">lightPos</span> <span class="o">-</span> <span class="n">fs_in</span><span class="p">.</span><span class="n">FragPos</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">lightDir</span><span class="p">,</span> <span class="n">normal</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>
    <span class="n">vec3</span> <span class="n">diffuse</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">*</span> <span class="n">lightColor</span><span class="p">;</span>
    <span class="c1">// Specular
</span><span class="c1"></span>    <span class="n">vec3</span> <span class="n">viewDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">viewPos</span> <span class="o">-</span> <span class="n">fs_in</span><span class="p">.</span><span class="n">FragPos</span><span class="p">);</span>
    <span class="n">vec3</span> <span class="n">reflectDir</span> <span class="o">=</span> <span class="n">reflect</span><span class="p">(</span><span class="o">-</span><span class="n">lightDir</span><span class="p">,</span> <span class="n">normal</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">spec</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="n">vec3</span> <span class="n">halfwayDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">lightDir</span> <span class="o">+</span> <span class="n">viewDir</span><span class="p">);</span>  
    <span class="n">spec</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">halfwayDir</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="mf">64.0</span><span class="p">);</span>
    <span class="n">vec3</span> <span class="n">specular</span> <span class="o">=</span> <span class="n">spec</span> <span class="o">*</span> <span class="n">lightColor</span><span class="p">;</span>    
    <span class="c1">// Calculate shadow
</span><span class="c1"></span>    <span class="kt">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">ShadowCalculation</span><span class="p">(</span><span class="n">fs_in</span><span class="p">.</span><span class="n">FragPos</span><span class="p">);</span>                      
    <span class="n">vec3</span> <span class="n">lighting</span> <span class="o">=</span> <span class="p">(</span><span class="n">ambient</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">shadow</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">diffuse</span> <span class="o">+</span> <span class="n">specular</span><span class="p">))</span> <span class="o">*</span> <span class="n">color</span><span class="p">;</span>    

    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">lighting</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>有一些细微的不同：光照代码一样，但我们现在有了一个uniform变量samplerCube，shadowCalculation函数用fragment的位置作为它的参数，取代了光空间的fragment位置。我们现在还要引入光的视锥的远平面值，后面我们会需要它。像素着色器的最后，我们计算出阴影元素，当fragment在阴影中时它是1.0，不在阴影中时是0.0。我们使用计算出来的阴影元素去影响光照的diffuse和specular元素。</p>
<p>在ShadowCalculation函数中有很多不同之处，现在是从立方体贴图中进行采样，不再使用2D纹理了。我们来一步一步的讨论一下的它的内容。</p>
<p>我们需要做的第一件事是获取立方体贴图的深度。你可能已经从教程的立方体贴图部分想到，我们已经将深度储存为fragment和光位置之间的距离了；我们这里采用相似的处理方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">float</span> <span class="nf">ShadowCalculation</span><span class="p">(</span><span class="n">vec3</span> <span class="n">fragPos</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vec3</span> <span class="n">fragToLight</span> <span class="o">=</span> <span class="n">fragPos</span> <span class="o">-</span> <span class="n">lightPos</span><span class="p">;</span> 
    <span class="kt">float</span> <span class="n">closestDepth</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">depthMap</span><span class="p">,</span> <span class="n">fragToLight</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这里，我们得到了fragment的位置与光的位置之间的不同的向量，使用这个向量作为一个方向向量去对立方体贴图进行采样。方向向量不需要是单位向量，所以无需对它进行标准化。最后的closestDepth是光源和它最接近的可见fragment之间的标准化的深度值。</p>
<p>closestDepth值现在在0到1的范围内了，所以我们先将其转换回0到far_plane的范围，这需要把他乘以far_plane：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">closestDepth</span> <span class="o">*=</span> <span class="n">far_plane</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>下一步我们获取当前fragment和光源之间的深度值，我们可以简单的使用fragToLight的长度来获取它，这取决于我们如何计算立方体贴图中的深度值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">float</span> <span class="n">currentDepth</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">fragToLight</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>返回的是和closestDepth范围相同的深度值。</p>
<p>现在我们可以将两个深度值对比一下，看看哪一个更接近，以此决定当前的fragment是否在阴影当中。我们还要包含一个阴影偏移，所以才能避免阴影失真，这在前面教程中已经讨论过了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">float</span> <span class="n">bias</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">;</span> 
<span class="kt">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">currentDepth</span> <span class="o">-</span>  <span class="n">bias</span> <span class="o">&gt;</span> <span class="n">closestDepth</span> <span class="o">?</span> <span class="mf">1.0</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>完整的ShadowCalculation现在变成了这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">float</span> <span class="nf">ShadowCalculation</span><span class="p">(</span><span class="n">vec3</span> <span class="n">fragPos</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Get vector between fragment position and light position
</span><span class="c1"></span>    <span class="n">vec3</span> <span class="n">fragToLight</span> <span class="o">=</span> <span class="n">fragPos</span> <span class="o">-</span> <span class="n">lightPos</span><span class="p">;</span>
    <span class="c1">// Use the light to fragment vector to sample from the depth map    
</span><span class="c1"></span>    <span class="kt">float</span> <span class="n">closestDepth</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">depthMap</span><span class="p">,</span> <span class="n">fragToLight</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>
    <span class="c1">// It is currently in linear range between [0,1]. Re-transform back to original value
</span><span class="c1"></span>    <span class="n">closestDepth</span> <span class="o">*=</span> <span class="n">far_plane</span><span class="p">;</span>
    <span class="c1">// Now get current linear depth as the length between the fragment and light position
</span><span class="c1"></span>    <span class="kt">float</span> <span class="n">currentDepth</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">fragToLight</span><span class="p">);</span>
    <span class="c1">// Now test for shadows
</span><span class="c1"></span>    <span class="kt">float</span> <span class="n">bias</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">;</span> 
    <span class="kt">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">currentDepth</span> <span class="o">-</span>  <span class="n">bias</span> <span class="o">&gt;</span> <span class="n">closestDepth</span> <span class="o">?</span> <span class="mf">1.0</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">shadow</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="csm联机阴影">CSM(联机阴影)</h3>
<p>事实上我们对远处的阴影要求并没有近处那么高，粗糙点无所谓，反正离得远也看不见，于是在此之上，出现了<strong>Cascaded ShadowMap</strong>，简称 <code>CSM</code>，它的做法是把相机的可视范围从近裁到远裁分割成N个子视锥，每个视锥渲一张ShadowMap。</p>
<h2 id="视差贴图视差映射">视差贴图（视差映射）</h2>
<blockquote>
<p>视差贴图背后的思想是修改纹理坐标使一个fragment的表面看起来比实际的更高或者更低，所有这些都根据观察方向和高度贴图。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">half3</span> <span class="n">view_tangentspace</span><span class="o">=</span><span class="n">normalize</span><span class="p">(</span><span class="n">mul</span><span class="p">(</span><span class="n">TBN</span><span class="p">,</span><span class="n">view_dir</span><span class="p">));</span> 
<span class="c1">// half2 uv_parallax = i.uv - (1.0-height) *view_tangentspace.xy/view_tangentspace.z*_Parallax;
</span><span class="c1"></span>                <span class="n">half2</span> <span class="n">uv_parallax</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">;</span>
				<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="n">half</span> <span class="n">height</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_ParallaxMap</span><span class="p">,</span> <span class="n">uv_parallax</span><span class="p">);</span>
					<span class="n">uv_parallax</span> <span class="o">=</span> <span class="n">uv_parallax</span> <span class="o">-</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">-</span> <span class="n">height</span><span class="p">)</span> <span class="o">*</span> <span class="n">view_tangentspace</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="n">_Parallax</span> <span class="o">*</span> <span class="mf">0.01f</span><span class="p">;</span>
				<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="衰减attenuation">衰减（Attenuation）</h3>
<p>在使用了gamma校正之后，另一个不同之处是光照衰减(Attenuation)。真实的物理世界中，光照的衰减和光源的距离的平方成反比。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">distance</span> <span class="o">*</span> <span class="n">distance</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>然而，当我们使用这个衰减公式的时候，衰减效果总是过于强烈，光只能照亮一小圈，看起来并不真实。出于这个原因，我们使用在基本光照教程中所讨论的那种衰减方程，它给了我们更大的控制权，此外我们还可以使用双曲线函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">distance</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>双曲线比使用二次函数变体在不用gamma校正的时候看起来更真实，不过但我们开启gamma校正以后线性衰减看起来太弱了，符合物理的二次函数突然出现了更好的效果。</p>
<h3 id="色调映射tone-mapping">色调映射(Tone Mapping)</h3>
<blockquote>
<p>色调映射(Tone Mapping)是一个损失很小的转换浮点颜色值至我们所需的LDR[0.0, 1.0]范围内的过程，通常会伴有特定的风格的色平衡(Stylistic Color Balance)</p>
</blockquote>
<p>ACES:<br>
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/eVUPOzmiYrNEocw.png"
        data-srcset="../../imgs/eVUPOzmiYrNEocw.png, ../../imgs/eVUPOzmiYrNEocw.png 1.5x, ../../imgs/eVUPOzmiYrNEocw.png 2x"
        data-sizes="auto"
        alt="../../imgs/eVUPOzmiYrNEocw.png"
        title="../../imgs/eVUPOzmiYrNEocw.png" /></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c">			<span class="n">float3</span> <span class="nf">ACESFilm</span><span class="p">(</span><span class="n">float3</span> <span class="n">x</span><span class="p">)</span> <span class="o">//</span> <span class="n">x</span> <span class="n">HDR</span> <span class="err">线性空间</span><span class="p">;</span><span class="err">返回值</span> <span class="n">LDR</span> 
			<span class="p">{</span>
				<span class="kt">float</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">2.51f</span><span class="p">;</span>
				<span class="kt">float</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">0.03f</span><span class="p">;</span>
				<span class="kt">float</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">2.43f</span><span class="p">;</span>
				<span class="kt">float</span> <span class="n">d</span> <span class="o">=</span> <span class="mf">0.59f</span><span class="p">;</span>
				<span class="kt">float</span> <span class="n">e</span> <span class="o">=</span> <span class="mf">0.14f</span><span class="p">;</span>
				<span class="k">return</span> <span class="nf">saturate</span><span class="p">((</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="n">e</span><span class="p">));</span>
			<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>最简单的色调映射算法是Reinhard色调映射，它涉及到分散整个HDR颜色值到LDR颜色值上，所有的值都有对应。Reinhard色调映射算法平均地将所有亮度值分散到LDR上。我们将Reinhard色调映射应用到之前的片段着色器上，并且为了更好的测量加上一个Gamma校正过滤(包括SRGB纹理的使用)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>             
    <span class="k">const</span> <span class="kt">float</span> <span class="n">gamma</span> <span class="o">=</span> <span class="mf">2.2</span><span class="p">;</span>
    <span class="n">vec3</span> <span class="n">hdrColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">hdrBuffer</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>

    <span class="c1">// Reinhard色调映射
</span><span class="c1"></span>    <span class="n">vec3</span> <span class="n">mapped</span> <span class="o">=</span> <span class="n">hdrColor</span> <span class="o">/</span> <span class="p">(</span><span class="n">hdrColor</span> <span class="o">+</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span>
    <span class="c1">// Gamma校正
</span><span class="c1"></span>    <span class="n">mapped</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">mapped</span><span class="p">,</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">));</span>

    <span class="n">color</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">mapped</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>   
</code></pre></td></tr></table>
</div>
</div><p>另一个有趣的色调映射应用是曝光(Exposure)参数的使用。你可能还记得之前我们在介绍里讲到的，HDR图片包含在不同曝光等级的细节。如果我们有一个场景要展现日夜交替，我们当然会在白天使用低曝光，在夜间使用高曝光，就像人眼调节方式一样。有了这个曝光参数，我们可以去设置可以同时在白天和夜晚不同光照条件工作的光照参数，我们只需要调整曝光参数就行了。</p>
<p>一个简单的曝光色调映射算法会像这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">uniform</span> <span class="kt">float</span> <span class="n">exposure</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>             
    <span class="k">const</span> <span class="kt">float</span> <span class="n">gamma</span> <span class="o">=</span> <span class="mf">2.2</span><span class="p">;</span>
    <span class="n">vec3</span> <span class="n">hdrColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">hdrBuffer</span><span class="p">,</span> <span class="n">TexCoords</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>

    <span class="c1">// 曝光色调映射
</span><span class="c1"></span>    <span class="n">vec3</span> <span class="n">mapped</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">hdrColor</span> <span class="o">*</span> <span class="n">exposure</span><span class="p">);</span>
    <span class="c1">// Gamma校正 
</span><span class="c1"></span>    <span class="n">mapped</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">mapped</span><span class="p">,</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">));</span>

    <span class="n">color</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">mapped</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><p>在这里我们将exposure定义为默认为1.0的uniform，从而允许我们更加精确设定我们是要注重黑暗还是明亮的区域的HDR颜色值。举例来说，高曝光值会使隧道的黑暗部分显示更多的细节，然而低曝光值会显著减少黑暗区域的细节，但允许我们看到更多明亮区域的细节。下面这组图片展示了在不同曝光值下的通道：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/4lSB17DCprqP5hd.png"
        data-srcset="../../imgs/4lSB17DCprqP5hd.png, ../../imgs/4lSB17DCprqP5hd.png 1.5x, ../../imgs/4lSB17DCprqP5hd.png 2x"
        data-sizes="auto"
        alt="../../imgs/4lSB17DCprqP5hd.png"
        title="../../imgs/4lSB17DCprqP5hd.png" /></p>
<p>这个图片清晰地展示了HDR渲染的优点。通过改变曝光等级，我们可以看见场景的很多细节，而这些细节可能在LDR渲染中都被丢失了。比如说隧道尽头，在正常曝光下木头结构隐约可见，但用低曝光木头的花纹就可以清晰看见了。对于近处的木头花纹来说，在高曝光下会能更好的看见。</p>
<h2 id="泛光bloom">泛光(Bloom)</h2>
<blockquote>
<p>提取亮度（阈值）&ndash;&gt; 降采样&ndash;&gt;升采样（叠加增加亮度）&ndash;&gt;合并（和原始图相加）</p>
</blockquote>
<h1 id="api笔记">API笔记</h1>
<h4 id="glgenbuffers">glGenBuffers</h4>
<p>generate buffer object names<br>
函数原型：<code>void glGenBuffers(GLsizei n,GLuint * buffers);   </code>
第一个参数是要生成的缓冲对象的数量，第二个是要输入用来存储缓冲对象名称的数组<br>
该函数会在buffers里返回n个缓冲对象的名称。</p>
<p>个人理解如下，可以声明一个GLuint变量，然后使用glGenBuffers后，它就会把缓冲对象保存在vbo里，当然也可以声明一个数组类型，那么创建的3个缓冲对象的名称会依次保存在数组里。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">//可以理解vbo是glGenBuffers分配内存缓冲区的指针或者地址，或者是一个名字代号，用来方便访问该内存缓冲区
</span><span class="c1"></span><span class="n">GLuint</span> <span class="n">vbo</span><span class="p">;</span>
<span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">&amp;</span><span class="n">vbo</span><span class="p">);</span>
<span class="n">GLuint</span> <span class="n">vbo</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">vbo</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>注意</strong>：这里我用的是VBO做的示范，解释一下，glGenBuffers()函数仅仅是生成一个缓冲对象的名称，这个缓冲对象并不具备任何意义，它仅仅是个缓冲对象，还不是一个顶点数组缓冲，它类似于C语言中的一个指针变量，我们可以分配内存对象并且用它的名称来引用这个内存对象。OpenGL有很多缓冲对象类型，那么这个缓冲对象到底是什么类型，就要用到下面的glBindBuffer()函数了。</p>
<p>glCreateBuffers和glGenBuffers一样，但是前者在opengl4.5开始支持，而后者支持所有版本。</p>
<h4 id="glbindbuffer">glBindBuffer</h4>
<p>bind a named buffer object<br>
函数原型：<code>void glBindBuffer(GLenum target,GLuint buffer);</code><br>
第一个就是缓冲对象的类型，第二个参数就是要绑定的缓冲对象的名称，也就是我们在上一个函数里生成的名称, 使用该函数将缓冲对象绑定到OpenGL上下文环境中以便使用。如果把target绑定到一个已经创建好的缓冲对象，那么这个缓冲对象将为当前target的<strong>激活对象</strong>；但是如果绑定的buffer值为0，那么OpenGL将不再对当前target使用任何缓存对象。</p>
<p><em>在OpenGL红宝书中给出了一个恰当的比喻：绑定对象的过程就像设置铁路的道岔开关，每一个缓冲类型中的各个对象就像不同的轨道一样，我们将开关设置为其中一个状态，那么之后的列车都会驶入这条轨道。</em></p>
<p><strong>切记</strong>：官方文档指出，GL_INVALID_VALUE is generated if buffer is not a name previously returned form a call to glGenBuffers。换句话说，这个名称虽然是GLuint类型的，但是你万万不能直接指定个常量比如说0,如果你这样做，就会出现GL_INVALID_VALUE的错误。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span>  <span class="c1">//VBO变成了一个顶点缓冲类型
</span><span class="c1"></span><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><em>OpenGL允许我们同时绑定多个缓冲类型，只要这些缓冲类型是不同的，换句话说，同一时间，不能绑定两个相同类型的缓冲对象。也可以理解为对于一个类型来说，同一时间只能“激活”一个类型，否则就会发生“矛盾”。</em></p>
<h4 id="glbufferdata">glBufferData</h4>
<p><code>void glBufferData（GLenum target,GLsizeiptr size,const GLvoid * data,GLenum usage）;</code><br>
<code>glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</code><br>
参数说明：</p>
<ul>
<li>
<p><code>target</code>  指定目标缓冲区对象。 符号常量必须为GL_ARRAY_BUFFER或GL_ELEMENT_ARRAY_BUFFER。</p>
</li>
<li>
<p><code>size</code>  指定缓冲区对象的新数据存储的大小（以字节为单位）。</p>
</li>
<li>
<p><code>data</code>  指定将复制到数据存储区以进行初始化的数据的指针，如果不复制数据，则指定NULL。</p>
<blockquote>
<p>果<code>data</code>为<code>NULL</code>，则仍会创建指定大小的数据存储，但其内容仍未初始化，因此被视为未定义的。</p>
</blockquote>
</li>
<li>
<p><code>usage</code>  指定数据存储的预期使用模式。 符号常量必须为GL_STREAM_DRAW，GL_STATIC_DRAW或GL_DYNAMIC_DRAW。</p>
</li>
</ul>
<p>glBufferData是一个专门用来把<strong>用户定义的数据复制到当前绑定缓冲</strong>(可以理解为从内存复制到显存缓冲区) 的函数。它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上。第二个参数指定传输数据的大小(以字节为单位)；用一个简单的sizeof计算出顶点数据大小就行。第三个参数是我们希望发送的实际数据。<br>
第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式：</p>
<ul>
<li>GL_STATIC_DRAW ：数据不会或几乎不会改变。</li>
<li>GL_DYNAMIC_DRAW：数据会被改变很多。</li>
<li>GL_STREAM_DRAW ：数据每次绘制时都会改变。</li>
</ul>
<h4 id="glvertexattribpointer">glVertexAttribPointer</h4>
<p><code>void glVertexAttribPointer( GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride,const GLvoid * pointer);</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>第一个参数指定我们要配置的顶点属性。还记得我们在顶点着色器中使用<code>layout(location = 0)</code>定义了<code>position</code>顶点属性的位置值(Location)吗？它可以把顶点属性的位置值设置为<code>0</code>。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入<code>0</code>。</li>
<li>第二个参数指定顶点属性的大小。顶点属性是一个<code>vec3</code>，它由3个值组成，所以大小是3。</li>
<li>第三个参数指定数据的类型，这里是GL_FLOAT(GLSL中<code>vec*</code>都是由浮点数值组成的)。</li>
<li>下个参数定义我们是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE。</li>
<li>第五个参数叫做<code>步长</code>(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个float之后，我们把步长设置为<code>3 * sizeof(float)</code>。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，我们在后面会看到更多的例子（译注: 这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节）。</li>
<li>最后一个参数的类型是<code>void*</code>，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。我们会在后面详细解释这个参数。</li>
</ul>
<blockquote>
<p>每个顶点属性从一个VBO管理的内存中获得它的数据，而具体是从哪个VBO（程序中可以有多个VBO）获取则是通过在调用glVertexAttribPointer时绑定到<code>GL_ARRAY_BUFFER</code>的VBO决定的。由于在调用glVertexAttribPointer之前绑定的是先前定义的VBO对象，顶点属性<code>0</code>现在会链接到它的顶点数据。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">8</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="mi">6</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)));</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="glenablevertexattribarray">glEnableVertexAttribArray</h4>
<p><code>glEnableVertexAttribArray(0);</code><br>
以顶点属性位置值作为参数，启用顶点属性；顶点属性默认是禁用的。</p>
<h4 id="gldrawarrays">glDrawArrays</h4>
<p><code>void GL_APIENTRY glDrawArrays (GLenum mode, GLint first, GLsizei count);</code><br>
参数说明：</p>
<ul>
<li>mode，绘制方式，OpenGL2.0以后提供以下参数：<code>GL_POINTS、GL_LINES、GL_LINE_LOOP、GL_LINE_STRIP、GL_TRIANGLES、GL_TRIANGLE_STRIP、GL_TRIANGLE_FAN</code>。</li>
<li>first，从数组缓存中的哪一位开始绘制，一般为0。</li>
<li>count，数组中顶点的数量。</li>
</ul>
<h4 id="gldrawelements">glDrawElements</h4>
<p><code>void glDrawElements( GLenum mode, GLsizei count, GLenum type, const GLvoid *indices）；</code>
参数说明：</p>
<ul>
<li>mode指定绘制图元的类型，它应该是下列值之一，GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON.</li>
<li>count为以mode类型连接的顶点的总数，且根据不同的mode，count小于或等于单个mode类型图元的顶点数*图元数</li>
<li>type为索引值的类型，只能是下列值之一：GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT。</li>
<li>indices：可以指定EBO中的偏移量（或者传递一个索引数组，但是这是当你不在使用索引缓冲对象的时候）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">EBO</span><span class="p">);</span>
<span class="n">glDrawElements</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">GL_UNSIGNED_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="glteximage2d">glTexImage2D</h4>
<p><code>void GL_APIENTRY glTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void* pixels);</code></p>
<p>参数说明：</p>
<ul>
<li>target 指定目标纹理，这个值必须是GL_TEXTURE_2D。</li>
<li>level 执行细节级别。0是最基本的图像级别，n表示第N级贴图细化级别。</li>
<li>internalformat 指定纹理中的颜色组件。可选的值有GL_ALPHA,GL_RGB,GL_RGBA,GL_LUMINANCE, GL_LUMINANCE_ALPHA 等几种。</li>
<li>width 指定纹理图像的宽度，必须是2的n次方。纹理图片至少要支持64个材质元素的宽度</li>
<li>height 指定纹理图像的高度，必须是2的m次方。纹理图片至少要支持64个材质元素的高度</li>
<li>border 指定边框的宽度。必须为0（历史遗留的问题）。</li>
<li>format 像素数据的颜色格式, 不需要和internalformatt取值必须相同。可选的值参考internalformat。</li>
<li>type 指定像素数据的数据类型。可以使用的值有GL_UNSIGNED_BYTE,GL_UNSIGNED_SHORT_5_6_5,GL_UNSIGNED_SHORT_4_4_4_4,GL_UNSIGNED_SHORT_5_5_5_1。</li>
<li>pixels 指定内存中指向图像数据的指针(真正的图像数据)</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="n">glGenerateMipmap</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="glbuffersubdata">glBufferSubData</h4>
<p><code>void glBufferSubData(    GLenum target,GLintptr offset,GLsizeiptr size,const GLvoid * data);</code><br>
<code>glBufferSubData(GL_ARRAY_BUFFER, 24, sizeof(data), &amp;data); // 范围： [24, 24 + sizeof(data)]</code><br>
参数说明：</p>
<ul>
<li><code>target</code> 指定目标缓冲区对象。符号常量必须为GL_ARRAY_BUFFER或GL_ELEMENT_ARRAY_BUFFER。</li>
<li><code>offset</code> 指定缓冲区对象的数据存储中的需要数据替换偏移量，以字节为单位进行测量。</li>
<li><code>size</code> 指定要替换的数据存储区域的大小（以字节为单位）。</li>
<li><code>data</code> 指定指向将复制到数据存储中的新数据的指针。</li>
</ul>
<p>glBufferSubData重新定义当前绑定到target的缓冲区对象的部分或全部数据存储。从字节偏移量offset开始并扩展为size字节的数据从data指向的存储器复制到数据存储器。如果offset和size一起定义超出缓冲区对象的数据存储边界的范围，则抛出错误。</p>
<p><strong>替换整个数据存储时，请考虑使用glBufferSubData而不是使用glBufferData完全重新创建数据存储。<code>这避免了重新分配数据存储的成本</code>。</strong></p>
<p>考虑使用多个缓冲区对象，以避免在数据存储更新期间停止渲染管道。如果管道中的任何渲染引用glBufferSubData正在更新的缓冲区对象中的数据，特别是来自正在更新的特定区域，则在更新数据存储之前，该渲染必须从管道中消失。</p>
<p><strong>客户端必须使数据元素与客户端平台的要求保持一致，并具有额外的基本级要求，即 <code>缓冲区内对包含N的数据的偏移量是N的倍数</code>。</strong></p>
<p><em><code>缓冲需要有足够的已分配内存</code>，所以对一个缓冲调用glBufferSubData之前必须要先调用glBufferData。</em></p>
<h4 id="glmapbuffer">glMapBuffer</h4>
<p>glMapBuffer用来将一个缓冲区对象中的数据映射为客户端中的地址空间<br>
<code>void *glMapBuffer(GLenum target,GLenum access);</code>
参数：</p>
<ul>
<li>target： 指定缓冲区的类型，参考glBufferData中的描述</li>
<li>access: 指定缓冲区对象中数据映射后的读写策略（可以只读、只写、或者读写），具体参数包括：
<table>
<thead>
<tr>
<th>取值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GL_READ_ONLY</td>
<td>只读</td>
</tr>
<tr>
<td>GL_WRITE_ONLY</td>
<td>只写</td>
</tr>
<tr>
<td>GL_READ_WRITE</td>
<td>读写</td>
</tr>
</tbody>
</table>
</li>
</ul>
<blockquote>
<p>备注：</p>
<ol>
<li>该函数返回的指针不能用于其他GL命令中</li>
<li>当我们对返回指针所做的操作与access中表示的使用方式不符时（比如access使用GL_WRITE_ONLY，但是我们在使用的时候去读取该指针所表示的数据（也就是我们使用了类似于GL_READ_ONLY的用法），会导致未定义的结果，应用程序可能会因此崩溃）</li>
<li>尽量使用access的方式与我们创建缓冲区对象所使用的标示一致，比如我们创建缓冲区对象的时候使用了GL_STATIC_READ，那么我们在使用access的时候使用GL_READ_ONLY，这样做可以更大程度的提升效率。</li>
</ol>
</blockquote>
<p>例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">float</span> <span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.35f</span>
  <span class="p">...</span>
<span class="p">};</span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
<span class="c1">// 获取指针
</span><span class="c1"></span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">glMapBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">GL_WRITE_ONLY</span><span class="p">);</span>
<span class="c1">// 复制数据到内存
</span><span class="c1"></span><span class="n">memcpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>
<span class="c1">// 记得告诉OpenGL我们不再需要这个指针了
</span><span class="c1"></span><span class="n">glUnmapBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>当我们使用glUnmapBuffer函数，告诉OpenGL我们已经完成指针操作之后，OpenGL就会知道你已经完成了。在解除映射(Unmapping)之后，指针将会不再可用，并且如果OpenGL能够成功将您的数据映射到缓冲中，这个函数将会返回GL_TRUE。</p>
<p><em>如果要直接映射数据到缓冲，而不事先将其存储到临时内存中，glMapBuffer这个函数会很有用。比如说，你可以从文件中读取数据，并直接将它们复制到缓冲内存中。</em></p>
<h4 id="glcopybuffersubdata">glCopyBufferSubData</h4>
<p>复制缓冲</p>
<blockquote>
<p>当你的缓冲已经填充好数据之后，你可能会想与其它的缓冲共享其中的数据，或者想要将缓冲的内容复制到另一个缓冲当中。glCopyBufferSubData能够让我们相对容易地从一个缓冲中复制数据到另一个缓冲中</p>
</blockquote>
<p><code>void glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset,GLintptr writeoffset, GLsizeiptr size);</code><br>
参数说明：</p>
<ul>
<li><code>readtarget</code> 指定应从中读取数据存储数据的目标。</li>
<li><code>writetarget</code> 指定应将数据存储数据写入的目标。</li>
<li><code>readoffset</code> 指定应从其读取数据的readtarget数据存储中以基本机器单位为单位的偏移量。</li>
<li><code>writeoffset</code> 指定基本目标机器单位中应写入数据的writetarget数据存储区中的偏移量。</li>
<li><code>size</code> 以基本机器单位指定要从readtarget复制到writetarget的数据的大小。</li>
</ul>
<p>下面这个例子展示了如何复制两个顶点数组缓冲：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">float</span> <span class="n">vertexData</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_COPY_READ_BUFFER</span><span class="p">,</span> <span class="n">vbo1</span><span class="p">);</span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_COPY_WRITE_BUFFER</span><span class="p">,</span> <span class="n">vbo2</span><span class="p">);</span>
<span class="n">glCopyBufferSubData</span><span class="p">(</span><span class="n">GL_COPY_READ_BUFFER</span><span class="p">,</span> <span class="n">GL_COPY_WRITE_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertexData</span><span class="p">));</span>
</code></pre></td></tr></table>
</div>
</div><p>我们也可以只将<code>writetarget</code>缓冲绑定为新的缓冲目标类型之一：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">float</span> <span class="n">vertexData</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">vbo1</span><span class="p">);</span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_COPY_WRITE_BUFFER</span><span class="p">,</span> <span class="n">vbo2</span><span class="p">);</span>
<span class="n">glCopyBufferSubData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">GL_COPY_WRITE_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertexData</span><span class="p">));</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="glvertexattribdivisor">glVertexAttribDivisor</h4>
<blockquote>
<p>这个函数告诉了OpenGL该什么时候更新顶点属性的内容至新一组数据<br>
<code>void glVertexAttribDivisor(GLuint index,GLuint divisor);</code>
参数说明：</p>
</blockquote>
<ul>
<li><code>index</code>:指定常规顶点属性的索引。</li>
<li><code>divisor</code>:属性除数(Attribute Divisor), 指定在索引处的泛型属性更新之间传递的实例数。
<blockquote>
<p>默认情况下，属性除数是0，告诉OpenGL我们需要在顶点着色器的每次迭代时更新顶点属性。将它设置为1时，我们告诉OpenGL我们希望在渲染一个新实例的时候更新顶点属性。而设置为2时，我们希望每2个实例更新一次属性，以此类推</p>
</blockquote>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">instanceVBO</span><span class="p">);</span>
<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>   
<span class="c1">//我们将属性除数设置为1，是在告诉OpenGL，处于位置值2的顶点属性是一个实例化数组。
</span><span class="c1"></span><span class="n">glVertexAttribDivisor</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>举例：
<code>vertex shader</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#version 330 core
</span><span class="cp"></span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aPos</span><span class="p">;</span>
<span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">aTexCoords</span><span class="p">;</span>
<span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="n">in</span> <span class="n">mat4</span> <span class="n">aInstanceMatrix</span><span class="p">;</span>

<span class="n">out</span> <span class="n">vec2</span> <span class="n">TexCoords</span><span class="p">;</span>

<span class="n">uniform</span> <span class="n">mat4</span> <span class="n">projection</span><span class="p">;</span>
<span class="n">uniform</span> <span class="n">mat4</span> <span class="n">view</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">TexCoords</span> <span class="o">=</span> <span class="n">aTexCoords</span><span class="p">;</span>
    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="n">view</span> <span class="o">*</span> <span class="n">aInstanceMatrix</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span> 
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>c++部分代码：
<strong>顶点属性最大允许的数据大小等于一个vec4</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buffer</span><span class="p">;</span>
    <span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">);</span>
    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
    <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">amount</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">modelMatrices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
        <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
        <span class="c1">//顶点属性最大允许的数据大小等于一个vec4
</span><span class="c1"></span>        <span class="c1">// set attribute pointers for matrix (4 times vec4)
</span><span class="c1"></span>        <span class="c1">//glVertexAttribPointer不能传入为矩阵的类型，最大是个Vec4，所以矩阵分四列进行4次传入，传入4个Vec4组成矩阵
</span><span class="c1"></span>
        <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
        <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
        <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="p">)));</span>
        <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
        <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="p">)));</span>
        <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
        <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="p">)));</span>

        <span class="n">glVertexAttribDivisor</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">glVertexAttribDivisor</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">glVertexAttribDivisor</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">glVertexAttribDivisor</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

        <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><em>让我们能够存储一个实例化数组的变换矩阵。然而，当我们顶点属性的类型大于vec4时，就要多进行一步处理了。顶点属性最大允许的数据大小等于一个vec4。因为一个mat4本质上是4个vec4，我们需要为这个矩阵预留4个顶点属性。因为我们将它的位置值设置为3，矩阵每一列的顶点属性位置值就是3、4、5和6。</em></p>
</blockquote>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../imgs/fgPtQlxYubMGUwN.png"
        data-srcset="../../imgs/fgPtQlxYubMGUwN.png, ../../imgs/fgPtQlxYubMGUwN.png 1.5x, ../../imgs/fgPtQlxYubMGUwN.png 2x"
        data-sizes="auto"
        alt="../../imgs/fgPtQlxYubMGUwN.png"
        title="../../imgs/fgPtQlxYubMGUwN.png" /></p>
<blockquote>
<p>根据RenderDoc的顶点输入数据可见：
Location索引为0和2属性的Divisor=0；索引3属性的Divisor=1；<br>
索引3，4，5，6组成索引3的矩阵<br>
<code>不明白0和1有啥区别？？？</code></p>
</blockquote></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2020-09-27 16:03:56</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://codingriver.github.io/opengl%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" data-hashtag="opengl"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 WhatsApp" data-sharer="whatsapp" data-url="https://codingriver.github.io/opengl%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" data-title="OpenGL 图形学记录" data-web><i class="fab fa-whatsapp fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://codingriver.github.io/opengl%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" data-title="OpenGL 图形学记录"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/line.svg"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://codingriver.github.io/opengl%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" data-title="OpenGL 图形学记录" data-ralateuid="xxxx"><i class="fab fa-weibo fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Myspace" data-sharer="myspace" data-url="https://codingriver.github.io/opengl%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" data-title="OpenGL 图形学记录" data-description=""><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/myspace.svg"></i></a><a href="javascript:void(0);" title="分享到 Blogger" data-sharer="blogger" data-url="https://codingriver.github.io/opengl%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" data-title="OpenGL 图形学记录" data-description=""><i class="fab fa-blogger fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Evernote" data-sharer="evernote" data-url="https://codingriver.github.io/opengl%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" data-title="OpenGL 图形学记录"><i class="fab fa-evernote fa-fw"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/opengl/">opengl</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/csharp%E8%AE%B0%E5%BD%95/" class="prev" rel="prev" title="C# 记录"><i class="fas fa-angle-left fa-fw"></i>C# 记录</a>
            <a href="/ugui-text%E6%8D%A2%E8%A1%8C%E9%97%AE%E9%A2%98/" class="next" rel="next" title="UGUI Text换行问题">UGUI Text换行问题<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="valine" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://valine.js.org/">Valine</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.74.3">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2020 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">codingriver</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/valine/valine.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.2.0/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/twemoji@13.0.0/dist/twemoji.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{"valine":{"appId":"TU9HHvqYbHWiqJGgbDQXTTHy-gzGzoHsz","appKey":"dN7hDY1PObmpH2SGFBNkIv88","avatar":"mp","el":"#valine","emojiCDN":"https://cdn.jsdelivr.net/npm/emoji-datasource-google@5.0.1/img/google/64/","emojiMaps":{"100":"1f4af.png","alien":"1f47d.png","anger":"1f4a2.png","angry":"1f620.png","anguished":"1f627.png","astonished":"1f632.png","black_heart":"1f5a4.png","blue_heart":"1f499.png","blush":"1f60a.png","bomb":"1f4a3.png","boom":"1f4a5.png","broken_heart":"1f494.png","brown_heart":"1f90e.png","clown_face":"1f921.png","cold_face":"1f976.png","cold_sweat":"1f630.png","confounded":"1f616.png","confused":"1f615.png","cry":"1f622.png","crying_cat_face":"1f63f.png","cupid":"1f498.png","dash":"1f4a8.png","disappointed":"1f61e.png","disappointed_relieved":"1f625.png","dizzy":"1f4ab.png","dizzy_face":"1f635.png","drooling_face":"1f924.png","exploding_head":"1f92f.png","expressionless":"1f611.png","face_vomiting":"1f92e.png","face_with_cowboy_hat":"1f920.png","face_with_hand_over_mouth":"1f92d.png","face_with_head_bandage":"1f915.png","face_with_monocle":"1f9d0.png","face_with_raised_eyebrow":"1f928.png","face_with_rolling_eyes":"1f644.png","face_with_symbols_on_mouth":"1f92c.png","face_with_thermometer":"1f912.png","fearful":"1f628.png","flushed":"1f633.png","frowning":"1f626.png","ghost":"1f47b.png","gift_heart":"1f49d.png","green_heart":"1f49a.png","grimacing":"1f62c.png","grin":"1f601.png","grinning":"1f600.png","hankey":"1f4a9.png","hear_no_evil":"1f649.png","heart":"2764-fe0f.png","heart_decoration":"1f49f.png","heart_eyes":"1f60d.png","heart_eyes_cat":"1f63b.png","heartbeat":"1f493.png","heartpulse":"1f497.png","heavy_heart_exclamation_mark_ornament":"2763-fe0f.png","hole":"1f573-fe0f.png","hot_face":"1f975.png","hugging_face":"1f917.png","hushed":"1f62f.png","imp":"1f47f.png","innocent":"1f607.png","japanese_goblin":"1f47a.png","japanese_ogre":"1f479.png","joy":"1f602.png","joy_cat":"1f639.png","kiss":"1f48b.png","kissing":"1f617.png","kissing_cat":"1f63d.png","kissing_closed_eyes":"1f61a.png","kissing_heart":"1f618.png","kissing_smiling_eyes":"1f619.png","laughing":"1f606.png","left_speech_bubble":"1f5e8-fe0f.png","love_letter":"1f48c.png","lying_face":"1f925.png","mask":"1f637.png","money_mouth_face":"1f911.png","nauseated_face":"1f922.png","nerd_face":"1f913.png","neutral_face":"1f610.png","no_mouth":"1f636.png","open_mouth":"1f62e.png","orange_heart":"1f9e1.png","partying_face":"1f973.png","pensive":"1f614.png","persevere":"1f623.png","pleading_face":"1f97a.png","pouting_cat":"1f63e.png","purple_heart":"1f49c.png","rage":"1f621.png","relaxed":"263a-fe0f.png","relieved":"1f60c.png","revolving_hearts":"1f49e.png","right_anger_bubble":"1f5ef-fe0f.png","robot_face":"1f916.png","rolling_on_the_floor_laughing":"1f923.png","scream":"1f631.png","scream_cat":"1f640.png","see_no_evil":"1f648.png","shushing_face":"1f92b.png","skull":"1f480.png","skull_and_crossbones":"2620-fe0f.png","sleeping":"1f634.png","sleepy":"1f62a.png","slightly_frowning_face":"1f641.png","slightly_smiling_face":"1f642.png","smile":"1f604.png","smile_cat":"1f638.png","smiley":"1f603.png","smiley_cat":"1f63a.png","smiling_face_with_3_hearts":"1f970.png","smiling_imp":"1f608.png","smirk":"1f60f.png","smirk_cat":"1f63c.png","sneezing_face":"1f927.png","sob":"1f62d.png","space_invader":"1f47e.png","sparkling_heart":"1f496.png","speak_no_evil":"1f64a.png","speech_balloon":"1f4ac.png","star-struck":"1f929.png","stuck_out_tongue":"1f61b.png","stuck_out_tongue_closed_eyes":"1f61d.png","stuck_out_tongue_winking_eye":"1f61c.png","sunglasses":"1f60e.png","sweat":"1f613.png","sweat_drops":"1f4a6.png","sweat_smile":"1f605.png","thinking_face":"1f914.png","thought_balloon":"1f4ad.png","tired_face":"1f62b.png","triumph":"1f624.png","two_hearts":"1f495.png","unamused":"1f612.png","upside_down_face":"1f643.png","weary":"1f629.png","white_frowning_face":"2639-fe0f.png","white_heart":"1f90d.png","wink":"1f609.png","woozy_face":"1f974.png","worried":"1f61f.png","yawning_face":"1f971.png","yellow_heart":"1f49b.png","yum":"1f60b.png","zany_face":"1f92a.png","zipper_mouth_face":"1f910.png","zzz":"1f4a4.png"},"enableQQ":false,"highlight":true,"lang":"zh-cn","pageSize":10,"placeholder":"説点啥吧...","recordIP":true,"serverURLs":"https://tu9hhvqy.lc-cn-n1-shared.com","visitor":true}},"search":{"algoliaAppID":"KLY81C70FD","algoliaIndex":"index","algoliaSearchKey":"f07750bedf42546c5e3339e308d17b97","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"twemoji":true};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
